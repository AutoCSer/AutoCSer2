# 内存数据库 - 自定义节点
AutoCSer 内存数据库可扩展**支持面向对象编程**，允许开发者根据实际业务需求以**自定义节点**的方式使用 C# 代码实现任意数据结构与 API 业务逻辑，可以**满足复杂业务需求**，并且可以大幅**提升数据访问层的开发与维护效率**。
# 实现一个简单的计数器
## 1. 定义节点 API 接口
[节点接口定义](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/CounterNode/ICounterNode.cs)需要使用 **public partial** 修饰，并且添加 [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Server/ServerNodeAttribute.cs) 配置，因为需要使用 AutoCSer 的[静态代码生成](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/05.CodeGenerator.md)功能生成 API 方法编号与**客户端接口**代码。当然你也可以不使用静态代码生成功能，手写相关代码，不过这种做法容易出错。  
节点 API 方法则使用 [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethodAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Server/ServerMethodAttribute.cs) 配置，**不允许 API 方法名称重复**，不支持泛型方法。  
节点 API 默认配置 IsPersistence 为 true 表示 API 调用需要持久化操作（所有存在修改持久化数据的 API 都应该使用默认配置），如果确认 API 仅读取数据而不会使内存数据状态产生业务上的变化则应该将 IsPersistence 设置为 false 避免不必要的数据持久化操作。  
将 SnapshotMethodSort 设置为非 0 值表示**加载快照数据的方法**，该方法返回值类型必须为 void，且唯一的参数类型必须与**快照接口的泛型类型**保持一致，通常还应该同时设置 IsClientCall = false 以禁止客户端请求访问。
``` csharp
    /// <summary>
    /// 计数器节点接口示例
    /// </summary>
    [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode]
    public partial interface ICounterNode
    {
        /// <summary>
        /// 加载快照数据（从快照数据恢复内存数据）
        /// </summary>
        /// <param name="value">data</param>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethod(IsClientCall = false, SnapshotMethodSort = 1)]
        void SnapshotSet(long value);
        /// <summary>
        /// 计数 +1
        /// </summary>
        void Increment();
        /// <summary>
        /// 获取当前计数
        /// </summary>
        /// <returns>当前计数</returns>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethod(IsPersistence = false)]
        long GetCount();
    }
```
## 2. 实现计数器功能
[节点实例](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/CounterNode/CounterNode.cs)需要实现节点接口功能：
``` csharp
    /// <summary>
    /// 计数器节点示例
    /// </summary>
    public sealed class CounterNode : ICounterNode
    {
        /// <summary>
        /// 当前计数
        /// </summary>
        private long count;
        /// <summary>
        /// 加载快照数据（从快照数据恢复内存数据）
        /// </summary>
        /// <param name="value">data</param>
        public void SnapshotSet(long value)
        {
            count = value;
        }
        /// <summary>
        /// 计数 +1
        /// </summary>
        public void Increment()
        {
            ++count;
        }
        /// <summary>
        /// 获取当前计数
        /// </summary>
        /// <returns>当前计数</returns>
        public long GetCount()
        {
            return count;
        }
    }
```
## 3. 实现快照接口
快照功能由两部分组成，除了加载快照数据的方法用于**恢复内存数据**，还需要实现接口 [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Snapshot/ISnapshot.cs) 或者 [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IEnumerableSnapshot<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Snapshot/IEnumerableSnapshot.cs) 用于持久化操作时将**内存数据转换为可序列化数据**的集合。  
对于没有实现快照功能的节点，在数据库持久化重建以后会丢失历史数据，也就是说要建立**可靠持久化的节点必须实现快照功能**，否则只能当作内存缓存数据使用。  
快照数据对象集合中**不允许存在 null 值**，否则会造成数据库持久化重建失败，[当前示例](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/CounterNode/CounterNode.cs)使用单值快照 [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.SnapshotGetValue<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Snapshot/SnapshotGetValue.cs) 实例。
``` csharp
    /// <summary>
    /// 计数器节点示例
    /// </summary>
    public sealed class CounterNode : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IEnumerableSnapshot<long>
    {
        /// <summary>
        /// 单值快照
        /// </summary>
        AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshotEnumerable<long> AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IEnumerableSnapshot<long>.SnapshotEnumerable { get { return new AutoCSer.CommandService.StreamPersistenceMemoryDatabase.SnapshotGetValue<long>(GetCount); } }
    }
```
## 4. 自定义基础服务节点
存在自定义节点的内存数据库服务，**必须提供**内置基础服务节点类型 [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServiceNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ServiceNode.cs) 的派生类实现，并且[必须直接显式继承](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/ICustomServiceNode.cs)接口 [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IServiceNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IServiceNode.cs)，该节点主要用于定义[创建节点](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/CustomServiceNode.cs)的 API 方法。
``` csharp
    /// <summary>
    /// 自定义基础服务节点接口
    /// </summary>
    [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode]
    public partial interface ICustomServiceNode : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IServiceNode
    {
        /// <summary>
        /// 创建计数器节点 ICounterNode
        /// </summary>
        /// <param name="index">节点索引信息</param>
        /// <param name="key">节点全局关键字</param>
        /// <param name="nodeInfo">服务端节点信息</param>
        /// <returns>节点标识，已经存在节点则直接返回</returns>
        AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex CreateCounterNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo);
    }
    
    /// <summary>
    /// 自定义基础服务节点，用于添加自定义节点创建 API 方法
    /// </summary>
    public sealed class CustomServiceNode : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServiceNode, ICustomServiceNode
    {
        /// <summary>
        /// 自定义基础服务节点
        /// </summary>
        /// <param name="service">日志流持久化内存数据库服务</param>
        public CustomServiceNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabaseService service) : base(service) { }
        /// <summary>
        /// 创建计数器节点 ICounterNode
        /// </summary>
        /// <param name="index">节点索引信息</param>
        /// <param name="key">节点全局关键字</param>
        /// <param name="nodeInfo">服务端节点信息</param>
        /// <returns>节点标识，已经存在节点则直接返回</returns>
        public AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex CreateCounterNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo)
        {
            return CreateSnapshotNode<ICounterNode>(index, key, nodeInfo, () => new CounterNode());
        }
    }
```
## 5. 静态代码生成
具体配置方法参考[静态代码生成](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/05.CodeGenerator.md)，生成的 {$(ProjectName)}.AutoCSer.cs 文件中包含用于路由的 API 方法编号与[客户端接口代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/%7BAutoCSer.Document.MemoryDatabaseCustomNode%7D.AutoCSer.cs)，比如：
``` csharp
        /// <summary>
        /// 计数器节点接口示例 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.Document.MemoryDatabaseCustomNode.ICounterNode))]
        public partial interface ICounterNodeClientNode
        {
            /// <summary>
            /// 获取当前计数
            /// </summary>
            /// <returns>当前计数</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<long> GetCount();
            /// <summary>
            /// 计数 +1
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Increment();
        }
        
        /// <summary>
        /// 自定义基础服务节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.Document.MemoryDatabaseCustomNode.ICustomServiceNode))]
        public partial interface ICustomServiceNodeClientNode : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IServiceNodeClientNode
        {
            /// <summary>
            /// 创建计数器节点 ICounterNode
            /// </summary>
            /// <param name="index">节点索引信息</param>
            /// <param name="key">节点全局关键字</param>
            /// <param name="nodeInfo">服务端节点信息</param>
            /// <returns>节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateCounterNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo);
        }
```
## 6. 创建 RPC 服务端监听
创建服务端监听可以参考内置数据结构节点，区别在于创建内存数据库服务实例的方法不一样，下面给出两份代码的对比。[内置节点代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Program.cs)如下：
``` csharp
            AutoCSer.CommandService.StreamPersistenceMemoryDatabaseService databaseService = databaseServiceConfig.Create();
```
自定义节点则需要[创建自定义基础服务节点](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/Program.cs)，代码如下：
``` csharp
            AutoCSer.Document.MemoryDatabaseCustomNode.ServiceConfig databaseServiceConfig = new AutoCSer.Document.MemoryDatabaseCustomNode.ServiceConfig
            {
                PersistencePath = Path.Combine(AutoCSer.TestCase.Common.Config.AutoCSerTemporaryFilePath, nameof(AutoCSer.Document.MemoryDatabaseCustomNode)),
                PersistenceSwitchPath = Path.Combine(AutoCSer.TestCase.Common.Config.AutoCSerTemporaryFilePath, nameof(AutoCSer.Document.MemoryDatabaseCustomNode) + nameof(AutoCSer.Document.MemoryDatabaseCustomNode.ServiceConfig.PersistenceSwitchPath))
            };
            AutoCSer.CommandService.StreamPersistenceMemoryDatabaseService databaseService = databaseServiceConfig.Create<ICustomServiceNode>(p => new CustomServiceNode(p));
```
## 7. 创建 RPC 客户端
创建 RPC 客户端与内置节点的区别在于创建的**客户端单例**的类型不同，内置节点创建的客户端单例类型为 [AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientCache<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Client/StreamPersistenceMemoryDatabaseClientCache.cs)，[示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/CommandClientSocketEvent.cs)如下：
``` csharp
        /// <summary>
        /// 日志流持久化内存数据库客户端单例
        /// </summary>
        public static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientCache<CommandClientSocketEvent> StreamPersistenceMemoryDatabaseClientCache = new AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientCache<CommandClientSocketEvent>(new AutoCSer.Net.CommandClientConfig
        {
            Host = new AutoCSer.Net.HostEndPoint((ushort)AutoCSer.TestCase.Common.CommandServerPortEnum.Document),
            GetSocketEventDelegate = (client) => new CommandClientSocketEvent(client)
        });
```
自定义节点则需要传参**自定义基础服务节点生成的客户端节点接口类型**，自定义节点创建的客户端单例类型为 [AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientCache<NT, ET>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Client/StreamPersistenceMemoryDatabaseClientCache.cs)，[示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/Client/CommandClientSocketEvent.cs)如下：
``` csharp
        /// <summary>
        /// 日志流持久化内存数据库客户端单例
        /// </summary>
        public static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientCache<ICustomServiceNodeClientNode, CommandClientSocketEvent> StreamPersistenceMemoryDatabaseClientCache = new AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientCache<ICustomServiceNodeClientNode, CommandClientSocketEvent>(new AutoCSer.Net.CommandClientConfig
        {
            Host = new AutoCSer.Net.HostEndPoint((ushort)AutoCSer.TestCase.Common.CommandServerPortEnum.Document),
            GetSocketEventDelegate = (client) => new CommandClientSocketEvent(client)
        });
```
## 8. 创建客户端节点
内置节点在客户端 [AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClient<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Client/StreamPersistenceMemoryDatabaseClient.cs) 中封装有直接返回客户端节点的方法，而[自定义节点](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/Client/CounterNode.cs)则需要开发者自己**根据实际情况调用创建客户端节点的方法**，具体用法可以参考内置节点的封装方法。
``` csharp
    /// <summary>
    /// 计数器节点客户端示例
    /// </summary>
    internal static class CounterNode
    {
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<ICounterNodeClientNode> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateNode<ICounterNodeClientNode>(nameof(CounterNode), client.ClientNode.CreateCounterNode));
        /// <summary>
        /// 计数器节点客户端示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            ICounterNodeClientNode node = nodeResult.Value.notNull();
            var valueResult = await node.GetCount();
            if (!valueResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var result = await node.Increment();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var nextResult = await node.GetCount();
            if (!nextResult.IsSuccess || nextResult.Value != valueResult.Value + 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
# 泛型数据结构节点
上面的计数器节点的一个实例只能记录一个数量值，如果需要给大量用户添加计数功能，那么需要创建大量节点实例才能满足需求，在这种需求场景中我们应该创建一个[集合性质的节点](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/DictionaryCounterNode/IDictionaryCounterNode.cs)。
## 1. 定义泛型节点 API 接口
``` csharp
    /// <summary>
    /// 字典计数器节点接口示例
    /// </summary>
    /// <typeparam name="T">关键字类型</typeparam>
    [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode]
    public partial interface IDictionaryCounterNode<T> where T : IEquatable<T>
    {
        /// <summary>
        /// 加载快照数据（从快照数据恢复内存数据）
        /// </summary>
        /// <param name="value">data</param>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethod(IsClientCall = false, SnapshotMethodSort = 1)]
        void SnapshotSet(BinarySerializeKeyValue<T, long> value);
        /// <summary>
        /// 计数 +1
        /// </summary>
        /// <param name="key">计数关键字</param>
        /// <returns>key 为 null 则返回 false</returns>
        bool Increment(T key);
        /// <summary>
        /// 获取当前计数
        /// </summary>
        /// <param name="key">计数关键字</param>
        /// <returns>key 为 null 则返回 -1</returns>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethod(IsPersistence = false)]
        long GetCount(T key);
        /// <summary>
        /// 删除计数
        /// </summary>
        /// <param name="key">计数关键字</param>
        /// <returns>返回 false 表示关键字不存在</returns>
        bool Remove(T key);
    }
```
## 2. 实现泛型字典计数器功能
[节点实例](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/DictionaryCounterNode/DictionaryCounterNode.cs)需要实现节点接口功能：
``` csharp
    /// <summary>
    /// 字典计数器节点示例
    /// </summary>
    /// <typeparam name="T">关键字类型</typeparam>
    public sealed class DictionaryCounterNode<T> : IDictionaryCounterNode<T>
        where T : IEquatable<T>
    {
        /// <summary>
        /// 字典计数器
        /// </summary>
        private Dictionary<T, long> counts;
        /// <summary>
        /// 字典计数器节点示例
        /// </summary>
        /// <param name="capacity">容器初始化大小</param>
        internal DictionaryCounterNode(int capacity)
        {
            counts = DictionaryCreator<T>.Create<long>(capacity);
        }
        /// <summary>
        /// 加载快照数据（从快照数据恢复内存数据）
        /// </summary>
        /// <param name="value">data</param>
        public void SnapshotSet(BinarySerializeKeyValue<T, long> value)
        {
            counts.Add(value.Key, value.Value);
        }
        /// <summary>
        /// 计数 +1
        /// </summary>
        /// <param name="key">计数关键字</param>
        /// <returns>key 为 null 则返回 false</returns>
        public bool Increment(T key)
        {
            if (key != null)
            {
                if (counts.TryGetValue(key, out long count)) counts[key] = count + 1;
                else counts.Add(key, 1);
                return true;
            }
            return false;
        }
        /// <summary>
        /// 获取当前计数
        /// </summary>
        /// <param name="key">计数关键字</param>
        /// <returns>key 为 null 则返回 -1</returns>
        public long GetCount(T key)
        {
            if (key != null) return counts.TryGetValue(key, out long count) ? count : 0;
            return -1;
        }
        /// <summary>
        /// 删除计数
        /// </summary>
        /// <param name="key">计数关键字</param>
        /// <returns>返回 false 表示关键字不存在</returns>
        public bool Remove(T key)
        {
            return key != null && counts.Remove(key);
        }
    }
```
## 3. 实现集合快照接口
[节点实例](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/DictionaryCounterNode/DictionaryCounterNode.cs)需要实现快照接口功能：
``` csharp
    /// <summary>
    /// 字典计数器节点示例
    /// </summary>
    /// <typeparam name="T">关键字类型</typeparam>
    public sealed class DictionaryCounterNode<T> : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<BinarySerializeKeyValue<T, long>>
    {
        /// <summary>
        /// 获取快照数据集合容器大小，用于预申请快照数据容器
        /// </summary>
        /// <param name="customObject">自定义对象，用于预生成辅助数据</param>
        /// <returns>快照数据集合容器大小</returns>
        int AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<BinarySerializeKeyValue<T, long>>.GetSnapshotCapacity(ref object customObject)
        {
            return counts.Count;
        }
        /// <summary>
        /// 获取快照数据集合，如果数据对象可能被修改则应该返回克隆数据对象防止建立快照期间数据被修改
        /// </summary>
        /// <param name="snapshotArray">预申请的快照数据容器</param>
        /// <param name="customObject">自定义对象，用于预生成辅助数据</param>
        /// <returns>快照数据</returns>
        AutoCSer.CommandService.StreamPersistenceMemoryDatabase.SnapshotResult<BinarySerializeKeyValue<T, long>> AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<BinarySerializeKeyValue<T, long>>.GetSnapshotResult(BinarySerializeKeyValue<T, long>[] snapshotArray, object customObject)
        {
            return AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode.GetSnapshotResult(counts, snapshotArray);
        }
        /// <summary>
        /// 持久化之前重组快照数据
        /// </summary>
        /// <param name="array">预申请的快照数据容器</param>
        /// <param name="newArray">超出预申请范围的快照数据集合</param>
        void AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<BinarySerializeKeyValue<T, long>>.SetSnapshotResult(ref LeftArray<BinarySerializeKeyValue<T, long>> array, ref LeftArray<BinarySerializeKeyValue<T, long>> newArray) { }
    }
```
## 4. 创建节点实例
在自定义基础服务节点添加[创建节点实例的 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/ICustomServiceNode.cs)，由于节点 API 不支持泛型方法，所以泛型类型参数需要转换为 [AutoCSer.Reflection.RemoteType](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Reflection/RemoteType.cs) 传参，服务端需要手动转换为 Type 类型，然后[使用反射操作创建泛型节点](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/CustomServiceNode.cs)。
``` csharp
    /// <summary>
    /// 自定义基础服务节点接口
    /// </summary>
    [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode]
    public partial interface ICustomServiceNode : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IServiceNode
    {
        /// <summary>
        /// 创建字典计数器节点 IDictionaryCounterNode{T}
        /// </summary>
        /// <param name="index">节点索引信息</param>
        /// <param name="key">节点全局关键字</param>
        /// <param name="nodeInfo">服务端节点信息</param>
        /// <param name="keyType">关键字类型</param>
        /// <param name="capacity">容器初始化大小</param>
        /// <returns>节点标识，已经存在节点则直接返回</returns>
        AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex CreateDictionaryCounterNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int capacity);
    }
    
    /// <summary>
    /// 自定义基础服务节点，用于添加自定义节点创建 API 方法
    /// </summary>
    public sealed class CustomServiceNode : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServiceNode, ICustomServiceNode
    {
        /// <summary>
        /// 创建字典计数器节点 IDictionaryCounterNode{T}
        /// </summary>
        /// <param name="index">节点索引信息</param>
        /// <param name="key">节点全局关键字</param>
        /// <param name="nodeInfo">服务端节点信息</param>
        /// <param name="keyType">关键字类型</param>
        /// <param name="capacity">容器初始化大小</param>
        /// <returns>节点标识，已经存在节点则直接返回</returns>
        public AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex CreateDictionaryCounterNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int capacity)
        {
            var type = default(Type);
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum state = getEquatableType(ref keyType, ref type);
            if (state == AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum.Success)
            {
                MethodInfo method = typeof(CustomServiceNode).GetMethod(nameof(createDictionaryCounterNode), BindingFlags.Instance | BindingFlags.NonPublic).notNull();
                return (AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex)method.MakeGenericMethod(type.notNull()).Invoke(this, new object[] { index, key, nodeInfo, capacity }).notNull();
            }
            return new AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex(state);
        }
        /// <summary>
        /// 创建字典计数器节点 IDictionaryCounterNode{T}
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="index">节点索引信息</param>
        /// <param name="key">节点全局关键字</param>
        /// <param name="nodeInfo">服务端节点信息</param>
        /// <param name="capacity">容器初始化大小</param>
        /// <returns>节点标识，已经存在节点则直接返回</returns>
        private AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex createDictionaryCounterNode<T>(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, int capacity)
            where T : IEquatable<T>
        {
            return CreateSnapshotNode<IDictionaryCounterNode<T>>(index, key, nodeInfo, () => new DictionaryCounterNode<T>(capacity));
        }
    }
```
## 5. 静态代码生成
具体配置方法参考[静态代码生成](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/05.CodeGenerator.md)，生成的 {$(ProjectName)}.AutoCSer.cs 文件中包含用于路由的 API 方法编号与客户端接口代码。
## 6. 创建客户端节点
泛型类型参数需要转换为 [AutoCSer.Reflection.RemoteType](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Reflection/RemoteType.cs) 传参，[示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/Client/DictionaryCounterNode.cs)如下：
``` csharp
    /// <summary>
    /// 字典计数器节点客户端示例
    /// </summary>
    internal static class DictionaryCounterNode
    {
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<IDictionaryCounterNodeClientNode<int>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateNode<IDictionaryCounterNodeClientNode<int>>(nameof(DictionaryCounterNode), (index, key, nodeInfo) => client.ClientNode.CreateDictionaryCounterNode(index, key, nodeInfo, typeof(int), 0)));
        /// <summary>
        /// 字典计数器节点客户端示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            IDictionaryCounterNodeClientNode<int> node = nodeResult.Value.notNull();
            //测试用户ID 为 1 的计数器
            int key = 1;
            var valueResult = await node.GetCount(key);
            if (!valueResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var result = await node.Increment(key);
            if (!result.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var nextResult = await node.GetCount(key);
            if (!nextResult.IsSuccess || nextResult.Value != valueResult.Value + 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
# 快照克隆对象
从上面的示例中可以看到，实现的 API 逻辑都没有处理线程安全问题，因为服务端采用的线程调度策略可以认为是在**单线程循环执行 API**，所以**不需要考虑线程安全问题**。  
持久化 API 的请求数据的持久化操作是另外一个单线程循环，所以持久化操作基本不会影响 API 执行的吞吐性能，它们之间被设计为流水线关系。对于每一个 API 请求而言，它的持久化与执行逻辑是有严格的先后顺序的，所以也不需要考虑线程安全问题。  
为了减少持久化重建操作对 API 吞吐性能的影响，持久化重建操作也可以认为是一个新的单线程循环操作，整个过程除了获取快照数据集合的方法 [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Snapshot/ISnapshot.cs).GetSnapshotResult 的调用占用了 API 的执行线程，其它操作都是**与 API 并行**执行的。  
而快照数据的持久化需要对快照数据对象进行序列化操作，如果**快照数据对象的成员数据**在序列化操作之前**被并行的 API 逻辑修改**了，就会造成快照对象持久化的时候产生的序列化数据是 API 逻辑修改后的成员数据，结果就是**持久化写入了错误的成员数据**，数据库服务重启以后会读取到错误的快照数据导致产生错误的内存数据。  
所以为了保证快照的持久化数据的正确性，获取快照数据集合的方法原则上要求返回的是**完全克隆（深拷贝）的数据对象**，这样执行 API 的逻辑修改对象成员的操作就不会造成快照持久化数据的变化，快照持久化才能写入正确的序列化数据。  
但是**完全克隆操作的消耗可能比序列化操作还多**，不仅要复制成员数据，还要创建新的对象，这种操作对于数据量较大的节点而言，在触发获取快照数据集合操作的时候会**长时间占用 API 的执行线程**，会对数据库的**吞吐性能与稳定性**造成严重影响。所以从综合性能的角度考虑，我们应该尽可能的**避免完全克隆操作**。  
在内置的通用数据结构节点的实现中，只有位图在获取快照数据的时候使用 System.Buffer.BlockCopy 复制了整个 byte[] 数组数据做到了完全克隆操作，其它数据结构返回的都是原始对象的数组，因为这些对象在服务端并不存在修改成员的操作，所以不会影响快照序列化数据的正确性。  
通过分析我们可以得到一个结论，只要不存在**某个对象的成员**在持久化 API 的逻辑中，**既存在取值操作又存在赋值操作**，那么就算持久化写入了错误的快照数据，在所有持久化数据顺序执行完毕之后，内存数据的**最终状态都会是正确的**，这些场景都是不需要考虑完全克隆操作的。  
由于常规的通用数据结构基本都是**以整体对象的方式操作快照数据对象**，不存在快照数据对象的某个成员被修改的逻辑，所以创建通用的数据结构一般都不需要考虑完全克隆操作。  
  
允许开发者根据实际业务需求自定义节点是 AutoCSer 内存数据库的重点核心功能，这种需求场景中的快照数据对象的成员取值与赋值操作几乎是**不可避免**的随处可见。  
为了在自定义需求场景中避免获取快照数据的方法中产生完全克隆操作，AutoCSer 内置提供了**快照克隆对象**类型 [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.SnapshotCloneObject<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Snapshot/SnapshotCloneObject.cs) 以支持快照数据对象**在持久化 API 中手动触发克隆操作**。  
快照克隆对象只要在获取快照数据之后，到完成持久化的序列化操作之前没有被持久化 API 访问，那么就不需要完全克隆操作。该对象在持久化操作中，快照数据的序列化操作的时候会进行 lock(this) 同步操作，开发者需要在对该对象的成员进行取值与赋值操作之前手动执行 CheckSnapshotValue 方法来触发自定义克隆操作。  
如果开发者担心持久化 API 某处逻辑中忘记手动执行 CheckSnapshotValue 方法导致持久化的序列化数据错误，AutoCSer 内置提供了封装类型 [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CheckSnapshotCloneObject<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Snapshot/CheckSnapshotCloneObject.cs) 默认每次获取数据对象的操作都会触发 CheckSnapshotValue 方法的执行。
## 1. 定义快照克隆对象
还是以泛型字典计数器功能举例，先[定义支持快照克隆的计数对象](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/DictionarySnapshotCloneCounterNode/SnapshotCloneCounter.cs)。
``` csharp
    /// <summary>
    /// 引用类型计数器对象（支持快照数据对象在持久化 API 中手动触发克隆操作的快照数据）
    /// </summary>
    /// <typeparam name="T">关键字类型</typeparam>
    [AutoCSer.BinarySerialize(IsReferenceMember = false)]
    public sealed class SnapshotCloneCounter<T> : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.SnapshotCloneObject<SnapshotCloneCounter<T>>
    {
        /// <summary>
        /// 无参构造，用于反射生成对象
        /// </summary>
        private SnapshotCloneCounter() { }
        /// <summary>
        /// 引用类型计数器对象
        /// </summary>
        /// <param name="key">keyword</param>
        public SnapshotCloneCounter(T key)
        {
            Key = key;
            Count = 1;
        }
        /// <summary>
        /// Keyword
        /// </summary>
        [AllowNull]
        public T Key { get; private set; }
        /// <summary>
        /// 当前计数
        /// </summary>
        public long Count { get; private set; }
        /// <summary>
        /// 计数 +1
        /// </summary>
        public void Increment()
        {
            //该操作同时存在取值与赋值操作，相当于 Count = Count + 1;
            ++Count;
        }
    }
```
## 2. 定义节点 API 接口
和泛型数据结构节点 API 接口的定义差不多，区别是[加载快照数据方法的参数类型是快照克隆对象类型](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/DictionarySnapshotCloneCounterNode/IDictionarySnapshotCloneCounterNode.cs)。
``` csharp
    /// <summary>
    /// 支持快照克隆的字典计数器节点接口示例
    /// </summary>
    /// <typeparam name="T">关键字类型</typeparam>
    [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode]
    public partial interface IDictionarySnapshotCloneCounterNode<T> where T : IEquatable<T>
    {
        /// <summary>
        /// 加载快照数据（从快照数据恢复内存数据）
        /// </summary>
        /// <param name="value">data</param>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethod(IsClientCall = false, SnapshotMethodSort = 1)]
        void SnapshotSet(SnapshotCloneCounter<T> value);
        /// <summary>
        /// 计数 +1
        /// </summary>
        /// <param name="key">计数关键字</param>
        /// <returns>key 为 null 则返回 false</returns>
        bool Increment(T key);
        /// <summary>
        /// 获取当前计数
        /// </summary>
        /// <param name="key">计数关键字</param>
        /// <returns>key 为 null 则返回 -1</returns>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethod(IsPersistence = false)]
        long GetCount(T key);
        /// <summary>
        /// 删除计数
        /// </summary>
        /// <param name="key">计数关键字</param>
        /// <returns>返回 false 表示关键字不存在</returns>
        bool Remove(T key);
    }
```
## 3. 实现节点 API 功能
[节点实例](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/DictionarySnapshotCloneCounterNode/DictionarySnapshotCloneCounterNode.cs)需要实现节点接口功能，注意字典的数据类型使用了**快照克隆对象的封装**：
``` csharp
    /// <summary>
    /// 支持快照克隆的字典计数器节点示例
    /// </summary>
    /// <typeparam name="T">关键字类型</typeparam>
    public sealed class DictionarySnapshotCloneCounterNode<T> : IDictionarySnapshotCloneCounterNode<T>
        where T : IEquatable<T>
    {
        /// <summary>
        /// 字典计数器
        /// </summary>
        private Dictionary<T, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CheckSnapshotCloneObject<SnapshotCloneCounter<T>>> counts;
        /// <summary>
        /// 支持快照克隆的字典计数器节点示例
        /// </summary>
        /// <param name="capacity">容器初始化大小</param>
        internal DictionarySnapshotCloneCounterNode(int capacity)
        {
            counts = DictionaryCreator<T>.Create<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CheckSnapshotCloneObject<SnapshotCloneCounter<T>>>(capacity);
        }
        /// <summary>
        /// 加载快照数据（从快照数据恢复内存数据）
        /// </summary>
        /// <param name="value">data</param>
        public void SnapshotSet(SnapshotCloneCounter<T> value)
        {
            counts.Add(value.Key, value);
        }
        /// <summary>
        /// 计数 +1
        /// </summary>
        /// <param name="key">计数关键字</param>
        /// <returns>key 为 null 则返回 false</returns>
        public bool Increment(T key)
        {
            if (key != null)
            {
                if (counts.TryGetValue(key, out AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CheckSnapshotCloneObject<SnapshotCloneCounter<T>> count)) count.GetNotNull().Increment();
                else counts.Add(key, new SnapshotCloneCounter<T>(key));
                return true;
            }
            return false;
        }
        /// <summary>
        /// 获取当前计数
        /// </summary>
        /// <param name="key">计数关键字</param>
        /// <returns>key 为 null 则返回 -1</returns>
        public long GetCount(T key)
        {
            if (key != null) return counts.TryGetValue(key, out AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CheckSnapshotCloneObject<SnapshotCloneCounter<T>> count) ? count.NoCheckNotNull().Count : 0;
            return -1;
        }
        /// <summary>
        /// 删除计数
        /// </summary>
        /// <param name="key">计数关键字</param>
        /// <returns>返回 false 表示关键字不存在</returns>
        public bool Remove(T key)
        {
            return key != null && counts.Remove(key);
        }
    }
```
## 4. 实现快照接口
[节点实例](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/DictionarySnapshotCloneCounterNode/DictionarySnapshotCloneCounterNode.cs)需要实现快照接口功能：
``` csharp
    /// <summary>
    /// 支持快照克隆的字典计数器节点示例
    /// </summary>
    /// <typeparam name="T">关键字类型</typeparam>
    public sealed class DictionarySnapshotCloneCounterNode<T> : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<SnapshotCloneCounter<T>>
        where T : IEquatable<T>
    {
        /// <summary>
        /// 获取快照数据集合容器大小，用于预申请快照数据容器
        /// </summary>
        /// <param name="customObject">自定义对象，用于预生成辅助数据</param>
        /// <returns>快照数据集合容器大小</returns>
        int AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<SnapshotCloneCounter<T>>.GetSnapshotCapacity(ref object customObject)
        {
            return counts.Count;
        }
        /// <summary>
        /// 获取快照数据集合，如果数据对象可能被修改则应该返回克隆数据对象防止建立快照期间数据被修改
        /// </summary>
        /// <param name="snapshotArray">预申请的快照数据容器</param>
        /// <param name="customObject">自定义对象，用于预生成辅助数据</param>
        /// <returns>快照数据</returns>
        AutoCSer.CommandService.StreamPersistenceMemoryDatabase.SnapshotResult<SnapshotCloneCounter<T>> AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<SnapshotCloneCounter<T>>.GetSnapshotResult(SnapshotCloneCounter<T>[] snapshotArray, object customObject)
        {
            return SnapshotCloneCounter<T>.GetSnapshotResult(snapshotArray, counts.Values);
        }
        /// <summary>
        /// 持久化之前重组快照数据
        /// </summary>
        /// <param name="array">预申请的快照数据容器</param>
        /// <param name="newArray">超出预申请范围的快照数据集合</param>
        void AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<SnapshotCloneCounter<T>>.SetSnapshotResult(ref LeftArray<SnapshotCloneCounter<T>> array, ref LeftArray<SnapshotCloneCounter<T>> newArray) { }
    }
```
## 5. 创建节点实例
和创建泛型数据结构节点实例一样，[示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/CustomServiceNode.cs)如下：
``` csharp
    /// <summary>
    /// 自定义基础服务节点接口
    /// </summary>
    [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode]
    public partial interface ICustomServiceNode : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IServiceNode
    {
        /// <summary>
        /// 创建支持快照克隆的字典计数器节点 IDictionarySnapshotCloneCounterNode{T}
        /// </summary>
        /// <param name="index">节点索引信息</param>
        /// <param name="key">节点全局关键字</param>
        /// <param name="nodeInfo">服务端节点信息</param>
        /// <param name="keyType">关键字类型</param>
        /// <param name="capacity">容器初始化大小</param>
        /// <returns>节点标识，已经存在节点则直接返回</returns>
        AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex CreateDictionarySnapshotCloneCounterNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int capacity);
    }
    
    /// <summary>
    /// 自定义基础服务节点，用于添加自定义节点创建 API 方法
    /// </summary>
    public sealed class CustomServiceNode : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServiceNode, ICustomServiceNode
    {
        /// <summary>
        /// 创建支持快照克隆的字典计数器节点 IDictionarySnapshotCloneCounterNode{T}
        /// </summary>
        /// <param name="index">节点索引信息</param>
        /// <param name="key">节点全局关键字</param>
        /// <param name="nodeInfo">服务端节点信息</param>
        /// <param name="keyType">关键字类型</param>
        /// <param name="capacity">容器初始化大小</param>
        /// <returns>节点标识，已经存在节点则直接返回</returns>
        public AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex CreateDictionarySnapshotCloneCounterNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int capacity)
        {
            var type = default(Type);
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum state = getEquatableType(ref keyType, ref type);
            if (state == AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum.Success)
            {
                MethodInfo method = typeof(CustomServiceNode).GetMethod(nameof(createDictionarySnapshotCloneCounterNode), BindingFlags.Instance | BindingFlags.NonPublic).notNull();
                return (AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex)method.MakeGenericMethod(type.notNull()).Invoke(this, new object[] { index, key, nodeInfo, capacity }).notNull();
            }
            return new AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex(state);
        }
        /// <summary>
        /// 创建支持快照克隆的字典计数器节点 IDictionarySnapshotCloneCounterNode{T}
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="index">节点索引信息</param>
        /// <param name="key">节点全局关键字</param>
        /// <param name="nodeInfo">服务端节点信息</param>
        /// <param name="capacity">容器初始化大小</param>
        /// <returns>节点标识，已经存在节点则直接返回</returns>
        private AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex createDictionarySnapshotCloneCounterNode<T>(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, int capacity)
            where T : IEquatable<T>
        {
            return CreateSnapshotNode<IDictionarySnapshotCloneCounterNode<T>>(index, key, nodeInfo, () => new DictionarySnapshotCloneCounterNode<T>(capacity));
        }
    }
```
## 6. 静态代码生成
具体配置方法参考[静态代码生成](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/05.CodeGenerator.md)，生成的 {$(ProjectName)}.AutoCSer.cs 文件中包含用于路由的 API 方法编号与客户端接口代码。
## 7. 创建客户端节点
和创建泛型数据结构可客户端节点一样，[示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/Client/DictionarySnapshotCloneCounterNode.cs)如下：
``` csharp
    /// <summary>
    /// 支持快照克隆的字典计数器节点客户端示例
    /// </summary>
    internal static class DictionarySnapshotCloneCounterNode
    {
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<IDictionarySnapshotCloneCounterNodeClientNode<int>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateNode<IDictionarySnapshotCloneCounterNodeClientNode<int>>(nameof(DictionarySnapshotCloneCounterNode), (index, key, nodeInfo) => client.ClientNode.CreateDictionarySnapshotCloneCounterNode(index, key, nodeInfo, typeof(int), 0)));
        /// <summary>
        /// 支持快照克隆的字典计数器节点客户端示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            IDictionarySnapshotCloneCounterNodeClientNode<int> node = nodeResult.Value.notNull();

            //测试用户ID 为 1 的计数器
            int key = 1;
            var valueResult = await node.GetCount(key);
            if (!valueResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var result = await node.Increment(key);
            if (!result.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var nextResult = await node.GetCount(key);
            if (!nextResult.IsSuccess || nextResult.Value != valueResult.Value + 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
# 多快照节点
多快照节点就是现实了多种快照数据类型的快照功能的节点，同一个节点中**不允许存在重复的快照数据类型**，由 API 方法配置的 SnapshotMethodSort 决定持久化操作的顺序。  
比如为了**避免产生分布式事务问题**，可能会把应用的所有数据放到同一个自定义节点中处理，这个节点就相当于传统应用的一个数据库，一个数据库通常都会有多个数据表格，那么就可能产生多个快照集合的持久化需求。  
比如一个游戏局内服务节点可能包含用户、怪物、物品等多种存在持久化需求的数据集合。当然你可能会有疑问，都支持面向对象编程了为什么不直接持久化一个包含所有业务对象的根对象？  
是的，对于较小的数据你确实可以把某个业务数据的根对象当作快照对象处理，但是这种做法几乎**无法避免完全克隆操作**，而且由于 AutoCSer 的序列化是纯内存操作，也就会造成相关输出数据缓冲区需要**占用大量内存资源**。  
下面举个简单的[多快照节点](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/BeforePersistenceNode/BeforePersistenceNode.cs)的例子：
``` csharp
    /// <summary>
    /// 持久化前置检查节点接口示例
    /// </summary>
    [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode]
    public partial interface IBeforePersistenceNode
    {
        /// <summary>
        /// 加载快照数据（从快照数据恢复内存数据）
        /// </summary>
        /// <param name="value">data</param>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethod(IsClientCall = false, SnapshotMethodSort = 1)]
        void SnapshotSetEntity(IdentityEntity value);
        /// <summary>
        /// 加载快照数据（从快照数据恢复内存数据）
        /// </summary>
        /// <param name="identity">当前分配 ID</param>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethod(IsClientCall = false, SnapshotMethodSort = 2)]
        void SnapshotSetIdentity(long identity);
    }

    /// <summary>
    /// 持久化前置检查节点示例
    /// </summary>
    public sealed class BeforePersistenceNode : IBeforePersistenceNode
        , AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<IdentityEntity>
        , AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IEnumerableSnapshot<long>
    {
        #region A snapshot of the data collection with identity
        /// <summary>
        /// 获取快照数据集合容器大小，用于预申请快照数据容器
        /// </summary>
        /// <param name="customObject">自定义对象，用于预生成辅助数据</param>
        /// <returns>快照数据集合容器大小</returns>
        int AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<IdentityEntity>.GetSnapshotCapacity(ref object customObject)
        {
            return entities.Count;
        }
        /// <summary>
        /// 获取快照数据集合，如果数据对象可能被修改则应该返回克隆数据对象防止建立快照期间数据被修改
        /// </summary>
        /// <param name="snapshotArray">预申请的快照数据容器</param>
        /// <param name="customObject">自定义对象，用于预生成辅助数据</param>
        /// <returns>快照数据</returns>
        AutoCSer.CommandService.StreamPersistenceMemoryDatabase.SnapshotResult<IdentityEntity> AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<IdentityEntity>.GetSnapshotResult(IdentityEntity[] snapshotArray, object customObject)
        {
            return IdentityEntity.GetSnapshotResult(snapshotArray, entities.Values);
        }
        /// <summary>
        /// 持久化之前重组快照数据
        /// </summary>
        /// <param name="array">预申请的快照数据容器</param>
        /// <param name="newArray">超出预申请范围的快照数据集合</param>
        void AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<IdentityEntity>.SetSnapshotResult(ref LeftArray<IdentityEntity> array, ref LeftArray<IdentityEntity> newArray) { }
        /// <summary>
        /// 加载快照数据（从快照数据恢复内存数据）
        /// </summary>
        /// <param name="value">data</param>
        public void SnapshotSetEntity(IdentityEntity value)
        {
            entities.Add(value.Identity, value);
        }
        #endregion
        #region A snapshot of the currently assigned identity
        /// <summary>
        /// 单值快照
        /// </summary>
        AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshotEnumerable<long> AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IEnumerableSnapshot<long>.SnapshotEnumerable { get { return new AutoCSer.CommandService.StreamPersistenceMemoryDatabase.SnapshotGetValue<long>(getCurrentIdentity); } }
        /// <summary>
        /// 获取当前分配 ID
        /// </summary>
        /// <returns></returns>
        private long getCurrentIdentity()
        {
            return currentIdentity;
        }
        /// <summary>
        /// 加载快照数据（从快照数据恢复内存数据）
        /// </summary>
        /// <param name="identity">当前分配 ID</param>
        public void SnapshotSetIdentity(long identity)
        {
            currentIdentity = identity;
        }
        #endregion
    }
```
# 持久化预操作
在 AutoCSer [内存数据库简介](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/06.MemoryDatabase/06.MemoryDatabase.md)中介绍**可扩展支持面向对象编程**时，重点提到了持久化 API 的逻辑需要具有**确定性**，**可重放执行的 API 逻辑**是数据库数据正确性的基础条件。  
这也就要求持久化 API 中**不允许产生具有随机性的持久化业务数据**，所有持久化的业务数据都必须是上下文唯一确定的。比如 DateTime.Now、Random.Next()、Guid.NewGuid() 等等这些具有随机性的数据都不允许在持久化 API 中赋值给持久化业务数据对象，因为这样会造成数据库重启重放执行持久化 API 恢复内存数据的时候**产生和历史不一致的业务数据**。  
我们创建一个新的持久化业务数据对象的时候，经常会存在某些成员值需要一个非确定的初始化值需求，而这些初始化值的生成可能依赖于服务端的某个内存数据的状态，**在客户端调用逻辑中可能没有简单的处理方法**，所以需要使用服务端逻辑来生成这些业务数据。  
针对这种需求场景 AutoCSer 提供了持久化 API 的预操作机制，允许给持久化 API 方法**绑定添加一个预操作方法**，这个预操作方法在执行 API 的线程中被调用完毕以后，才会触发原 API 的持久化操作，所以在该方法中**对引用类型参数对象的成员进行修改**，其操作结果会被当成持久化 API 的请求数据处理。  
但是持久化预操作**并不能解决所有**非确定值的持久化业务数据需求，存在复杂的非确定值需求的场景，可能就不适合使用 AutoCSer 内存数据库来处理了。  
持久化预操作还可以用于判断调用参数的合法性以避免非法请求参数产生持久化操作（当然参数的合法性检查应该在客户端调用逻辑中处理），也可以用于提前生成持久化 API 需要的数据对象以避免持久化 API 在 new 操作时产生内存不足异常等问题。  
  
持久化预操作方法必须与对应的持久化 API 方法在定义上保持一致，包括参数顺序、参数类型、参数名称等，虽然方法名称与返回值类型是不同的，但是也必须满足匹配规则。  
持久化预操作方法的方法名称必须是对应的持久化 API 方法的方法名称增加 **BeforePersistence 后缀**，返回值类型的定义分两种情况：  
当持久化 API 方法的返回值类型为 void 时，预操作方法的返回值必须为 bool 类型，返回 true 表示需要继续正常执行持久化 API 方法，**返回 false 则表示取消该 API 的持久化操作与执行操作并直接返回 Success 调用状态**，所以只有在正常执行持久化 API 逻辑也**不会修改内存数据状态**的场景中才允许返回 false。  
当持久化 API 方法存在返回值类型 T 时，预操作方法的返回值必须为 [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/ValueResult.cs) 类型，返回 default 或者 IsValue 为 false 时表示需要继续正常执行持久化 API 方法，**返回 IsValue 为 true 则表示取消该 API 的持久化操作与执行操作并直接将 Value 值返回给客户端**，所以只有在正常执行持久化 API 逻辑也会**返回同样的 Value 值并且不会修改内存数据状态**的场景中才允许返回 IsValue 为 true。  
下面举个简单的[持久化预操作的例子](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/BeforePersistenceNode/BeforePersistenceNode.cs)：
``` csharp
        /// <summary>
        /// 添加一个新数据（持久化操作之前检查输入参数）
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<long> AppendEntityBeforePersistence(IdentityEntity value)
        {
            if (value != null)
            {
                //清理客户端传参
                value.Identity = 0;
                //返回默认值则继续执行 AppendEntity 方法
                return default(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<long>);
            }
            //返回非默认值则直接返回，不再执行 AppendEntity 方法，也不会持久化该请求数据
            return 0;
        }
        /// <summary>
        /// 添加一个新数据
        /// </summary>
        /// <param name="value"></param>
        /// <returns>新数据 ID，失败返回 0</returns>
        public long AppendEntity(IdentityEntity value)
        {
            if (value.Identity == 0) value.Identity = ++currentIdentity;
            entities.Add(value.Identity, value);
            return value.Identity;
        }
```
# 初始化加载数据
由于 AutoCSer 内存数据库的持久化 API 是需要支持重放执行的，所以在实际业务需求场景中，开发者可能需要在某些特殊的持久化 API 中区分当前逻辑是由数据库冷启动的历史数据产生的，还是由客户端发起的新请求产生的。  
因为大多数实际业务需求**并非仅仅只是修改持久化业务数据的内存数据状态**，还可能需要触发一些事件操作（比如发送邮件通知），如果当前逻辑是由**历史持久化数据**产生的，就**不应该重复执行这些事件操作**（当然如果事件逻辑本身具有幂等性那可能就只是浪费一些计算资源了）。  
在简单的逻辑需求场景中，让[节点实例类型](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/LoadPersistenceNode/LoadPersistenceNode.cs)派生自类型 [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ContextNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Server/ContextNode.cs) 可以在节点初始化过程中**绑定当前数据库服务的上下文**，通过该上下文可以判断当前执行逻辑是否由客户端发起的新请求产生。
``` csharp
    /// <summary>
    /// 初始化加载持久化数据 API 示例节点
    /// </summary>
    public sealed class LoadPersistenceNode : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ContextNode<ILoadPersistenceNode>, ILoadPersistenceNode
    {
        /// <summary>
        /// 计数 +1
        /// </summary>
        public void Increment()
        {
            ++count;
            //IsLoaded 为 true 表示当前执行逻辑由客户端发起的新请求产生，否则表示当前执行逻辑由数据库冷启动的历史数据产生
            if (base.StreamPersistenceMemoryDatabaseService.IsLoaded) ;
        }
    }
```
但是在复杂逻辑需求场景中，这种判断操作容易产生更复杂的逻辑调用链的**耦合与混乱**，而且开发者很容易在某个逻辑调用点**忘记调用该判断逻辑**，导致产生一些多余甚至错误的操作逻辑。  
针对这种场景需求，AutoCSer 支持将这种 API 分裂成两个**需求明确的独立 API 逻辑**分支，系统根据当前状态自动选择执行不同的 API 逻辑，对于客户端发起的新请求则执行完整的原始 API 逻辑，对于数据库冷启动的历史数据则执行一个仅修改持久化业务数据的 API 逻辑。  
[初始化加载持久化数据的方法](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/LoadPersistenceNode/LoadPersistenceNode.cs)必须与对应的持久化 API 方法在定义上保持一致，包括参数顺序、参数类型、参数名称、返回值类型等，而方法名称则必须是由对应持久化 API 方法的方法名称增加 **LoadPersistence 后缀**。
``` csharp
    /// <summary>
    /// 初始化加载持久化数据 API 示例节点
    /// </summary>
    public sealed class LoadPersistenceNode : ILoadPersistenceNode
    {
        /// <summary>
        /// 计数 +1（初始化加载持久化数据）
        /// </summary>
        public void IncrementLoadPersistence()
        {
            ++count;
            //output false
            Console.WriteLine($"IsLoaded {base.StreamPersistenceMemoryDatabaseService.IsLoaded} in {nameof(IncrementLoadPersistence)}");
        }
        /// <summary>
        /// 计数 +1
        /// </summary>
        public void Increment()
        {
            ++count;
            //output true
            Console.WriteLine($"IsLoaded {base.StreamPersistenceMemoryDatabaseService.IsLoaded} in {nameof(Increment)}");
        }
    }
```
# JSON 混杂二进制序列化
AutoCSer 内存数据库的持久化操作与 RPC 一样都**默认采用二进制序列化**，而二进制序列化要求**数据定义稳定不变**，否则会造成持久化数据**反序列化失败**，导致内存数据状态**无法正常恢复**，内存数据库也就**无法正常重启**。  
由于大多数业务数据类型的成员定义都是不稳定的，所以这些业务数据类型应该[显式配置为 JSON 混杂二进制序列化](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/BeforePersistenceNode/IdentityEntity.cs)。不过这种序列化模式由于需要写入并解析成员名称，所以会大幅降低数据序列化效率，而且会大幅增加持久化文件大小。  
数据的序列化配置也是**不允许更改**的，更改序列化配置同样会造成反序列化失败的问题，所以业务数据的序列化配置**必须在设计阶段就权衡确定**。如果后期存在定义修改需求，正确的做法应该重新定义独立的业务数据类型与增加新的 API 来处理问题。
``` csharp
    /// <summary>
    /// 带有 ID 的测试数据
    /// </summary>
    [AutoCSer.BinarySerialize(IsJsonMix = true)]
    public sealed class IdentityEntity
```
# 性能测试
从 .NET Redis 客户端与 AutoCSer 内存数据库的并发吞吐测试结果来看，对于同样的需求在高并发场景下，AutoCSer 内存数据库的测试吞吐性能整体上限**超过 StackExchange.Redis + Garnet 数倍**，越是轻量级 API 的测试，两者的并发吞吐性能差距越大。  
采用 Garnet 替代 Redis 服务端，是因为大量测试结果表明 **Garnet 的吞吐性能是 Redis 的两倍以上**。而 **StackExchange.Redis 是各种 .NET 客户端中测试结果最好的**，它与其它客户端的吞吐性能差距达到一个数量级。  
[.NET Redis 测试项目](https://github.com/AutoCSer/AutoCSer2/tree/main/TestCase/ThirdParty/RedisPerformance)  
[AutoCSer 内存数据库测试服务端项目](https://github.com/AutoCSer/AutoCSer2/tree/main/TestCase/StreamPersistenceMemoryDatabase/Performance)  
[AutoCSer 内存数据库测试客户端项目](https://github.com/AutoCSer/AutoCSer2/tree/main/TestCase/StreamPersistenceMemoryDatabase/PerformanceClient)  
AutoCSer 内存数据库除了支持自定义节点与存在并发吞吐性能优势，还支持**可靠持久化**与[本地嵌入模式](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/09.MemoryDatabaseLocalService/09.MemoryDatabaseLocalService.md)都是重要特性，另外 AutoCSer RPC 的全双工应答机制相对于 Redis 的应答模式能**更好的适应高延时的网络环境**，提供**更稳定的实战性能**优势。  
当然，实现高性能的自定义节点**对开发者能力是存在一些要求**的，如果你对**数据结构与算法**复杂度的知识有一定了解，那么就可以通过 AutoCSer 内存数据库轻松打造在 .NET 环境中碾压 Garnet / Redis 的 API。
# [本地嵌入模式](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/09.MemoryDatabaseLocalService/09.MemoryDatabaseLocalService.md)