# In-memory database - Custom nodes
AutoCSer in-memory database is scalable and **supports object-oriented programming**, allowing developers to implement any data structure and API business logic using C# code in the form of **custom nodes** based on actual business needs. It can **meet complex business requirements** and significantly **improve the development and maintenance efficiency of the data access layer**.
# Implement a simple counter
## 1. Define the node API interface
The [node interface definition](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/CounterNode/ICounterNode.cs) needs to use the **public partial** modifier and add the [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Server/ServerNodeAttribute.cs) configuration because the [static code generation](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/05.CodeGenerator.Eng.md) function of AutoCSer needs to be used to generate the API method number and the **client interface** code. Of course, you can also write the relevant code by hand without using the static code generation function, but this approach is prone to errors.  
The node API methods are configured using [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethodAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Server/ServerMethodAttribute.cs), and **duplicate API method names are not allowed**. Generic methods are not supported.  
The default configuration of IsPersistence for the node API is true, indicating that API calls require persistent operations (all apis that modify persistent data should use the default configuration). If it is confirmed that the API only reads data without causing business changes to the in-memory data state, IsPersistence should be set to false to avoid unnecessary data persistence operations.  
Setting SnapshotMethodSort to a non-0 value indicates a **method for loading snapshot data**. The return type of this method must be void, and the unique parameter type must be consistent with the **generic type of the snapshot interface**. Usually, IsClientCall = false should also be set simultaneously to prohibit client requests for access.
``` csharp
    /// <summary>
    /// Counter node interface example
    /// </summary>
    [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode]
    public partial interface ICounterNode
    {
        /// <summary>
        /// Load snapshot data (recover memory data from snapshot data)
        /// </summary>
        /// <param name="value">data</param>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethod(IsClientCall = false, SnapshotMethodSort = 1)]
        void SnapshotSet(long value);
        /// <summary>
        /// Count +1
        /// </summary>
        void Increment();
        /// <summary>
        /// Get the current count
        /// </summary>
        /// <returns>Current count</returns>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethod(IsPersistence = false)]
        long GetCount();
    }
```
## 2. Implement the counter function
The [node instance](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/CounterNode/CounterNode.cs) needs to implement the node interface function:
``` csharp
    /// <summary>
    /// Counter node example
    /// </summary>
    public sealed class CounterNode : ICounterNode
    {
        /// <summary>
        /// Current count
        /// </summary>
        private long count;
        /// <summary>
        /// Load snapshot data (recover memory data from snapshot data)
        /// </summary>
        /// <param name="value">data</param>
        public void SnapshotSet(long value)
        {
            count = value;
        }
        /// <summary>
        /// Count +1
        /// </summary>
        public void Increment()
        {
            ++count;
        }
        /// <summary>
        /// Get the current count
        /// </summary>
        /// <returns>Current count</returns>
        public long GetCount()
        {
            return count;
        }
    }
```
## 3. Implement the snapshot interface
The snapshot function consists of two parts. Besides the method of loading snapshot data to **restore in-memory data**, it is also necessary to implement interfaces [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Snapshot/ISnapshot.cs) or [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IEnumerableSnapshot<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Snapshot/IEnumerableSnapshot.cs) to **convert in-memory data into a collection of serializable data** during persistence operations.  
For nodes that have not implemented the snapshot function, historical data will be lost after database persistence reconstruction. That is to say, **nodes that want to establish reliable persistence must implement the snapshot function**; otherwise, they can only be used as in-memory cache data.  
The **null value is not allowed** in the snapshot data object collection; otherwise, it will cause the database persistence reconstruction to fail. The [current example](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/CounterNode/CounterNode.cs) uses an instance of a single-value snapshot [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.SnapshotGetValue<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Snapshot/SnapshotGetValue.cs).
``` csharp
    /// <summary>
    /// Counter node example
    /// </summary>
    public sealed class CounterNode : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IEnumerableSnapshot<long>
    {
        /// <summary>
        /// Single-valued snapshot
        /// </summary>
        AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshotEnumerable<long> AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IEnumerableSnapshot<long>.SnapshotEnumerable { get { return new AutoCSer.CommandService.StreamPersistenceMemoryDatabase.SnapshotGetValue<long>(GetCount); } }
    }
```
## 4. Customize the basic service node
For in-memory database services with custom nodes, a derived class implementation of the built-in base service node type [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServiceNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ServiceNode.cs) **must be provided**, and interface [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IServiceNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IServiceNode.cs) [must be explicitly inherited](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/ICustomServiceNode.cs) directly. This node is mainly used to define the API methods for [creating nodes](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/CustomServiceNode.cs).
``` csharp
    /// <summary>
    /// Customize the basic service node interface
    /// </summary>
    [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode]
    public partial interface ICustomServiceNode : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IServiceNode
    {
        /// <summary>
        /// Create a counter node ICounterNode
        /// </summary>
        /// <param name="index">Node index information</param>
        /// <param name="key">Node global keyword</param>
        /// <param name="nodeInfo">Server-side node information</param>
        /// <returns>Node identifier, there have been a node is returned directly</returns>
        AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex CreateCounterNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo);
    }
    
    /// <summary>
    /// Customize the basic service node for adding custom nodes to create API methods
    /// </summary>
    public sealed class CustomServiceNode : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServiceNode, ICustomServiceNode
    {
        /// <summary>
        /// Customize the basic service node
        /// </summary>
        /// <param name="service">Log stream persistence memory database service</param>
        public CustomServiceNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabaseService service) : base(service) { }
        /// <summary>
        /// Create a counter node ICounterNode
        /// </summary>
        /// <param name="index">Node index information</param>
        /// <param name="key">Node global keyword</param>
        /// <param name="nodeInfo">Server-side node information</param>
        /// <returns>Node identifier, there have been a node is returned directly</returns>
        public AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex CreateCounterNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo)
        {
            return CreateSnapshotNode<ICounterNode>(index, key, nodeInfo, () => new CounterNode());
        }
    }
```
## 5. Static code generation
For specific configuration methods, refer to the [static code generation](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/05.CodeGenerator.Eng.md). The generated {$(ProjectName)}.AutoCSer.cs file contains the API method number for routing and the [client interface code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/%7BAutoCSer.Document.MemoryDatabaseCustomNode%7D.AutoCSer.cs), for example:
``` csharp
        /// <summary>
        /// Counter node interface example 
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.Document.MemoryDatabaseCustomNode.ICounterNode))]
        public partial interface ICounterNodeClientNode
        {
            /// <summary>
            /// Get the current count 
            /// </summary>
            /// <returns>Current count</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<long> GetCount();
            /// <summary>
            /// Count +1 
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Increment();
        }
        
        /// <summary>
        /// Customize the basic service node interface 
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.Document.MemoryDatabaseCustomNode.ICustomServiceNode))]
        public partial interface ICustomServiceNodeClientNode : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IServiceNodeClientNode
        {
            /// <summary>
            /// Create a counter node ICounterNode 
            /// </summary>
            /// <param name="index">Node index information </param>
            /// <param name="key">Node global keyword</param>
            /// <param name="nodeInfo">Server-side node information</param>
            /// <returns>Node identifier, there have been a node is returned directly</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateCounterNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo);
        }
```
## 6. Create the RPC server listener
To create a server-side listener, you can refer to the built-in data structure node. The difference lies in the method of creating an in-memory database service instance. The following is a comparison of two sets of code. The [built-in node code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Program.cs) is as follows:
``` csharp
            AutoCSer.CommandService.StreamPersistenceMemoryDatabaseService databaseService = databaseServiceConfig.Create();
```
For custom nodes, it is necessary to [create a custom base service node](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/Program.cs). The code is as follows:
``` csharp
            AutoCSer.Document.MemoryDatabaseCustomNode.ServiceConfig databaseServiceConfig = new AutoCSer.Document.MemoryDatabaseCustomNode.ServiceConfig
            {
                PersistencePath = Path.Combine(AutoCSer.TestCase.Common.Config.AutoCSerTemporaryFilePath, nameof(AutoCSer.Document.MemoryDatabaseCustomNode)),
                PersistenceSwitchPath = Path.Combine(AutoCSer.TestCase.Common.Config.AutoCSerTemporaryFilePath, nameof(AutoCSer.Document.MemoryDatabaseCustomNode) + nameof(AutoCSer.Document.MemoryDatabaseCustomNode.ServiceConfig.PersistenceSwitchPath))
            };
            AutoCSer.CommandService.StreamPersistenceMemoryDatabaseService databaseService = databaseServiceConfig.Create<ICustomServiceNode>(p => new CustomServiceNode(p));
```
## 7. Create the RPC client
The difference between creating an RPC client and a built-in node lies in the type of the **client singleton** created. The type of the client singleton created by a built-in node is [AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientCache<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Client/StreamPersistenceMemoryDatabaseClientCache.cs). The [sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/CommandClientSocketEvent.cs) is as follows:
``` csharp
        /// <summary>
        /// Log stream persistence memory database client single example
        /// </summary>
        public static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientCache<CommandClientSocketEvent> StreamPersistenceMemoryDatabaseClientCache = new AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientCache<CommandClientSocketEvent>(new AutoCSer.Net.CommandClientConfig
        {
            Host = new AutoCSer.Net.HostEndPoint((ushort)AutoCSer.TestCase.Common.CommandServerPortEnum.Document),
            GetSocketEventDelegate = (client) => new CommandClientSocketEvent(client)
        });
```
For custom nodes, parameters need to be passed to define the **interface type of the client node generated by the custom basic service node**. The client singleton type created by the custom node is [AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientCache<NT, ET>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Client/StreamPersistenceMemoryDatabaseClientCache.cs). The [sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/Client/CommandClientSocketEvent.cs) is as follows:
``` csharp
        /// <summary>
        /// Log stream persistence in-memory database client singleton
        /// </summary>
        public static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientCache<ICustomServiceNodeClientNode, CommandClientSocketEvent> StreamPersistenceMemoryDatabaseClientCache = new AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientCache<ICustomServiceNodeClientNode, CommandClientSocketEvent>(new AutoCSer.Net.CommandClientConfig
        {
            Host = new AutoCSer.Net.HostEndPoint((ushort)AutoCSer.TestCase.Common.CommandServerPortEnum.Document),
            GetSocketEventDelegate = (client) => new CommandClientSocketEvent(client)
        });
```
## 8. Create the client node
Built-in nodes encapsulate methods in the client [AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClient<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Client/StreamPersistenceMemoryDatabaseClient.cs) that directly return to the client node, while [custom nodes](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/Client/CounterNode.cs) require developers to **call the method for creating the client node based on the actual situation**. For specific usage, you can refer to the encapsulation methods of built-in nodes.
``` csharp
    /// <summary>
    /// Counter node client example
    /// </summary>
    internal static class CounterNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<ICounterNodeClientNode> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateNode<ICounterNodeClientNode>(nameof(CounterNode), client.ClientNode.CreateCounterNode));
        /// <summary>
        /// Counter node client example
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            ICounterNodeClientNode node = nodeResult.Value.notNull();
            var valueResult = await node.GetCount();
            if (!valueResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var result = await node.Increment();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var nextResult = await node.GetCount();
            if (!nextResult.IsSuccess || nextResult.Value != valueResult.Value + 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
# Generic data structure node
An instance of the counter node mentioned above can only record one quantity value. If a counting function needs to be added to a large number of users, a large number of node instances need to be created to meet the demand. In such a demand scenario, we should create a [node with a collection nature](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/DictionaryCounterNode/IDictionaryCounterNode.cs).
## 1. Define the generic node API interface
``` csharp
    /// <summary>
    /// Dictionary counter node interface example
    /// </summary>
    /// <typeparam name="T">Keyword type</typeparam>
    [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode]
    public partial interface IDictionaryCounterNode<T> where T : IEquatable<T>
    {
        /// <summary>
        /// Load snapshot data (recover memory data from snapshot data)
        /// </summary>
        /// <param name="value">data</param>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethod(IsClientCall = false, SnapshotMethodSort = 1)]
        void SnapshotSet(BinarySerializeKeyValue<T, long> value);
        /// <summary>
        /// Count +1
        /// </summary>
        /// <param name="key">The keyword for counting</param>
        /// <returns>If the key is null, it returns false</returns>
        bool Increment(T key);
        /// <summary>
        /// Get the current count
        /// </summary>
        /// <param name="key">The keyword for counting</param>
        /// <returns>If the key is null, -1 will be returned</returns>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethod(IsPersistence = false)]
        long GetCount(T key);
        /// <summary>
        /// Delete the count
        /// </summary>
        /// <param name="key">The keyword for counting</param>
        /// <returns>Returning false indicates that the keyword does not exist</returns>
        bool Remove(T key);
    }
```
## 2. Implement the generic dictionary counter function
The [node instance](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/DictionaryCounterNode/DictionaryCounterNode.cs) needs to implement the node interface function:
``` csharp
    /// <summary>
    /// Dictionary counter node example
    /// </summary>
    /// <typeparam name="T">Keyword type</typeparam>
    public sealed class DictionaryCounterNode<T> : IDictionaryCounterNode<T>
        where T : IEquatable<T>
    {
        /// <summary>
        /// Dictionary counter
        /// </summary>
        private Dictionary<T, long> counts;
        /// <summary>
        /// Dictionary counter node example
        /// </summary>
        /// <param name="capacity">Container initialization size</param>
        internal DictionaryCounterNode(int capacity)
        {
            counts = DictionaryCreator<T>.Create<long>(capacity);
        }
        /// <summary>
        /// Load snapshot data (recover memory data from snapshot data)
        /// </summary>
        /// <param name="value">data</param>
        public void SnapshotSet(BinarySerializeKeyValue<T, long> value)
        {
            counts.Add(value.Key, value.Value);
        }
        /// <summary>
        /// Count +1
        /// </summary>
        /// <param name="key">The keyword for counting</param>
        /// <returns>If the key is null, it returns false</returns>
        public bool Increment(T key)
        {
            if (key != null)
            {
                if (counts.TryGetValue(key, out long count)) counts[key] = count + 1;
                else counts.Add(key, 1);
                return true;
            }
            return false;
        }
        /// <summary>
        /// Get the current count
        /// </summary>
        /// <param name="key">The keyword for counting</param>
        /// <returns>If the key is null, -1 will be returned</returns>
        public long GetCount(T key)
        {
            if (key != null) return counts.TryGetValue(key, out long count) ? count : 0;
            return -1;
        }
        /// <summary>
        /// Delete the count
        /// </summary>
        /// <param name="key">The keyword for counting</param>
        /// <returns>Returning false indicates that the keyword does not exist</returns>
        public bool Remove(T key)
        {
            return key != null && counts.Remove(key);
        }
    }
```
## 3. Implement the collection snapshot interface
The [node instance](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/DictionaryCounterNode/DictionaryCounterNode.cs) needs to implement the snapshot interface function:
``` csharp
    /// <summary>
    /// Dictionary counter node example
    /// </summary>
    /// <typeparam name="T">Keyword type</typeparam>
    public sealed class DictionaryCounterNode<T> : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<BinarySerializeKeyValue<T, long>>
    {
        /// <summary>
        /// Get the snapshot data collection container size for pre-applying snapshot data containers
        /// </summary>
        /// <param name="customObject">Custom objects for pre-generating auxiliary data</param>
        /// <returns>The size of the snapshot data collection container</returns>
        int AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<BinarySerializeKeyValue<T, long>>.GetSnapshotCapacity(ref object customObject)
        {
            return counts.Count;
        }
        /// <summary>
        /// Get the snapshot data collection. If the data object may be modified, the cloned data object should be returned to prevent the data from being modified during the snapshot establishment
        /// </summary>
        /// <param name="snapshotArray">Pre-applied snapshot data container</param>
        /// <param name="customObject">Custom objects for pre-generating auxiliary data</param>
        /// <returns>Snapshot data</returns>
        AutoCSer.CommandService.StreamPersistenceMemoryDatabase.SnapshotResult<BinarySerializeKeyValue<T, long>> AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<BinarySerializeKeyValue<T, long>>.GetSnapshotResult(BinarySerializeKeyValue<T, long>[] snapshotArray, object customObject)
        {
            return AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode.GetSnapshotResult(counts, snapshotArray);
        }
        /// <summary>
        /// Reorganize the snapshot data before persistence
        /// </summary>
        /// <param name="array">Pre-applied snapshot data container</param>
        /// <param name="newArray">Snapshot data collection that exceed the pre-application scope</param>
        void AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<BinarySerializeKeyValue<T, long>>.SetSnapshotResult(ref LeftArray<BinarySerializeKeyValue<T, long>> array, ref LeftArray<BinarySerializeKeyValue<T, long>> newArray) { }
    }
```
## 4. Create the node instance
In the custom basic service node, add an [API for creating node instances](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/ICustomServiceNode.cs). Since the node API does not support generic methods, generic Type parameters need to be converted to [AutoCSer.Reflection.RemoteType](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Reflection/RemoteType.cs) parameters. The server needs to manually convert them to type types and then [use reflection operations to create generic nodes](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/CustomServiceNode.cs).
``` csharp
    /// <summary>
    /// Customize the basic service node interface
    /// </summary>
    [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode]
    public partial interface ICustomServiceNode : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IServiceNode
    {
        /// <summary>
        /// Create a dictionary counter node IDictionaryCounterNode{T}
        /// </summary>
        /// <param name="index">Node index information</param>
        /// <param name="key">Node global keyword</param>
        /// <param name="nodeInfo">Server-side node information</param>
        /// <param name="keyType">Keyword type</param>
        /// <param name="capacity">Container initialization size</param>
        /// <returns>Node identifier, there have been a node is returned directly</returns>
        AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex CreateDictionaryCounterNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int capacity);
    }
    
    /// <summary>
    /// Customize the basic service node for adding custom nodes to create API methods
    /// </summary>
    public sealed class CustomServiceNode : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServiceNode, ICustomServiceNode
    {
        /// <summary>
        /// Create a dictionary counter node IDictionaryCounterNode{T}
        /// </summary>
        /// <param name="index">Node index information</param>
        /// <param name="key">Node global keyword</param>
        /// <param name="nodeInfo">Server-side node information</param>
        /// <param name="keyType">Keyword type</param>
        /// <param name="capacity">Container initialization size</param>
        /// <returns>Node identifier, there have been a node is returned directly</returns>
        public AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex CreateDictionaryCounterNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int capacity)
        {
            var type = default(Type);
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum state = getEquatableType(ref keyType, ref type);
            if (state == AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum.Success)
            {
                MethodInfo method = typeof(CustomServiceNode).GetMethod(nameof(createDictionaryCounterNode), BindingFlags.Instance | BindingFlags.NonPublic).notNull();
                return (AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex)method.MakeGenericMethod(type.notNull()).Invoke(this, new object[] { index, key, nodeInfo, capacity }).notNull();
            }
            return new AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex(state);
        }
        /// <summary>
        /// Create a dictionary counter node IDictionaryCounterNode{T}
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="index">Node index information</param>
        /// <param name="key">Node global keyword</param>
        /// <param name="nodeInfo">Server-side node information</param>
        /// <param name="capacity">Container initialization size</param>
        /// <returns>Node identifier, there have been a node is returned directly</returns>
        private AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex createDictionaryCounterNode<T>(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, int capacity)
            where T : IEquatable<T>
        {
            return CreateSnapshotNode<IDictionaryCounterNode<T>>(index, key, nodeInfo, () => new DictionaryCounterNode<T>(capacity));
        }
    }
```
## 5. Static code generation
For specific configuration methods, refer to the [static code generation](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/05.CodeGenerator.Eng.md). The generated {$(ProjectName)}.AutoCSer.cs file contains the API method number for routing and the client interface code.
## 6. Create the client node
Generic type parameters need to be converted to [AutoCSer.Reflection.RemoteType](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Reflection/RemoteType.cs) parameters. The [sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/Client/DictionaryCounterNode.cs) is as follows:
``` csharp
    /// <summary>
    /// Dictionary counter node client example
    /// </summary>
    internal static class DictionaryCounterNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<IDictionaryCounterNodeClientNode<int>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateNode<IDictionaryCounterNodeClientNode<int>>(nameof(DictionaryCounterNode), (index, key, nodeInfo) => client.ClientNode.CreateDictionaryCounterNode(index, key, nodeInfo, typeof(int), 0)));
        /// <summary>
        /// Dictionary counter node client example
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            IDictionaryCounterNodeClientNode<int> node = nodeResult.Value.notNull();
            //Test the counter with the user identity of 1
            int key = 1;
            var valueResult = await node.GetCount(key);
            if (!valueResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var result = await node.Increment(key);
            if (!result.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var nextResult = await node.GetCount(key);
            if (!nextResult.IsSuccess || nextResult.Value != valueResult.Value + 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
# Snapshot clone object
From the above examples, it can be seen that the implemented API logic does not handle thread safety issues. This is because the thread scheduling strategy adopted by the server can be regarded as **executing the API in a single-thread loop**, so there is **no need to consider thread safety issues**.  
The persistence operation of the request data for the persistence API is another single-threaded loop, so the persistence operation basically does not affect the throughput performance of the API execution. They are designed as a pipeline relationship. For each API request, its persistence and execution logic follow a strict sequence, so there is no need to consider thread safety issues.  
To reduce the impact of persistent reconstruction operations on API throughput performance, persistent reconstruction operations can also be regarded as a new single-threaded loop operation. Throughout the process, except for the call to the method [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Snapshot/ISnapshot.cs).GetSnapshotResult for obtaining the snapshot data set which occupies the API's execution thread, all other operations are executed in **parallel with the API**.  
The persistence of snapshot data requires serialization operations on the snapshot data object. If the **member data of the snapshot data object is modified by parallel API logic** before the serialization operation, it will result in the serialized data generated during the persistence of the snapshot object being the member data modified by the API logic. The consequence is that the **persistence writes incorrect member data** After the database service is restarted, incorrect snapshot data will be read, resulting in incorrect memory data.  
Therefore, to ensure the correctness of the snapshot persistence data, the method for obtaining the snapshot data set should, in principle, return a **completely cloned (deep copy) data object**. Only in this way can the logical modification of object members by executing the API not cause changes to the snapshot persistence data, and the snapshot persistence can write the correct serialized data.  
However, **the consumption of a complete cloning operation may be even higher than that of a serialization operation**. Not only does it require copying member data, but also creating new objects. For nodes with large amounts of data, this operation will **occupy the API execution thread for a long time** when triggering the operation to obtain the snapshot data set, which will have a serious impact on the **throughput performance and stability** of the database. So from the perspective of comprehensive performance, we should **avoid complete cloning operations** as much as possible.  
In the implementation of the built-in universal data structure node, only the bitmap uses System.Buffer.BlockCopy to copy the entire byte[] array data when obtaining snapshot data, achieving a complete cloning operation. Other data structures all return arrays of the original objects. Since these objects do not have any member modification operations on the server side, they will not affect the correctness of the snapshot serialized data.  
Through analysis, we can draw a conclusion that as long as no **member of a certain object has both value retrieval and assignment operations** in the logic of the persistence API, even if the persistence writes incorrect snapshot data, the **final state of the memory data will be correct** after all the persistent data are executed in sequence. These scenarios do not require the consideration of complete cloning operations.  
Since conventional general-purpose data structures basically **operate on snapshot data objects as a whole object**, there is no logic for modifying a certain member of the snapshot data object. Therefore, when creating general-purpose data structures, it is generally not necessary to consider complete cloning operations.  
  
Allowing developers to customize nodes based on actual business needs is a key core function of the AutoCSer in-memory database. In such demand scenarios, the member value retrieval and assignment operations of snapshot data objects are almost **inevitable** and ubiquitous.  
To avoid full cloning operations in the method of obtaining snapshot data in custom requirement scenarios, AutoCSer provides a built-in **snapshot clone object** type [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.SnapshotCloneObject<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Snapshot/SnapshotCloneObject.cs) to support **manual triggering of clone operations on snapshot data objects in the persistence API**.  
As long as the snapshot clone object is not accessed by the persistence API from the time the snapshot data is obtained until the serialization operation for persistence is completed, a full cloning operation is not required. During the persistence operation of this object, when serializing the snapshot data, a lock(this) synchronization operation is performed. The developer needs to manually execute the CheckSnapshotValue method before taking values or assigning values to the members of this object to trigger a custom cloning operation.  
If developers are concerned that forgetting to manually execute the CheckSnapshotValue method somewhere in the logic of the persistence API may cause errors in the serialized data of the persistence, AutoCSer provides built-in encapsulation type [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CheckSnapshotCloneObject<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Snapshot/CheckSnapshotCloneObject.cs). By default, every operation to obtain a data object triggers the execution of the CheckSnapshotValue method.
## 1. Define the snapshot clone object
Still taking the generic dictionary counter function as an example, first [define the counting object that supports snapshot cloning](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/DictionarySnapshotCloneCounterNode/SnapshotCloneCounter.cs).
``` csharp
    /// <summary>
    /// Reference type counter object (snapshot data that supports manual triggering of clone operations for snapshot data objects in the persistence API)
    /// </summary>
    /// <typeparam name="T">Keyword type</typeparam>
    [AutoCSer.BinarySerialize(IsReferenceMember = false)]
    public sealed class SnapshotCloneCounter<T> : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.SnapshotCloneObject<SnapshotCloneCounter<T>>
    {
        /// <summary>
        /// Parameterless construction, used for reflecting to generate objects
        /// </summary>
        private SnapshotCloneCounter() { }
        /// <summary>
        /// Reference type counter object
        /// </summary>
        /// <param name="key">keyword</param>
        public SnapshotCloneCounter(T key)
        {
            Key = key;
            Count = 1;
        }
        /// <summary>
        /// Keyword
        /// </summary>
        [AllowNull]
        public T Key { get; private set; }
        /// <summary>
        /// Current count
        /// </summary>
        public long Count { get; private set; }
        /// <summary>
        /// Count +1
        /// </summary>
        public void Increment()
        {
            //This operation involves both value retrieval and assignment operations simultaneously, which is equivalent to Count = Count + 1;
            ++Count;
        }
    }
```
## 2. Define the node API interface
It is similar to the definition of the generic data structure node API interface, but the difference is that the [parameter type of the method for loading snapshot data is the snapshot clone object type](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/DictionarySnapshotCloneCounterNode/IDictionarySnapshotCloneCounterNode.cs).
``` csharp
    /// <summary>
    /// An example of the dictionary counter node interface supporting snapshot cloning
    /// </summary>
    /// <typeparam name="T">Keyword type</typeparam>
    [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode]
    public partial interface IDictionarySnapshotCloneCounterNode<T> where T : IEquatable<T>
    {
        /// <summary>
        /// Load snapshot data (recover memory data from snapshot data)
        /// </summary>
        /// <param name="value">data</param>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethod(IsClientCall = false, SnapshotMethodSort = 1)]
        void SnapshotSet(SnapshotCloneCounter<T> value);
        /// <summary>
        /// Count +1
        /// </summary>
        /// <param name="key">The keyword for counting</param>
        /// <returns>If the key is null, it returns false</returns>
        bool Increment(T key);
        /// <summary>
        /// Get the current count
        /// </summary>
        /// <param name="key">The keyword for counting</param>
        /// <returns>If the key is null, -1 will be returned</returns>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethod(IsPersistence = false)]
        long GetCount(T key);
        /// <summary>
        /// Delete the count
        /// </summary>
        /// <param name="key">The keyword for counting</param>
        /// <returns>Returning false indicates that the keyword does not exist</returns>
        bool Remove(T key);
    }
```
## 3. Implement the API function of the node
The [node instance](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/DictionarySnapshotCloneCounterNode/DictionarySnapshotCloneCounterNode.cs)needs to implement the node interface function. Note that the data type of the dictionary uses the **encapsulation of snapshot clone object**:
``` csharp
    /// <summary>
    /// An example of the dictionary counter node supporting snapshot cloning
    /// </summary>
    /// <typeparam name="T">Keyword type</typeparam>
    public sealed class DictionarySnapshotCloneCounterNode<T> : IDictionarySnapshotCloneCounterNode<T>
        where T : IEquatable<T>
    {
        /// <summary>
        /// Dictionary counter
        /// </summary>
        private Dictionary<T, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CheckSnapshotCloneObject<SnapshotCloneCounter<T>>> counts;
        /// <summary>
        /// An example of the dictionary counter node supporting snapshot cloning
        /// </summary>
        /// <param name="capacity">Container initialization size</param>
        internal DictionarySnapshotCloneCounterNode(int capacity)
        {
            counts = DictionaryCreator<T>.Create<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CheckSnapshotCloneObject<SnapshotCloneCounter<T>>>(capacity);
        }
        /// <summary>
        /// Load snapshot data (recover memory data from snapshot data)
        /// </summary>
        /// <param name="value">data</param>
        public void SnapshotSet(SnapshotCloneCounter<T> value)
        {
            counts.Add(value.Key, value);
        }
        /// <summary>
        /// Count +1
        /// </summary>
        /// <param name="key">The keyword for counting</param>
        /// <returns>If the key is null, it returns false</returns>
        public bool Increment(T key)
        {
            if (key != null)
            {
                if (counts.TryGetValue(key, out AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CheckSnapshotCloneObject<SnapshotCloneCounter<T>> count)) count.GetNotNull().Increment();
                else counts.Add(key, new SnapshotCloneCounter<T>(key));
                return true;
            }
            return false;
        }
        /// <summary>
        /// Get the current count
        /// </summary>
        /// <param name="key">The keyword for counting</param>
        /// <returns>If the key is null, -1 will be returned</returns>
        public long GetCount(T key)
        {
            if (key != null) return counts.TryGetValue(key, out AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CheckSnapshotCloneObject<SnapshotCloneCounter<T>> count) ? count.NoCheckNotNull().Count : 0;
            return -1;
        }
        /// <summary>
        /// Delete the count
        /// </summary>
        /// <param name="key">The keyword for counting</param>
        /// <returns>Returning false indicates that the keyword does not exist</returns>
        public bool Remove(T key)
        {
            return key != null && counts.Remove(key);
        }
    }
```
## 4. Implement the snapshot interface
The [node instance](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/DictionarySnapshotCloneCounterNode/DictionarySnapshotCloneCounterNode.cs) needs to implement the snapshot interface function:
``` csharp
    /// <summary>
    /// An example of the dictionary counter node supporting snapshot cloning
    /// </summary>
    /// <typeparam name="T">Keyword type</typeparam>
    public sealed class DictionarySnapshotCloneCounterNode<T> : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<SnapshotCloneCounter<T>>
        where T : IEquatable<T>
    {
        /// <summary>
        /// Get the snapshot data collection container size for pre-applying snapshot data containers
        /// </summary>
        /// <param name="customObject">Custom objects for pre-generating auxiliary data</param>
        /// <returns>The size of the snapshot data collection container</returns>
        int AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<SnapshotCloneCounter<T>>.GetSnapshotCapacity(ref object customObject)
        {
            return counts.Count;
        }
        /// <summary>
        /// Get the snapshot data collection. If the data object may be modified, the cloned data object should be returned to prevent the data from being modified during the snapshot establishment
        /// </summary>
        /// <param name="snapshotArray">Pre-applied snapshot data container</param>
        /// <param name="customObject">Custom objects for pre-generating auxiliary data</param>
        /// <returns>Snapshot data</returns>
        AutoCSer.CommandService.StreamPersistenceMemoryDatabase.SnapshotResult<SnapshotCloneCounter<T>> AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<SnapshotCloneCounter<T>>.GetSnapshotResult(SnapshotCloneCounter<T>[] snapshotArray, object customObject)
        {
            return SnapshotCloneCounter<T>.GetSnapshotResult(snapshotArray, counts.Values);
        }
        /// <summary>
        /// Reorganize the snapshot data before persistence
        /// </summary>
        /// <param name="array">Pre-applied snapshot data container</param>
        /// <param name="newArray">Snapshot data collection that exceed the pre-application scope</param>
        void AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<SnapshotCloneCounter<T>>.SetSnapshotResult(ref LeftArray<SnapshotCloneCounter<T>> array, ref LeftArray<SnapshotCloneCounter<T>> newArray) { }
    }
```
## 5. Create the node instance
Just like creating an instance of a generic data structure node, the [sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/CustomServiceNode.cs) is as follows:
``` csharp
    /// <summary>
    /// Customize the basic service node interface
    /// </summary>
    [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode]
    public partial interface ICustomServiceNode : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IServiceNode
    {
        /// <summary>
        /// Create a dictionary counter node that supports snapshot cloning IDictionarySnapshotCloneCounterNode{T}
        /// </summary>
        /// <param name="index">Node index information</param>
        /// <param name="key">Node global keyword</param>
        /// <param name="nodeInfo">Server-side node information</param>
        /// <param name="keyType">Keyword type</param>
        /// <param name="capacity">Container initialization size</param>
        /// <returns>Node identifier, there have been a node is returned directly</returns>
        AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex CreateDictionarySnapshotCloneCounterNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int capacity);
    }
    
    /// <summary>
    /// Customize the basic service node for adding custom nodes to create API methods
    /// </summary>
    public sealed class CustomServiceNode : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServiceNode, ICustomServiceNode
    {
        /// <summary>
        /// Create a dictionary counter node that supports snapshot cloning IDictionarySnapshotCloneCounterNode{T}
        /// </summary>
        /// <param name="index">Node index information</param>
        /// <param name="key">Node global keyword</param>
        /// <param name="nodeInfo">Server-side node information</param>
        /// <param name="keyType">Keyword type</param>
        /// <param name="capacity">Container initialization size</param>
        /// <returns>Node identifier, there have been a node is returned directly</returns>
        public AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex CreateDictionarySnapshotCloneCounterNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int capacity)
        {
            var type = default(Type);
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum state = getEquatableType(ref keyType, ref type);
            if (state == AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum.Success)
            {
                MethodInfo method = typeof(CustomServiceNode).GetMethod(nameof(createDictionarySnapshotCloneCounterNode), BindingFlags.Instance | BindingFlags.NonPublic).notNull();
                return (AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex)method.MakeGenericMethod(type.notNull()).Invoke(this, new object[] { index, key, nodeInfo, capacity }).notNull();
            }
            return new AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex(state);
        }
        /// <summary>
        /// Create a dictionary counter node that supports snapshot cloning IDictionarySnapshotCloneCounterNode{T}
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="index">Node index information</param>
        /// <param name="key">Node global keyword</param>
        /// <param name="nodeInfo">Server-side node information</param>
        /// <param name="capacity">Container initialization size</param>
        /// <returns>Node identifier, there have been a node is returned directly</returns>
        private AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex createDictionarySnapshotCloneCounterNode<T>(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, int capacity)
            where T : IEquatable<T>
        {
            return CreateSnapshotNode<IDictionarySnapshotCloneCounterNode<T>>(index, key, nodeInfo, () => new DictionarySnapshotCloneCounterNode<T>(capacity));
        }
    }
```
## 6. Static code generation
For specific configuration methods, refer to the [static code generation](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/05.CodeGenerator.Eng.md). The generated {$(ProjectName)}.AutoCSer.cs file contains the API method number for routing and the client interface code.
## 7. Create the client node
Just like creating client nodes for generic data structures, the [sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/Client/DictionarySnapshotCloneCounterNode.cs) is as follows:
``` csharp
    /// <summary>
    /// A client example of a dictionary counter node that supports snapshot cloning
    /// </summary>
    internal static class DictionarySnapshotCloneCounterNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<IDictionarySnapshotCloneCounterNodeClientNode<int>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateNode<IDictionarySnapshotCloneCounterNodeClientNode<int>>(nameof(DictionarySnapshotCloneCounterNode), (index, key, nodeInfo) => client.ClientNode.CreateDictionarySnapshotCloneCounterNode(index, key, nodeInfo, typeof(int), 0)));
        /// <summary>
        /// A client example of a dictionary counter node that supports snapshot cloning
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            IDictionarySnapshotCloneCounterNodeClientNode<int> node = nodeResult.Value.notNull();

            //Test the counter with the user identity of 1
            int key = 1;
            var valueResult = await node.GetCount(key);
            if (!valueResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var result = await node.Increment(key);
            if (!result.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var nextResult = await node.GetCount(key);
            if (!nextResult.IsSuccess || nextResult.Value != valueResult.Value + 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
# Multi-snapshot node
A multi-snapshot node is a node that implements the snapshot function of multiple snapshot data types. **No duplicate snapshot data types are allowed** in the same node. The order of persistence operations is determined by the SnapshotMethodSort configured by the API method.  
For instance, to **avoid distributed transaction issues**, all the data of an application might be processed in a single custom node. This node is equivalent to a database of a traditional application. A database usually has multiple data tables, which may lead to the need for persistence of multiple snapshot collections.  
For instance, an in-game service node may contain various data sets with persistent requirements, such as users, monsters, and items. Of course, you might have doubts. Since object-oriented programming is already supported, why not directly persist a root object that contains all business objects?  
Yes, for smaller data, you can indeed treat the root object of a certain business data as a snapshot object. However, this approach almost **cannot avoid complete cloning operations**. Moreover, since the serialization of AutoCSer is a pure memory operation, it will cause the related output data buffer to **occupy a large amount of memory resources**.  
Here is a simple example of a [multi-snapshot node](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/BeforePersistenceNode/BeforePersistenceNode.cs):
``` csharp
    /// <summary>
    /// Example of a persistent pre-check node interface
    /// </summary>
    [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode]
    public partial interface IBeforePersistenceNode
    {
        /// <summary>
        /// Load snapshot data (recover memory data from snapshot data)
        /// </summary>
        /// <param name="value">data</param>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethod(IsClientCall = false, SnapshotMethodSort = 1)]
        void SnapshotSetEntity(IdentityEntity value);
        /// <summary>
        /// Load snapshot data (recover memory data from snapshot data)
        /// </summary>
        /// <param name="identity">Current allocation identity</param>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethod(IsClientCall = false, SnapshotMethodSort = 2)]
        void SnapshotSetIdentity(long identity);
    }

    /// <summary>
    /// Example of a persistent pre-check node
    /// </summary>
    public sealed class BeforePersistenceNode : IBeforePersistenceNode
        , AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<IdentityEntity>
        , AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IEnumerableSnapshot<long>
    {
        #region A snapshot of the data collection with identity
        /// <summary>
        /// Get the snapshot data collection container size for pre-applying snapshot data containers
        /// </summary>
        /// <param name="customObject">Custom objects for pre-generating auxiliary data</param>
        /// <returns>The size of the snapshot data collection container</returns>
        int AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<IdentityEntity>.GetSnapshotCapacity(ref object customObject)
        {
            return entities.Count;
        }
        /// <summary>
        /// Get the snapshot data collection. If the data object may be modified, the cloned data object should be returned to prevent the data from being modified during the snapshot establishment
        /// </summary>
        /// <param name="snapshotArray">Pre-applied snapshot data container</param>
        /// <param name="customObject">Custom objects for pre-generating auxiliary data</param>
        /// <returns>Snapshot data</returns>
        AutoCSer.CommandService.StreamPersistenceMemoryDatabase.SnapshotResult<IdentityEntity> AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<IdentityEntity>.GetSnapshotResult(IdentityEntity[] snapshotArray, object customObject)
        {
            return IdentityEntity.GetSnapshotResult(snapshotArray, entities.Values);
        }
        /// <summary>
        /// Reorganize the snapshot data before persistence
        /// </summary>
        /// <param name="array">Pre-applied snapshot data container</param>
        /// <param name="newArray">Snapshot data collection that exceed the pre-application scope</param>
        void AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshot<IdentityEntity>.SetSnapshotResult(ref LeftArray<IdentityEntity> array, ref LeftArray<IdentityEntity> newArray) { }
        /// <summary>
        /// Load snapshot data (recover memory data from snapshot data)
        /// </summary>
        /// <param name="value">data</param>
        public void SnapshotSetEntity(IdentityEntity value)
        {
            entities.Add(value.Identity, value);
        }
        #endregion
        #region A snapshot of the currently assigned identity
        /// <summary>
        /// Single-valued snapshot
        /// </summary>
        AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISnapshotEnumerable<long> AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IEnumerableSnapshot<long>.SnapshotEnumerable { get { return new AutoCSer.CommandService.StreamPersistenceMemoryDatabase.SnapshotGetValue<long>(getCurrentIdentity); } }
        /// <summary>
        /// Get the current allocation identity
        /// </summary>
        /// <returns></returns>
        private long getCurrentIdentity()
        {
            return currentIdentity;
        }
        /// <summary>
        /// Load snapshot data (recover memory data from snapshot data)
        /// </summary>
        /// <param name="identity">Current allocation identity</param>
        public void SnapshotSetIdentity(long identity)
        {
            currentIdentity = identity;
        }
        #endregion
    }
```
# Persistent pre-operation
When introducing the **extensible support for object-oriented programming** in the AutoCSer [in-memory database introduction](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/06.MemoryDatabase/06.MemoryDatabase.Eng.md), it was emphasized that the logic of the persistent API needs to be **deterministic**, and the **logic of the replayable API** is the fundamental condition for the correctness of database data.  
This also requires that **no random persistent business data be generated** in the persistence API, and all persistent business data must be uniquely determined by the context. For instance, Random data such as DateTime.Now, Random.Next(), Guid.NewGuid(), etc., are not allowed to be assigned to persistent business data objects in the persistence API. This is because it will cause the database to restart and replay, and when the persistence API is executed to restore memory data, it will **generate business data that is inconsistent with the history**.  
When we create a new persistent business data object, there is often a need for some member values to have a non-deterministic initialization value. The generation of these initialization values may depend on the state of a certain memory data on the server side. **There may not be a simple processing method in the client's calling logic**, so it is necessary to use the server-side logic to generate these business data.  
For this demand scenario, AutoCSer provides a pre-operation mechanism for persistent apis, allowing **a pre-operation method to be added to the binding** of persistent API methods. This pre-operation method will only trigger the persistence operation of the original API after it has been called in the thread executing the API. So in this method, if the **members of the reference type parameter object are modified**, the operation result will be processed as the request data of the persistence API.  
However, persistent pre-operations **cannot address all** the persistent business data requirements for non-deterministic values. In scenarios with complex non-deterministic value requirements, it may not be suitable to use AutoCSer in-memory databases for processing.  
Persistent pre-operations can also be used to determine the legitimacy of call parameters to prevent illegal request parameters from generating persistent operations (of course, the legitimacy check of parameters should be handled in the client's call logic), and can also be used to generate the data objects required by the persistent API in advance to avoid problems such as insufficient memory exceptions during the new operation of the persistent API.  
  
The persistent pre-operation method must be consistent in definition with the corresponding persistent API method, including parameter order, parameter type, parameter name, etc. Although the method name and the return value type are different, they must also meet the matching rules.  
The method name of the persistence pre-operation method must be the method name of the corresponding persistence API method with the **BeforePersistence suffix** added. The definition of the return value type is divided into two cases:  
When the return type of the persistent API method is void, the return value of the pre-operation method must be of the bool type. Returning true indicates that the persistent API method needs to continue to execute normally. **Returning false indicates that the persistence operation and execution operation of the API are cancelled and the Success call status is directly returned**. Therefore, returning false is only allowed in scenarios where the normal execution of the persistence API logic **does not modify the state of the memory data**.  
When the persistence API method has a return value type of T, the return value of the pre-operation method must be of type [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/ValueResult.cs). If the return value of default or IsValue is false, it indicates that the persistence API method needs to continue to execute normally. **If IsValue is returned to true, it indicates that the persistence and execution operations of this API are cancelled and the Value is directly returned to the client**. Therefore, only in scenarios where the normal execution of the persistence API logic also **returns the same Value and does not modify the state of the memory data** is it allowed to return IsValue as true.  
Here is a simple [example of the persistent pre-operation](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/BeforePersistenceNode/BeforePersistenceNode.cs):
``` csharp
        /// <summary>
        /// Add a new data (Check the input parameters before the persistence operation)
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<long> AppendEntityBeforePersistence(IdentityEntity value)
        {
            if (value != null)
            {
                //Clean up the parameters passed by the client
                value.Identity = 0;
                //Returning the default value will continue to execute the AppendEntity method
                return default(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<long>);
            }
            //If a non-default value is returned, it will be returned directly without executing the AppendEntity method, nor will the requested data be persisted
            return 0;
        }
        /// <summary>
        /// Add a new data
        /// </summary>
        /// <param name="value"></param>
        /// <returns>New data identity. Return 0 if failed</returns>
        public long AppendEntity(IdentityEntity value)
        {
            if (value.Identity == 0) value.Identity = ++currentIdentity;
            entities.Add(value.Identity, value);
            return value.Identity;
        }
```
# Initialize loading data
Since the persistence API of the AutoCSer in-memory database needs to support replay execution, in actual business requirement scenarios, developers may need to distinguish in some special persistence apis whether the current logic is generated by the cold-started historical data of the database or by a new request initiated by the client.  
Since most actual business requirements are **not merely about modifying the in-memory data state of persistent business data**, they may also need to trigger some event operations (such as sending email notifications). If the current logic is generated from **historical persistent data**, **These event operations should not be repeated** (of course, if the event logic itself is idempotent, it might just be a waste of some computing resources).  
In a simple logical requirement scenario, allowing the [node instance type](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/LoadPersistenceNode/LoadPersistenceNode.cs) to be derived from type [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ContextNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Server/ContextNode.cs) can **bind the context of the current database service** during the node initialization process. Through this context, it can be determined whether the current execution logic is generated by a new request initiated by the client.
``` csharp
    /// <summary>
    /// The API sample node for initialize and load the persistent data
    /// </summary>
    public sealed class LoadPersistenceNode : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ContextNode<ILoadPersistenceNode>, ILoadPersistenceNode
    {
        /// <summary>
        /// Count +1
        /// </summary>
        public void Increment()
        {
            ++count;
            //If IsLoaded is true, it indicates that the current execution logic is generated by a new request initiated by the client; otherwise, it indicates that the current execution logic is generated by historical data cold-started from the database
            if (base.StreamPersistenceMemoryDatabaseService.IsLoaded) ;
        }
    }
```
However, in complex logical demand scenarios, such judgment operations are prone to cause more complex **coupling and confusion** in the logical call chain. Moreover, developers are very likely to **forget to call the judgment logic** at a certain logical call point, resulting in the generation of some redundant or even incorrect operation logics.  
For this scenario requirement, AutoCSer supports splitting this API into two **independent API logic branches with clear requirements**. The system automatically selects and executes different API logics based on the current state, and for new requests initiated by the client, it executes the complete original API logic. For the historical data of the database cold start, an API logic that only modifies the persistent business data is executed.  
The [method for initializing and loading persistent data](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/LoadPersistenceNode/LoadPersistenceNode.cs) must be consistent in definition with the corresponding persistence API method, including parameter order, parameter type, parameter name, return value type, etc. The method name must be the method name of the corresponding persistence API method with the **LoadPersistence suffix** added.
``` csharp
    /// <summary>
    /// The API sample node for initialize and load the persistent data
    /// </summary>
    public sealed class LoadPersistenceNode : ILoadPersistenceNode
    {
        /// <summary>
        /// Count +1 (Initialize and load the persistent data)
        /// </summary>
        public void IncrementLoadPersistence()
        {
            ++count;
            //output false
            Console.WriteLine($"IsLoaded {base.StreamPersistenceMemoryDatabaseService.IsLoaded} in {nameof(IncrementLoadPersistence)}");
        }
        /// <summary>
        /// Count +1
        /// </summary>
        public void Increment()
        {
            ++count;
            //output true
            Console.WriteLine($"IsLoaded {base.StreamPersistenceMemoryDatabaseService.IsLoaded} in {nameof(Increment)}");
        }
    }
```
# JSON mixed binary serialization
The persistence operation of AutoCSer in-memory database, like RPC, **defaults to binary serialization**. However, binary serialization requires **stable data definitions**; otherwise, it will cause the **deserialization of persistent data to fail**, resulting in the **inability to restore the in-memory data state normally and the in-memory database to be restarted normally**.  
Since the member definitions of most business data types are unstable, these business data types should be [explicitly configured as JSON mixed binary serialization](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/BeforePersistenceNode/IdentityEntity.cs). However, this serialization mode will significantly reduce the efficiency of data serialization as it requires writing and parsing member names, and it will also greatly increase the size of persistent files.  
The serialization configuration of data is also **not allowed to be changed**. Altering the serialization configuration will also cause the problem of deserialization failure. Therefore, the serialization configuration of business data **must be weighed and determined at the design stage**. If there is a need for definition modification in the future, the correct approach should be to redefine independent business data types and add new apis to handle the issue.
``` csharp
    /// <summary>
    /// Test data with identity
    /// </summary>
    [AutoCSer.BinarySerialize(IsJsonMix = true)]
    public sealed class IdentityEntity
```
# Performance testing
Based on the concurrent throughput test results of the .NET Redis client and the AutoCSer in-memory database, for the same requirements in high-concurrency scenarios, the overall upper limit of the test throughput performance of the AutoCSer in-memory database **exceeds that of StackExchange.Redis + Garnet by several times**. The more lightweight the API is tested, the greater the gap in concurrent throughput performance between the two.  
Garnet is adopted to replace the Redis server because a large number of test results show that the **throughput performance of Garnet is more than twice that of Redis**. **StackExchange.Redis has the best test results among various .NET clients**, and the throughput performance gap between it and other clients reaches an order of magnitude.  
[.NET Redis test project](https://github.com/AutoCSer/AutoCSer2/tree/main/TestCase/ThirdParty/RedisPerformance)  
[AutoCSer in-memory database test server project](https://github.com/AutoCSer/AutoCSer2/tree/main/TestCase/StreamPersistenceMemoryDatabase/Performance)  
[AutoCSer in-memory database test client project](https://github.com/AutoCSer/AutoCSer2/tree/main/TestCase/StreamPersistenceMemoryDatabase/PerformanceClient)  
In addition to supporting custom nodes and having the advantage of concurrent throughput performance, AutoCSer in-memory database also supports **reliable persistence** and [local embedding mode](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/09.MemoryDatabaseLocalService/09.MemoryDatabaseLocalService.Eng.md), which are both important features. Moreover, the full-duplex response mechanism of AutoCSer RPC can **better adapt to high-latency network environments compared** to the response mode of Redis. Provide **more stable practical performance** advantages.  
Of course, achieving high-performance custom nodes does **have certain requirements for developers' capabilities**. If you have a certain understanding of **data structures and algorithm** complexity, then you can easily build an API that outperforms Garnet/Redis in the .NET environment through AutoCSer in-memory database.
# [Local embedding mode](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/09.MemoryDatabaseLocalService/09.MemoryDatabaseLocalService.Eng.md)