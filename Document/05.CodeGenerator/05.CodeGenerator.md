# 静态代码生成
虽然 Emit 可以解决运行时动态生成代码的需求，但总会有些需求更适合使用静态代码生成技术来解决（比如生成的中间代码可能需要在 IDE 中使用），还有 [AOT](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/12.NativeAOT/12.NativeAOT.md) 环境无法使用 Emit 往往也需要引入静态代码生成技术来解决问题。  
AutoCSer 的静态代码生成不是微软官方的 Source Generator 方案，而是**为 AutoCSer 框架需求定制**的一个基于简单的[自定义模板](https://github.com/AutoCSer/AutoCSer2/tree/main/AutoCSer/CodeGenerator/Template)引擎的实现，具体支持项目为 [AutoCSer.CodeGenerator.NET8.csproj](https://github.com/AutoCSer/AutoCSer2/tree/main/AutoCSer/CodeGenerator)。它通过读取目标程序集相关的元数据信息，为代码模板提供数据源，类似于 WEB 开发中的 MV* 模板技术。  
AutoCSer 静态代码生成组件的特点是 **C# 模板代码也要求是可编译的**（不是文本模板），模板中的主体代码除了指令以外基本都是常规代码，这样的模板代码可以感知被依赖项目的大多数重构操作，具有较好的可维护性。  
使用 AutoCSer 静态代码生成功能，需要在 VS 项目属性的**生成**菜单下点击**事件**选项，在**生成后事件**的输入框中输入如下代码（注意需要根据不同的平台版本修改 AutoCSer.CodeGenerator.exe 的真实路径）：
``` text
if exist "C:\AutoCSer\CodeGenerator\bin\Release\net8.0\AutoCSer.CodeGenerator.exe" C:\AutoCSer\CodeGenerator\bin\Release\net8.0\AutoCSer.CodeGenerator.exe "$(ProjectName)" "$(ProjectDir) " "$(TargetPath) " "$(RootNamespace)"
```
![静态代码生成的项目配置](CodeGenerator.png)
本质上就是在项目的程序集生成成功的时候 VS 会触发生成后事件调用 AutoCSer.CodeGenerator.exe 来生成静态代码，正常情况下会在目录 $(TargetPath) 中生成一个名为 **{$(ProjectName)}.AutoCSer.cs** 的 C# 代码文件。非 IDE 环境可以手动调用命令行，将环境变量替换为真实值即可。  
如果需要生成的代码包含 API 的 XML 文档，需要在**生成**菜单下点击**输出**选项，勾选**文档文件**选项，这样就会生成程序集的 XML 文档文件。
# RPC
由于客户端与服务端存在不同的线程调度需求，所以客户端与服务端的接口 API 定义也不同，我们可以给[服务接口](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/Service/IServiceController.cs)添加 [AutoCSer.Net.CommandServerControllerInterfaceAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerControllerInterfaceAttribute.cs) 配置，这样就可以生成默认的[客户端接口 API 定义](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/%7BAutoCSer.Document.CodeGenerator%7D.AutoCSer.cs)。
``` csharp
    /// <summary>
    /// 生成客户端控制器接口 API 定义示例
    /// </summary>
    [AutoCSer.Net.CommandServerControllerInterface]
    public partial interface IServiceController
    {
        /// <summary>
        /// 一次性响应 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        int OneTimeResponse(int left, int right);
        /// <summary>
        /// 二阶段响应 API 示例
        /// </summary>
        /// <param name="callback">第一阶段的回调委托包装，倒数第二个参数类型必须是 AutoCSer.Net.CommandServerCallback{T}</param>
        /// <param name="keepCallback">第二阶段持续响应的回调委托包装，最后一个参数类型必须是 AutoCSer.Net.CommandServerKeepCallback{T} 或者 AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be void</returns>
        void TwoStageResponse(AutoCSer.Net.CommandServerCallback<string> callback, AutoCSer.Net.CommandServerKeepCallback<int> keepCallback);
    }
```
``` csharp
        /// <summary>
        /// 生成客户端控制器接口 API 定义示例 client interface
        /// </summary>
        public partial interface IServiceControllerClientController
        {
            /// <summary>
            /// 一次性响应 API 示例
            /// </summary>
            /// <param name="left"></param>
            /// <param name="right"></param>
            /// <returns></returns>
            AutoCSer.Net.ReturnCommand<int> OneTimeResponse(int left, int right);
            /// <summary>
            /// 二阶段响应 API 示例
            /// </summary>
            /// <param name="callback">第一阶段的回调委托包装，倒数第二个参数类型必须是 AutoCSer.Net.CommandServerCallback{T}</param>
            /// <param name="keepCallback">第二阶段持续响应的回调委托包装，最后一个参数类型必须是 AutoCSer.Net.CommandServerKeepCallback{T} 或者 AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
            /// <returns></returns>
            AutoCSer.Net.KeepCallbackCommand TwoStageResponse(Action<AutoCSer.Net.CommandClientReturnValue<string>> callback, Action<AutoCSer.Net.CommandClientReturnValue<int>, AutoCSer.Net.KeepCallbackCommand> keepCallback);
        }
```
AutoCSer 默认生成的客户端 API 的返回值会**携带网络交互状态信息**，对于习惯于 API 直接返回需求数据类型的开发者，可以在客户端套接字事件的派生类中重写属性 [AutoCSer.Net.CommandClientSocketEvent](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientSocketEvent/CommandClientSocketEvent.cs).IsCodeGeneratorReturnValueController 并设置为 true 以触发这种 API 封装代码的生成。  
该功能要求客户端套接字事件的派生类型提供一个构造函数，该构造函数有且仅有一个 [AutoCSer.Net.CommandClient](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClient.cs) 类型的参数，当然这本身就是一个常规操作，[示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/Service/CommandClientSocketEvent.cs)如下：
``` csharp
    /// <summary>
    /// 命令客户端套接字事件
    /// </summary>
    internal sealed partial class CommandClientSocketEvent : AutoCSer.Net.CommandClientSocketEventTask<CommandClientSocketEvent>
    {
        /// <summary>
        /// 客户端接口示例
        /// </summary>
        [AllowNull]
        public IServiceControllerClientController ServiceControllerClientController { get; private set; }
        /// <summary>
        /// 客户端控制器创建参数集合，用于命令客户端套接字初始化是创建客户端控制器对象，同时也用于命令客户端套接字事件在通过认证 API 之后根据客户端控制器接口类型自动绑定控制器属性
        /// </summary>
        public override IEnumerable<AutoCSer.Net.CommandClientControllerCreatorParameter> ControllerCreatorParameters
        {
            get
            {
                yield return new AutoCSer.Net.CommandClientControllerCreatorParameter(typeof(Service.IServiceController), typeof(IServiceControllerClientController));
            }
        }
        /// <summary>
        /// 生成直接获取返回值的客户端控制器封装类型
        /// </summary>
        public override bool IsCodeGeneratorReturnValueController { get { return true; } }
        /// <summary>
        /// 命令客户端套接字事件
        /// </summary>
        /// <param name="client">Command client</param>
        public CommandClientSocketEvent(AutoCSer.Net.CommandClient client) : base(client) { }
    }
```
生成的 API 封装代码如下：
``` csharp
    /// <summary>
    /// 命令客户端套接字事件
    /// </summary>
    internal partial class CommandClientSocketEvent
    {
        /// <summary>
        /// 客户端接口示例 (Direct return value API encapsulation)
        /// </summary>
        public sealed class ServiceControllerClientControllerReturnValueController
        {
            /// <summary>
            /// Command client socket event
            /// </summary>
            private readonly AutoCSer.Document.NativeAOT.Service.CommandClientSocketEvent __client__;
            /// <summary>
            /// Whether errors and exceptions are ignored
            /// </summary>
            private readonly bool __isIgnoreError__;
            /// <summary>
            /// 客户端接口示例 (Direct return value API encapsulation)
            /// </summary>
            /// <param name="client">Command client socket event</param>
            /// <param name="isIgnoreError">Whether errors and exceptions are ignored</param>
            public ServiceControllerClientControllerReturnValueController(AutoCSer.Document.NativeAOT.Service.CommandClientSocketEvent client, bool isIgnoreError = false)
            {
                __client__ = client;
                __isIgnoreError__ = isIgnoreError;
            }
            /// <summary>
            /// 一次性响应 API 示例
            /// </summary>
            /// <param name="left"></param>
            /// <param name="right"></param>
            /// <returns></returns>
            [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            public AutoCSer.Net.CommandServer.CommandReturnValue<int> OneTimeResponse(int left, int right)
            {
                
                return this.__client__.ServiceControllerClientController/**/.OneTimeResponse(left, right).GetValue(__isIgnoreError__);
            }
            /// <summary>
            /// 二阶段响应 API 示例
            /// </summary>
            /// <returns></returns>
            [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            public AutoCSer.Net.KeepCallbackCommand TwoStageResponse(System.Action<string> callback, System.Action<int> keepCallback)
            {
                return this.__client__.ServiceControllerClientController/**/.TwoStageResponse(new AutoCSer.Net.CommandServer.ClientReturnValueCallback<string>(callback), new AutoCSer.Net.CommandServer.ClientReturnValueCallback<int>(keepCallback));
            }
            /// <summary>
            /// 二阶段响应 API 示例
            /// </summary>
            /// <returns></returns>
            [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            public AutoCSer.Net.KeepCallbackCommand TwoStageResponse(System.Action<string> callback, Action<AutoCSer.Net.CommandClientReturnValue> error_callback, System.Action<int> keepCallback, Action<AutoCSer.Net.CommandClientReturnValue> error_keepCallback)
            {
                return this.__client__.ServiceControllerClientController/**/.TwoStageResponse(new AutoCSer.Net.CommandServer.ClientReturnValueCallback<string>(callback, error_callback), new AutoCSer.Net.CommandServer.ClientReturnValueCallback<int>(keepCallback, error_keepCallback));
            }
        }
        /// <summary>
        /// Get the direct return value API encapsulation (ServiceControllerClientController)
        /// </summary>
        /// <param name="isIgnoreError">Whether errors and exceptions are ignored</param>
        /// <returns>客户端接口示例 (Direct return value API encapsulation)</returns>
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public ServiceControllerClientControllerReturnValueController GetServiceControllerClientControllerReturnValueController(bool isIgnoreError = false) { return new ServiceControllerClientControllerReturnValueController(this, isIgnoreError); }
    }
```
由于直接返回需求数据类型的**委托回调操作无法抛出 Exception 异常**，所以将回调委托参数分拆为**正常回调**与**错误回调**两个参数来处理，同时会生成一个没有错误回调参数的 API 用于可以忽略错误信息的场景。
# 内存数据库
内存数据库节点的服务端只支持队列线程的同步调度模式，而客户端只支持 await 异步调度模式，所以客户端与服务端的节点接口 API 定义是不同的，需要给[服务端节点接口](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/MemoryDatabase/IServerNode.cs)添加 [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Server/ServerNodeAttribute.cs) 配置，这样就可以生成默认的客户端节点接口 API 定义。
``` csharp
    /// <summary>
    /// 生成客户端节点接口 API 定义示例
    /// </summary>
    [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode]
    public partial interface IServerNode
    {
        /// <summary>
        /// Test API
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        int Add(int left, int right);
    }
```
``` csharp
        /// <summary>
        /// 生成客户端节点接口 API 定义示例 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.Document.CodeGenerator.MemoryDatabase.IServerNode))]
        public partial interface IServerNodeClientNode
        {
            /// <summary>
            /// Test API
            /// </summary>
            /// <param name="left"></param>
            /// <param name="right"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> Add(int left, int right);
        }
```
[本地嵌入模式](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/MemoryDatabase/ILocalNode.cs)则需要**设置 IsLocalClient 为 true** 才会生成本地客户端节点接口 API 定义。
``` csharp
    /// <summary>
    /// 生成本地客户端节点接口 API 定义示例
    /// </summary>
    [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode(IsLocalClient = true, IsClient = false)]
    public partial interface ILocalNode
    {
        /// <summary>
        /// Test API
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        int Add(int left, int right);
    }
```
``` csharp
        /// <summary>
        /// 生成本地客户端节点接口 API 定义示例 local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.Document.CodeGenerator.MemoryDatabase.ILocalNode))]
        public partial interface ILocalNodeLocalClientNode
        {
            /// <summary>
            /// Test API
            /// </summary>
            /// <param name="left"></param>
            /// <param name="right"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> Add(int left, int right);
        }
```
# [内存数据库简介](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/06.MemoryDatabase/06.MemoryDatabase.md)