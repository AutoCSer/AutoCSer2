# Static code generation
Although Emit can address the need for dynamic code generation at runtime, there are always some requirements that are more suitable for using static code generation techniques to solve (for example, the intermediate code generated may need to be used in an IDE), and in [AOT](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/12.NativeAOT/12.NativeAOT.Eng.md) environments where Emit cannot be used, static code generation techniques often need to be introduced to solve the problem.  
The static code generation of AutoCSer is not the official Source Generator solution of Microsoft, but an implementation based on a simple [custom template](https://github.com/AutoCSer/AutoCSer2/tree/main/AutoCSer/CodeGenerator/Template) engine **customized for the requirements of the AutoCSer framework**. The specific supported project is [AutoCSer.CodeGenerator.NET8.csproj](https://github.com/AutoCSer/AutoCSer2/tree/main/AutoCSer/CodeGenerator). It provides data sources for code templates by reading metadata information related to the target assembly, similar to the MV* template technology in WEB development.  
The feature of the AutoCSer static code generation component is that the **C# template code is also required to be compilable** (not text templates). The main code in the template, except for instructions, is basically regular code. Such template code can sense most of the refactoring operations of the dependent project and has good maintainability.  
To use the AutoCSer static code generation function, you need to click the **Event** option under the **Generate** menu of the VS project properties, and enter the following code in the **Post-Generate Event** input box (note that the real path of AutoCSer.CodeGenerator.exe needs to be modified according to different platform versions) :
``` text
if exist "C:\AutoCSer\CodeGenerator\bin\Release\net8.0\AutoCSer.CodeGenerator.exe" C:\AutoCSer\CodeGenerator\bin\Release\net8.0\AutoCSer.CodeGenerator.exe "$(ProjectName)" "$(ProjectDir) " "$(TargetPath) " "$(RootNamespace)"
```
![Project configuration for static code generation](CodeGenerator.png)
Essentially, when the assembly of the project is successfully generated, VS will trigger a post-generation event call to AutoCSer.CodeGenerator.exe to generate static code. Under normal circumstances, a C# code file named **{$(ProjectName)}.AutoCSer.cs** will be generated in the directory $(TargetPath). In non-IDE environments, you can manually invoke the command line to replace the environment variables with their actual values.  
If the code to be generated contains the XML document of the API, you need to click the **Output** option under the **Generate** menu and check the **Document File** option. In this way, the XML document file of the assembly will be generated.
# RPC
Due to the different thread scheduling requirements of the client and the server, the interface API definitions of the client and the server are also different. We can add [AutoCSer.Net.CommandServerControllerInterfaceAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerControllerInterfaceAttribute.cs) configuration to the [service interface](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/Service/IServiceController.cs), and in this way, the default [client interface API definition](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/%7BAutoCSer.Document.CodeGenerator%7D.AutoCSer.cs) can be generated.
``` csharp
    /// <summary>
    /// An example of generate the API definition of the client controller interface
    /// </summary>
    [AutoCSer.Net.CommandServerControllerInterface]
    public partial interface IServiceController
    {
        /// <summary>
        /// One-time response API example
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        int OneTimeResponse(int left, int right);
        /// <summary>
        /// Two-stage response API example
        /// </summary>
        /// <param name="callback">For the callback wrapper in the first stage, the type of the penultimate parameter must be AutoCSer.Net.CommandServerCallback{T}第一阶段的回调委托包装，倒数第二个参数类型必须是 AutoCSer.Net.CommandServerCallback{T}</param>
        /// <param name="keepCallback">For the callback delegate wrapper of the second stage of continuous response, the last parameter type must be AutoCSer.Net.CommandServerKeepCallback{T} or AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be void</returns>
        void TwoStageResponse(AutoCSer.Net.CommandServerCallback<string> callback, AutoCSer.Net.CommandServerKeepCallback<int> keepCallback);
    }
```
``` csharp
        /// <summary>
        /// An example of generate the API definition of the client controller interface 
        /// </summary>
        public partial interface IServiceControllerClientController
        {
            /// <summary>
            /// One-time response API example 
            /// </summary>
            /// <param name="left"></param>
            /// <param name="right"></param>
            /// <returns></returns>
            AutoCSer.Net.ReturnCommand<int> OneTimeResponse(int left, int right);
            /// <summary>
            /// Two-stage response API example 
            /// </summary>
            /// <param name="callback">For the callback wrapper in the first stage, the type of the penultimate parameter must be AutoCSer.Net.CommandServerCallback{T} </param>
            /// <param name="keepCallback">For the callback delegate wrapper of the second stage of continuous response, the last parameter type must be AutoCSer.Net.CommandServerKeepCallback{T} or AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
            /// <returns></returns>
            AutoCSer.Net.KeepCallbackCommand TwoStageResponse(Action<AutoCSer.Net.CommandClientReturnValue<string>> callback, Action<AutoCSer.Net.CommandClientReturnValue<int>, AutoCSer.Net.KeepCallbackCommand> keepCallback);
        }
```
The default return value of the client API generated by AutoCSer will **carry network interaction status information**. For developers who are accustomed to the API directly returning the required data type, they can override the property [AutoCSer.Net.CommandClientSocketEvent](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientSocketEvent/CommandClientSocketEvent.cs).IsCodeGeneratorReturnValueController in the derived class of the client socket event and set it to true to trigger the generation of this API encapsulation code.  
This feature requires that the derived type of the client socket event provide a constructor, which has exactly one parameter of type [AutoCSer.Net.CommandClient](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClient.cs). Of course, this is a regular operation in itself. The [sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/Service/CommandClientSocketEvent.cs) is as follows:
``` csharp
    /// <summary>
    /// Command client socket events
    /// </summary>
    internal sealed partial class CommandClientSocketEvent : AutoCSer.Net.CommandClientSocketEventTask<CommandClientSocketEvent>
    {
        /// <summary>
        /// Client interface example
        /// </summary>
        [AllowNull]
        public IServiceControllerClientController ServiceControllerClientController { get; private set; }
        /// <summary>
        /// The set of parameters for creating the client controller is used to create the client controller object during the initialization of the client socket, and also to automatically bind the controller properties based on the interface type of the client controller after the client socket passes the service authentication API
        /// </summary>
        public override IEnumerable<AutoCSer.Net.CommandClientControllerCreatorParameter> ControllerCreatorParameters
        {
            get
            {
                yield return new AutoCSer.Net.CommandClientControllerCreatorParameter(typeof(Service.IServiceController), typeof(IServiceControllerClientController));
            }
        }
        /// <summary>
        /// Generate the client controller encapsulation type for directly obtaining the return value
        /// </summary>
        public override bool IsCodeGeneratorReturnValueController { get { return true; } }
        /// <summary>
        /// Command client socket events
        /// </summary>
        /// <param name="client">Command client</param>
        public CommandClientSocketEvent(AutoCSer.Net.CommandClient client) : base(client) { }
    }
```
The generated API encapsulation code is as follows:
``` csharp
    /// <summary>
    /// Command client socket events 
    /// </summary>
    internal partial class CommandClientSocketEvent
    {
        /// <summary>
        /// Client interface example (Direct return value API encapsulation)
        /// </summary>
        public sealed class ServiceControllerClientControllerReturnValueController
        {
            /// <summary>
            /// Command client socket event
            /// </summary>
            private readonly AutoCSer.Document.NativeAOT.Service.CommandClientSocketEvent __client__;
            /// <summary>
            /// Whether errors and exceptions are ignored
            /// </summary>
            private readonly bool __isIgnoreError__;
            /// <summary>
            /// Client interface example (Direct return value API encapsulation)
            /// </summary>
            /// <param name="client">Command client socket event</param>
            /// <param name="isIgnoreError">Whether errors and exceptions are ignored</param>
            public ServiceControllerClientControllerReturnValueController(AutoCSer.Document.NativeAOT.Service.CommandClientSocketEvent client, bool isIgnoreError = false)
            {
                __client__ = client;
                __isIgnoreError__ = isIgnoreError;
            }
            /// <summary>
            /// One-time response API example  
            /// </summary>
            /// <param name="left"></param>
            /// <param name="right"></param>
            /// <returns></returns>
            [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            public AutoCSer.Net.CommandServer.CommandReturnValue<int> OneTimeResponse(int left, int right)
            {
                
                return this.__client__.ServiceControllerClientController/**/.OneTimeResponse(left, right).GetValue(__isIgnoreError__);
            }
            /// <summary>
            /// Two-stage response API example  
            /// </summary>
            /// <returns></returns>
            [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            public AutoCSer.Net.KeepCallbackCommand TwoStageResponse(System.Action<string> callback, System.Action<int> keepCallback)
            {
                return this.__client__.ServiceControllerClientController/**/.TwoStageResponse(new AutoCSer.Net.CommandServer.ClientReturnValueCallback<string>(callback), new AutoCSer.Net.CommandServer.ClientReturnValueCallback<int>(keepCallback));
            }
            /// <summary>
            /// Two-stage response API example  
            /// </summary>
            /// <returns></returns>
            [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            public AutoCSer.Net.KeepCallbackCommand TwoStageResponse(System.Action<string> callback, Action<AutoCSer.Net.CommandClientReturnValue> error_callback, System.Action<int> keepCallback, Action<AutoCSer.Net.CommandClientReturnValue> error_keepCallback)
            {
                return this.__client__.ServiceControllerClientController/**/.TwoStageResponse(new AutoCSer.Net.CommandServer.ClientReturnValueCallback<string>(callback, error_callback), new AutoCSer.Net.CommandServer.ClientReturnValueCallback<int>(keepCallback, error_keepCallback));
            }
        }
        /// <summary>
        /// Get the direct return value API encapsulation (ServiceControllerClientController)
        /// </summary>
        /// <param name="isIgnoreError">Whether errors and exceptions are ignored</param>
        /// <returns>Client interface example (Direct return value API encapsulation)</returns>
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public ServiceControllerClientControllerReturnValueController GetServiceControllerClientControllerReturnValueController(bool isIgnoreError = false) { return new ServiceControllerClientControllerReturnValueController(this, isIgnoreError); }
    }
```
Since the callback operation that directly returns the required data type **cannot throw an Exception**, the callback delegate parameters are split into **normal callback** and **error callback** parameters for handling. At the same time, an API without error callback parameters will be generated for scenarios where error messages can be ignored.
# In-memory database
The server of the in-memory database node only supports the synchronous scheduling mode of queue threads, while the client only supports the await asynchronous scheduling mode. Therefore, the API definitions of the node interface between the client and the server are different. It is necessary to add [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Server/ServerNodeAttribute.cs) configuration to the [server node interface](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/MemoryDatabase/IServerNode.cs), so that the default API definition of the client node interface can be generated.
``` csharp
    /// <summary>
    /// An example of generate the API definition of the client node interface
    /// </summary>
    [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode]
    public partial interface IServerNode
    {
        /// <summary>
        /// Test API
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        int Add(int left, int right);
    }
```
``` csharp
        /// <summary>
        /// An example of generate the API definition of the client node interface 
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.Document.CodeGenerator.MemoryDatabase.IServerNode))]
        public partial interface IServerNodeClientNode
        {
            /// <summary>
            /// Test API
            /// </summary>
            /// <param name="left"></param>
            /// <param name="right"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> Add(int left, int right);
        }
```
The [local embedding mode](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/MemoryDatabase/ILocalNode.cs) requires **setting IsLocalClient to true** for the local client node interface API definition to be generated.
``` csharp
    /// <summary>
    /// An example of generate the API definition of the local client node interface
    /// </summary>
    [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNode(IsLocalClient = true, IsClient = false)]
    public partial interface ILocalNode
    {
        /// <summary>
        /// Test API
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        int Add(int left, int right);
    }
```
``` csharp
        /// <summary>
        /// An example of generate the API definition of the local client node interface 
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.Document.CodeGenerator.MemoryDatabase.ILocalNode))]
        public partial interface ILocalNodeLocalClientNode
        {
            /// <summary>
            /// Test API
            /// </summary>
            /// <param name="left"></param>
            /// <param name="right"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> Add(int left, int right);
        }
```
# [Introduction to in-memory database](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/06.MemoryDatabase/06.MemoryDatabase.Eng.md)