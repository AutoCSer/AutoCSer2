# 内存数据库 - 内置数据结构节点
AutoCSer 内存数据库内置支持一些简单的常用数据结构，主要包括字典、消息、分布式锁、平衡二叉树、哈希表、哈希过滤、队列、栈、位图、数组、仅存档数据以及 AutoCSer 运维工具组件等，也可作为[自定义节点](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/08.MemoryDatabaseCustomNode.md)的参考示例。
# 服务端
AutoCSer 内存数据库服务是基于 AutoCSer RPC 实现的服务控制器，所以创建内存数据库服务就是创建一个具有内存数据库服务控制器实例的 RPC 服务。
## 1. 配置定义
在默认配置类型 [AutoCSer.CommandService.StreamPersistenceMemoryDatabaseServiceConfig](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Server/StreamPersistenceMemoryDatabaseServiceConfig.cs) 不满足需求的情况下，我们需要从它派生一个子类用于[自定义配置](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Server/ServiceConfig.cs)。
``` csharp
    /// <summary>
    /// 日志流持久化内存数据库服务配置
    /// </summary>
    internal sealed class ServiceConfig : AutoCSer.CommandService.StreamPersistenceMemoryDatabaseServiceConfig
    {
        /// <summary>
        /// 测试环境删除 15 分钟以前的历史持久化文件，生产环境根据实际需求处理
        /// </summary>
        /// <returns></returns>
        public override DateTime GetRemoveHistoryFileTime()
        {
            return AutoCSer.Threading.SecondTimer.UtcNow.AddMinutes(-15);
        }
        /// <summary>
        /// 测试环境每分钟执行一次删除历史持久化文件操作，生产环境根据实际需求处理
        /// </summary>
        /// <param name="service"></param>
        /// <returns></returns>
        public override void RemoveHistoryFile(AutoCSer.CommandService.StreamPersistenceMemoryDatabaseService service)
        {
            new AutoCSer.CommandService.StreamPersistenceMemoryDatabase.RemoveHistoryFile(service).Remove(new AutoCSer.Threading.TaskRunTimer(60.0)).Catch();
        }
        /// <summary>
        /// 重建文件大小设置为至少 10MB
        /// </summary>
        /// <param name="service"></param>
        /// <returns></returns>
        public override bool CheckRebuild(AutoCSer.CommandService.StreamPersistenceMemoryDatabaseService service)
        {
            long persistencePosition = service.GetPersistencePosition();
            return (persistencePosition >> 1) >= service.RebuildSnapshotPosition && persistencePosition > 10 << 20;
        }
    }
```
## 2. 创建实例
[调用内存数据库配置类型的 Create 方法](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Program.cs)创建[内存数据库服务](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Server/StreamPersistenceMemoryDatabaseService.cs)控制器实例。
``` csharp
            AutoCSer.Document.MemoryDatabaseNode.Server.ServiceConfig databaseServiceConfig = new AutoCSer.Document.MemoryDatabaseNode.Server.ServiceConfig
            {
                PersistencePath = Path.Combine(AutoCSer.TestCase.Common.Config.AutoCSerTemporaryFilePath, nameof(AutoCSer.Document.MemoryDatabaseNode)),
                PersistenceSwitchPath = Path.Combine(AutoCSer.TestCase.Common.Config.AutoCSerTemporaryFilePath, nameof(AutoCSer.Document.MemoryDatabaseNode) + nameof(AutoCSer.Document.MemoryDatabaseNode.Server.ServiceConfig.PersistenceSwitchPath))
            };
            AutoCSer.CommandService.StreamPersistenceMemoryDatabaseService databaseService = databaseServiceConfig.Create();
```
## 3. 创建 RPC 服务端监听
内存数据库的默认服务控制器接口类型为 [AutoCSer.CommandService.IStreamPersistenceMemoryDatabaseService](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Server/IStreamPersistenceMemoryDatabaseService.cs)，支持多线程并发读操作的服务控制器接口类型为 [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IReadWriteQueueService](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Server/IReadWriteQueueService.cs)。  
[示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Program.cs)中没有定义[服务认证 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/04.ServiceAuthentication/04.ServiceAuthentication.md)，生产环境需要增加服务认证 API 以防止非法客户端访问。
``` csharp
            AutoCSer.Net.CommandServerConfig commandServerConfig = new AutoCSer.Net.CommandServerConfig
            {
                Host = new AutoCSer.Net.HostEndPoint((ushort)AutoCSer.TestCase.Common.CommandServerPortEnum.Document),
            };
            await using (AutoCSer.Net.CommandListener commandListener = new AutoCSer.Net.CommandListenerBuilder(0)
                .Append<AutoCSer.CommandService.IStreamPersistenceMemoryDatabaseService>(databaseService)
                //.Append<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IReadWriteQueueService>(databaseService)
                .CreateCommandListener(commandServerConfig))
            {
                if (await commandListener.Start())
                {
                    await Client.CommandClientSocketEvent.Test();

                    Console.WriteLine("Completed");
                    Console.ReadKey();
                }
            }
```
# 客户端
AutoCSer 内存数据库客户端是一个 RPC 客户端控制器实例。
## 1. 定义 RPC 客户端实例
RPC 的[客户端控制器实例](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/CommandClientSocketEvent.cs)在 [AutoCSer.Net.CommandClientSocketEvent](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientSocketEvent/CommandClientSocketEvent.cs) 的派生类中定义，内存数据库客户端需要实现接口 [AutoCSer.CommandService.IStreamPersistenceMemoryDatabaseClientSocketEvent](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Client/IStreamPersistenceMemoryDatabaseClientSocketEvent.cs)。
``` csharp
    /// <summary>
    /// RPC 客户端实例
    /// </summary>
    internal sealed class CommandClientSocketEvent : AutoCSer.Net.CommandClientSocketEventTask<CommandClientSocketEvent>, AutoCSer.CommandService.IStreamPersistenceMemoryDatabaseClientSocketEvent
    {
        /// <summary>
        /// 内存数据库客户端接口实例
        /// </summary>
        [AllowNull]
        public AutoCSer.CommandService.IStreamPersistenceMemoryDatabaseClient StreamPersistenceMemoryDatabaseClient { get; private set; }
        /// <summary>
        /// 客户端控制器创建参数集合，用于命令客户端套接字初始化是创建客户端控制器对象，同时也用于命令客户端套接字事件在通过认证 API 之后根据客户端控制器接口类型自动绑定控制器属性
        /// </summary>
        public override IEnumerable<AutoCSer.Net.CommandClientControllerCreatorParameter> ControllerCreatorParameters
        {
            get
            {
                yield return new AutoCSer.Net.CommandClientControllerCreatorParameter(typeof(AutoCSer.CommandService.IStreamPersistenceMemoryDatabaseService), typeof(AutoCSer.CommandService.IStreamPersistenceMemoryDatabaseClient));
                //yield return new AutoCSer.Net.CommandClientControllerCreatorParameter(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IReadWriteQueueService), typeof(AutoCSer.CommandService.IStreamPersistenceMemoryDatabaseClient));
            }
        }
        /// <summary>
        /// RPC 客户端实例
        /// </summary>
        /// <param name="client">命令客户端</param>
        public CommandClientSocketEvent(AutoCSer.Net.CommandClient client) : base(client) { }
    }
```
## 2. 创建 RPC 客户端
和普通 AutoCSer RPC 客户端一样，内存数据库的客户端在实战中应该采用单例模式。
``` csharp
        /// <summary>
        /// 内存数据库客户端单例
        /// </summary>
        public static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientCache<CommandClientSocketEvent> StreamPersistenceMemoryDatabaseClientCache = new AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientCache<CommandClientSocketEvent>(new AutoCSer.Net.CommandClientConfig
        {
            Host = new AutoCSer.Net.HostEndPoint((ushort)AutoCSer.TestCase.Common.CommandServerPortEnum.Document),
            GetSocketEventDelegate = (client) => new CommandClientSocketEvent(client)
        });
```
# 内置数据结构节点
由于创建节点与获取节点的调用开销比较大，可以类比于传统关系数据库创建表格的操作，所以应该尽量减少调用相关 API 的操作，可以使用内置提供的[客户端节点缓存单例的封装类型](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Client/StreamPersistenceMemoryDatabaseClientNodeCache.cs)来获取客户端节点。
## 1. Key-Value 字典
字典是最常用的数据结构，针对不同场景与性能需求 AutoCSer 内置了 3 种不同序列化策略的字典节点。  
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDictionaryNode<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IDictionaryNode.cs) 是对字典的服务端**泛型封装**（后面提到泛型封装都是指服务端泛型封装），KT 必须实现 IEquatable<KT> 接口，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/DictionaryNode.cs)如下：
``` csharp
    /// <summary>
    /// 泛型字典客户端节点示例
    /// </summary>
    internal static class DictionaryNode
    {
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDictionaryNodeClientNode<string, string>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateDictionaryNode<string, string>(nameof(DictionaryNode)));
        /// <summary>
        /// 泛型字典客户端节点示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDictionaryNodeClientNode<string, string> node = nodeResult.Value.notNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var boolResult = await node.Set("3A", "AAA");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var valueResult = await node.TryGetValue("3A");
            if (!valueResult.IsSuccess || valueResult.Value.Value != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            valueResult = await node.TryGetValue("3B");
            if (!valueResult.IsSuccess || valueResult.Value.IsValue)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Remove("3A");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayDictionaryNode<KT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IByteArrayDictionaryNode.cs) 是对字典关键字的**泛型封装**，KT 必须实现 IEquatable<KT> 接口，Value 则采用服务端字节数组封装 [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/ServerByteArray.cs)。  
服务端字节数组封装默认支持 4 种客户端传参模式，分别是 byte[]、string、JSON 混杂二进制序列化、二进制序列化，不同的传参模式需要调用不同的 API 分别处理，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/ByteArrayDictionaryNode.cs)如下：
``` csharp
    /// <summary>
    /// 字典节点客户端示例
    /// </summary>
    internal static class ByteArrayDictionaryNode
    {
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayDictionaryNodeClientNode<string>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateByteArrayDictionaryNode<string>(nameof(ByteArrayDictionaryNode)));
        /// <summary>
        /// 字典节点客户端示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayDictionaryNodeClientNode<string> node = nodeResult.Value.notNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            #region byte[]
            byte[] data = new byte[] { 1, 2, 3, 4 };
            //byte[] 支持隐式转换为 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray
            var boolResult = await node.Set("ByteArray", data);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            //获取 byte[] 使用 TryGetValue 方法
            var dataResult = await node.TryGetValue("ByteArray");
            if (!dataResult.IsSuccess || !AutoCSer.Common.SequenceEqual(data, dataResult.Value.Value))
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            #region string
            //string 支持隐式转换为 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray 本质是二进制序列化为 byte[]
            boolResult = await node.Set("String", "AAA");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            //获取 string 使用 TryGetString 扩展方法
            var stringResult = await node.TryGetString("String");
            if (!stringResult.IsSuccess || stringResult.Value != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            #region JSON mixed binary serialization
            Data.TestClass testData = new Data.TestClass { Int = 1, String = "AAA" };
            boolResult = await node.Set("JsonSerialize", AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.JsonSerialize(testData));
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            //获取 JSON 混杂二进制反序列化对象使用 TryGetJsonDeserialize 扩展方法
            var classResult = await node.TryGetJsonDeserialize<string, Data.TestClass>("JsonSerialize");
            if (!classResult.IsSuccess || classResult.Value?.String != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            #region Binary serialization
            boolResult = await node.Set("BinarySerialize", AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.BinarySerialize(testData));
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            //获取二进制反序列化对象使用 TryGetBinaryDeserialize 扩展方法
            classResult = await node.TryGetBinaryDeserialize<string, Data.TestClass>("BinarySerialize");
            if (!classResult.IsSuccess || classResult.Value?.String != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            return true;
        }
    }
```
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashBytesDictionaryNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IHashBytesDictionaryNode.cs) 的 Key 与 Value 都采用服务端字节数组封装，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/HashBytesDictionaryNode.cs)如下：
``` csharp
    /// <summary>
    /// 字典节点客户端示例
    /// </summary>
    internal static class HashBytesDictionaryNode
    {
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashBytesDictionaryNodeClientNode> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateHashBytesDictionaryNode(nameof(HashBytesDictionaryNode)));
        /// <summary>
        /// 字典节点客户端示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashBytesDictionaryNodeClientNode node = nodeResult.Value.notNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            #region Keyword JSON serialization
            Data.TestClass keyData = new Data.TestClass { Int = 1, String = "3A" };
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray jsonKey = AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.JsonSerialize(keyData);
            var boolResult = await node.Set(jsonKey, "AAA");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var stringResult = await node.TryGetString(jsonKey);
            if (!stringResult.IsSuccess || stringResult.Value != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            #region Keyword binary serialization
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray binarySerializeKey = AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.BinarySerialize(keyData);
            boolResult = await node.Set(binarySerializeKey, "AAA");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            stringResult = await node.TryGetString(binarySerializeKey);
            if (!stringResult.IsSuccess || stringResult.Value != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            return true;
        }
    }
```
数据结构节点的客户端接口默认是根据服务端节点接口定义，使用 AutoCSer 的[静态代码生成](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/05.CodeGenerator.md)工具生成的，客户端接口类型名称默认是在服务端接口类型名称之后增加 **ClientNode 后缀**，比如服务端节点接口类型 [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDictionaryNode<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IDictionaryNode.cs) 对应的客户端节点接口类型是 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDictionaryNode**ClientNode**<KT, VT>。
### 1.1 泛型封装
使用泛型封装的前提是服务端包含并且加载了具体的数据类型，这就需要服务端引用相关数据类型定义的程序集，并且可能需要在服务启动之前**显式触发加载这些程序集与类型信息**。  
泛型封装类型的实例对象默认采用二进制序列化，服务端内存数据保存的是**具体对象的实例**，不适合处理定义复杂的引用类型，因为可能会产生多个引用类型对象从而对 GC 造成更大压力。  
一般来说，没有引用类型成员的值类型或者简单的引用类型都应该采用泛型封装，这样可以在**性能与内存空间占用**上获取最佳效果，比如 int、long、string、enum 或者没有引用类型成员的 struct 等。
### 1.2 服务端字节数组封装
使用服务端字节数组封装，**序列化与反序列化操作都由客户端决定**，并且相关操作都在客户端进行，服务端没有业务数据类型概念**只处理 byte[] 数据**，本质上和 Redis 服务端只处理字节序列是一样的。  
一般来说，服务端字节数组封装的问题在于很**容易造成占用过多的服务端内存**，因为 byte[] 一般都是数据对象的序列化数据，比如 JSON 序列化数据与内存对象数据的空间占用甚至可能相差一个数量级。
## 2. 分片字典
我们知道基于单个数组实现的集合类型，在数组空间不足的情况下是需要扩容操作的，而扩容操作一般都是申请一个大概 2 倍空间的新数组并写入旧数据。在数据量较大的情况下，**一旦触发扩容操作就会产生较长的 CPU 占用时间**，这个操作会严重影响 API 的延时与吞吐性能。  
很多数据结构的扩容操作都存在这个问题，比如上面介绍的 Key-Value 字典也存在这个问题，在有效数据的数量上限确定的情况下我们可以通过设置构造函数的 capacity 参数来避免扩容操作的产生。  
但是在绝大多数场景中我们并不知道这个上限值，扩容操作基本是无法避免的，所以 AutoCSer 对字典进行了一种简单的数组封装。它会申请一个 256 长度的字典数组，在哈希值随机化的环境中每个字典对象的数据量会**降到整体数据量的 1/256 左右**，可以大幅降低单次扩容操作的延时并稳定吞吐性能。  
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IFragmentDictionaryNode<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IFragmentDictionaryNode.cs) 是对分片字典的**泛型封装**，KT 必须实现 IEquatable<KT> 接口，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/FragmentDictionaryNode.cs)如下：
``` csharp
    /// <summary>
    /// 泛型字典客户端节点示例
    /// </summary>
    internal static class FragmentDictionaryNode
    {
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IFragmentDictionaryNodeClientNode<string, string>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateFragmentDictionaryNode<string, string>(nameof(FragmentDictionaryNode)));
        /// <summary>
        /// 泛型字典客户端节点示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IFragmentDictionaryNodeClientNode<string, string> node = nodeResult.Value.notNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var boolResult = await node.Set("3A", "AAA");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var valueResult = await node.TryGetValue("3A");
            if (!valueResult.IsSuccess || valueResult.Value.Value != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            valueResult = await node.TryGetValue("3B");
            if (!valueResult.IsSuccess || valueResult.Value.IsValue)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Remove("3A");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayFragmentDictionaryNode<KT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IByteArrayFragmentDictionaryNode.cs) 是对分片字典关键字的**泛型封装**，KT 必须实现 IEquatable<KT> 接口，Value 则采用服务端字节数组封装，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/ByteArrayFragmentDictionaryNode.cs)如下：
``` csharp
    /// <summary>
    /// 字典节点客户端示例
    /// </summary>
    internal static class ByteArrayFragmentDictionaryNode
    {
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayFragmentDictionaryNodeClientNode<string>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateByteArrayFragmentDictionaryNode<string>(nameof(ByteArrayFragmentDictionaryNode)));
        /// <summary>
        /// 字典节点客户端示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayFragmentDictionaryNodeClientNode<string> node = nodeResult.Value.notNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            #region byte[]
            byte[] data = new byte[] { 1, 2, 3, 4 };
            //byte[] 支持隐式转换为 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray
            var boolResult = await node.Set("ByteArray", data);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            //获取 byte[] 使用 TryGetValue 方法
            var dataResult = await node.TryGetValue("ByteArray");
            if (!dataResult.IsSuccess || !AutoCSer.Common.SequenceEqual(data, dataResult.Value.Value))
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            #region string
            //string 支持隐式转换为 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray 本质是二进制序列化为 byte[]
            boolResult = await node.Set("String", "AAA");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            //获取 string 使用 TryGetString 扩展方法
            var stringResult = await node.TryGetString("String");
            if (!stringResult.IsSuccess || stringResult.Value != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            #region JSON mixed binary serialization
            Data.TestClass testData = new Data.TestClass { Int = 1, String = "AAA" };
            boolResult = await node.Set("JsonSerialize", AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.JsonSerialize(testData));
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            //获取 JSON 混杂二进制反序列化对象使用 TryGetJsonDeserialize 扩展方法
            var classResult = await node.TryGetJsonDeserialize<string, Data.TestClass>("JsonSerialize");
            if (!classResult.IsSuccess || classResult.Value?.String != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            #region Binary serialization
            boolResult = await node.Set("BinarySerialize", AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.BinarySerialize(testData));
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            //获取二进制反序列化对象使用 TryGetBinaryDeserialize 扩展方法
            classResult = await node.TryGetBinaryDeserialize<string, Data.TestClass>("BinarySerialize");
            if (!classResult.IsSuccess || classResult.Value?.String != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            return true;
        }
    }
```
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashBytesFragmentDictionaryNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IHashBytesFragmentDictionaryNode.cs) 的 Key 与 Value 都采用服务端字节数组封装，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/HashBytesFragmentDictionaryNode.cs)如下：
``` csharp
    /// <summary>
    /// 字典节点客户端示例
    /// </summary>
    internal static class HashBytesFragmentDictionaryNode
    {
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashBytesFragmentDictionaryNodeClientNode> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateHashBytesFragmentDictionaryNode(nameof(HashBytesFragmentDictionaryNode)));
        /// <summary>
        /// 字典节点客户端示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashBytesFragmentDictionaryNodeClientNode node = nodeResult.Value.notNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            #region Keyword JSON serialization
            Data.TestClass keyData = new Data.TestClass { Int = 1, String = "3A" };
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray jsonKey = AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.JsonSerialize(keyData);
            var boolResult = await node.Set(jsonKey, "AAA");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var stringResult = await node.TryGetString(jsonKey);
            if (!stringResult.IsSuccess || stringResult.Value != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            #region Keyword binary serialization
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray binarySerializeKey = AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.BinarySerialize(keyData);
            boolResult = await node.Set(binarySerializeKey, "AAA");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            stringResult = await node.TryGetString(binarySerializeKey);
            if (!stringResult.IsSuccess || stringResult.Value != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            return true;
        }
    }
```
## 3. 消息
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/IMessageNode.cs) 是消息节点接口类型，根据不同的消息数据类型需求内置提供了 5 种客户端消费者的封装。  
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.BinaryMessageConsumer<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/BinaryMessageConsumer.cs) 是服务端泛型消息的封装，客户端可以使用委托模式 [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.OnBinaryMessageConsumer<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/OnBinaryMessageConsumer.cs) 替代方法 onMessage 的重载，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/Message/BinaryMessageConsumer.cs)如下：
``` csharp
    /// <summary>
    /// 服务端泛型消息客户端消费者示例
    /// </summary>
    internal sealed class BinaryMessageConsumer : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.BinaryMessageConsumer<Data.TestClass>
    {
        /// <summary>
        /// 服务端泛型消息客户端消费者示例
        /// </summary>
        /// <param name="commandClient">Command client</param>
        /// <param name="node">二进制序列化消息消息客户端节点</param>
        internal BinaryMessageConsumer(AutoCSer.Net.CommandClient commandClient, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.BinaryMessage<Data.TestClass>> node) : base(commandClient, node, 1 << 10) { }
        /// <summary>
        /// 消息处理，异常也表示消息执行失败
        /// </summary>
        /// <param name="message"></param>
        /// <returns>消息是否执行成功</returns>
        protected override Task<bool> onMessage(Data.TestClass message)
        {
            lock (messageLock) messages.Remove(message.Int);
            return AutoCSer.Common.GetCompletedTask(true);
        }

        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.BinaryMessage<Data.TestClass>>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateBinaryMessageNode<Data.TestClass>(nameof(BinaryMessageConsumer)));
        /// <summary>
        /// 未完成消息集合
        /// </summary>
        private static Dictionary<int, Data.TestClass> messages = new Dictionary<int, Data.TestClass>();
        /// <summary>
        /// 消费消息测试访问锁
        /// </summary>
        private static readonly object messageLock = new object();
        /// <summary>
        /// 服务端泛型消息客户端消费者示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.BinaryMessage<Data.TestClass>> node = nodeResult.Value.notNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            messages.Clear();
            for (char message = 'A'; message <= 'Z'; ++message)
            {
                Data.TestClass messageData = new Data.TestClass { Int = message, String = message.ToString() };
                messages.Add(message, messageData);

                result = await node.AppendMessage(messageData);
                if (!result.IsSuccess)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
            }

            using (BinaryMessageConsumer consumer = new BinaryMessageConsumer(CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.ClientCache.Client, node))
            {
                #region Wait for the test message to complete
                long timeout = Stopwatch.GetTimestamp() + AutoCSer.Date.GetTimestampBySeconds(10);
                while (messages.Count != 0)
                {
                    if (timeout < Stopwatch.GetTimestamp())
                    {
                        return AutoCSer.Breakpoint.ReturnFalse();
                    }
                    await Task.Delay(1);
                }
                #endregion
            }

            return true;
        }
    }
```
服务端非泛型消息都是对 [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/ServerByteArrayMessage.cs) 消息类型的封装，服务端处理的消息数据是 byte[]，序列化与反序列化操作由客户端处理。  
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessageConsumer<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/ServerByteArrayMessageConsumer.cs) 是客户端二进制序列化消息的封装，[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.OnServerByteArrayMessageConsumer<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/OnServerByteArrayMessageConsumer.cs) 是使用委托替代方法 onMessage 的重载的封装，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/Message/ServerByteArrayBinaryMessageConsumer.cs)如下：
``` csharp
    /// <summary>
    /// 客户端二进制序列化消息客户端消费者示例
    /// </summary>
    internal sealed class ServerByteArrayBinaryMessageConsumer : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessageConsumer<Data.TestClass>
    {
        /// <summary>
        /// 客户端二进制序列化消息客户端消费者示例
        /// </summary>
        /// <param name="commandClient">Command client</param>
        /// <param name="node">服务端字节数组消息客户端节点</param>
        internal ServerByteArrayBinaryMessageConsumer(AutoCSer.Net.CommandClient commandClient, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage> node) : base(commandClient, node, 1 << 10) { }
        /// <summary>
        /// 消息处理，异常也表示消息执行失败
        /// </summary>
        /// <param name="message"></param>
        /// <returns>消息是否执行成功</returns>
        protected override Task<bool> onMessage(Data.TestClass? message)
        {
            lock (messageLock) messages.Remove(message.notNull().Int);
            return AutoCSer.Common.GetCompletedTask(true);
        }

        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateServerByteArrayMessageNode(nameof(ServerByteArrayBinaryMessageConsumer)));
        /// <summary>
        /// 未完成消息集合
        /// </summary>
        private static Dictionary<int, Data.TestClass> messages = new Dictionary<int, Data.TestClass>();
        /// <summary>
        /// 消费消息测试访问锁
        /// </summary>
        private static readonly object messageLock = new object();
        /// <summary>
        /// 客户端二进制序列化消息客户端消费者示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage> node = nodeResult.Value.notNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            messages.Clear();
            for (char message = 'A'; message <= 'Z'; ++message)
            {
                Data.TestClass messageData = new Data.TestClass { Int = message, String = message.ToString() };
                messages.Add(message, messageData);

                result = await node.AppendMessage(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage.BinarySerialize(messageData));
                if (!result.IsSuccess)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
            }

            using (ServerByteArrayBinaryMessageConsumer consumer = new ServerByteArrayBinaryMessageConsumer(CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.ClientCache.Client, node))
            {
                #region Wait for the test message to complete
                long timeout = Stopwatch.GetTimestamp() + AutoCSer.Date.GetTimestampBySeconds(10);
                while (messages.Count != 0)
                {
                    if (timeout < Stopwatch.GetTimestamp())
                    {
                        return AutoCSer.Breakpoint.ReturnFalse();
                    }
                    await Task.Delay(1);
                }
                #endregion
            }

            return true;
        }
    }
```
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessageJsonConsumer<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/ServerByteArrayMessageJsonConsumer.cs) 是客户端 JSON 混杂二进制序列化消息的封装，[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.OnServerByteArrayMessageJsonConsumer<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/OnServerByteArrayMessageJsonConsumer.cs) 是使用委托替代方法 onMessage 的重载的封装，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/Message/ServerByteArrayMessageJsonConsumer.cs)如下：
``` csharp
    /// <summary>
    /// 客户端 JSON 混杂二进制消息客户端消费者示例
    /// </summary>
    internal sealed class ServerByteArrayMessageJsonConsumer : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessageJsonConsumer<Data.TestClass>
    {
        /// <summary>
        /// 客户端 JSON 混杂二进制消息客户端消费者示例
        /// </summary>
        /// <param name="commandClient">Command client</param>
        /// <param name="node">服务端字节数组消息客户端节点</param>
        internal ServerByteArrayMessageJsonConsumer(AutoCSer.Net.CommandClient commandClient, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage> node) : base(commandClient, node, 1 << 10) { }
        /// <summary>
        /// 消息处理，异常也表示消息执行失败
        /// </summary>
        /// <param name="message"></param>
        /// <returns>消息是否执行成功</returns>
        protected override Task<bool> onMessage(Data.TestClass? message)
        {
            lock (messageLock) messages.Remove(message.notNull().Int);
            return AutoCSer.Common.GetCompletedTask(true);
        }

        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateServerByteArrayMessageNode(nameof(ServerByteArrayMessageJsonConsumer)));
        /// <summary>
        /// 未完成消息集合
        /// </summary>
        private static Dictionary<int, Data.TestClass> messages = new Dictionary<int, Data.TestClass>();
        /// <summary>
        /// 消费消息测试访问锁
        /// </summary>
        private static readonly object messageLock = new object();
        /// <summary>
        /// 客户端 JSON 混杂二进制消息客户端消费者示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage> node = nodeResult.Value.notNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            messages.Clear();
            for (char message = 'A'; message <= 'Z'; ++message)
            {
                Data.TestClass messageData = new Data.TestClass { Int = message, String = message.ToString() };
                messages.Add(message, messageData);

                result = await node.AppendMessage(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage.JsonSerialize(messageData));
                if (!result.IsSuccess)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
            }

            using (ServerByteArrayMessageJsonConsumer consumer = new ServerByteArrayMessageJsonConsumer(CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.ClientCache.Client, node))
            {
                #region Wait for the test message to complete
                long timeout = Stopwatch.GetTimestamp() + AutoCSer.Date.GetTimestampBySeconds(10);
                while (messages.Count != 0)
                {
                    if (timeout < Stopwatch.GetTimestamp())
                    {
                        return AutoCSer.Breakpoint.ReturnFalse();
                    }
                    await Task.Delay(1);
                }
                #endregion
            }

            return true;
        }
    }
```
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessageStringConsumer](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/ServerByteArrayMessageStringConsumer.cs) 是客户端 string 消息的封装，[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.OnServerByteArrayMessageStringConsumer](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/OnServerByteArrayMessageStringConsumer.cs) 是使用委托替代方法 onMessage 的重载的封装，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/Message/ServerByteArrayMessageStringConsumer.cs)如下：
``` csharp
    /// <summary>
    /// 客户端 string 二进制序列化消息客户端消费者示例
    /// </summary>
    internal sealed class ServerByteArrayMessageStringConsumer : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessageStringConsumer
    {
        /// <summary>
        /// 客户端 string 二进制序列化消息客户端消费者示例
        /// </summary>
        /// <param name="commandClient">Command client</param>
        /// <param name="node">服务端字节数组消息客户端节点</param>
        internal ServerByteArrayMessageStringConsumer(AutoCSer.Net.CommandClient commandClient, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage> node) : base(commandClient, node, 1 << 10) { }
        /// <summary>
        /// 消息处理，异常也表示消息执行失败
        /// </summary>
        /// <param name="message"></param>
        /// <returns>消息是否执行成功</returns>
        protected override Task<bool> onMessage(string? message)
        {
            lock (messageLock) messages.Remove(message.notNull());
            return AutoCSer.Common.GetCompletedTask(true);
        }

        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateServerByteArrayMessageNode(nameof(ServerByteArrayMessageStringConsumer)));
        /// <summary>
        /// 未完成消息集合
        /// </summary>
        private static HashSet<string> messages = new HashSet<string>();
        /// <summary>
        /// 消费消息测试访问锁
        /// </summary>
        private static readonly object messageLock = new object();
        /// <summary>
        /// 客户端 string 二进制序列化消息客户端消费者示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage> node = nodeResult.Value.notNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            messages.Clear();
            for (char message = 'A'; message <= 'Z'; ++message)
            {
                string messageData = message.ToString();
                messages.Add(messageData);

                result = await node.AppendMessage(messageData);
                if (!result.IsSuccess)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
            }

            using (ServerByteArrayMessageStringConsumer consumer = new ServerByteArrayMessageStringConsumer(CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.ClientCache.Client, node))
            {
                #region Wait for the test message to complete
                long timeout = Stopwatch.GetTimestamp() + AutoCSer.Date.GetTimestampBySeconds(10);
                while (messages.Count != 0)
                {
                    if (timeout < Stopwatch.GetTimestamp())
                    {
                        return AutoCSer.Breakpoint.ReturnFalse();
                    }
                    await Task.Delay(1);
                }
                #endregion
            }

            return true;
        }
    }
```
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessageConsumer](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/ServerByteArrayMessageConsumer.cs) 是 byte[] 消息的封装，[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.OnServerByteArrayMessageConsumer](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/OnServerByteArrayMessageConsumer.cs) 是使用委托替代方法 onMessage 的重载的封装，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/Message/ServerByteArrayMessageStringConsumer.cs)如下：
``` csharp
    /// <summary>
    /// byte[] 消息客户端消费者示例
    /// </summary>
    internal sealed class ServerByteArrayMessageConsumer : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessageConsumer
    {
        /// <summary>
        /// byte[] 消息客户端消费者示例
        /// </summary>
        /// <param name="commandClient">Command client</param>
        /// <param name="node">服务端字节数组消息客户端节点</param>
        internal ServerByteArrayMessageConsumer(AutoCSer.Net.CommandClient commandClient, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage> node) : base(commandClient, node, 1 << 10) { }
        /// <summary>
        /// 消息处理，异常也表示消息执行失败
        /// </summary>
        /// <param name="message"></param>
        /// <returns>消息是否执行成功</returns>
        protected override Task<bool> onMessage(byte[]? message)
        {
            lock (messageLock) messages.Remove(message.notNull()[0]);
            return AutoCSer.Common.GetCompletedTask(true);
        }

        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateServerByteArrayMessageNode(nameof(ServerByteArrayMessageConsumer)));
        /// <summary>
        /// 未完成消息集合
        /// </summary>
        private static Dictionary<int, byte[]> messages = new Dictionary<int, byte[]>();
        /// <summary>
        /// 消费消息测试访问锁
        /// </summary>
        private static readonly object messageLock = new object();
        /// <summary>
        /// byte[] 消息客户端消费者示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage> node = nodeResult.Value.notNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            messages.Clear();
            for (char message = 'A'; message <= 'Z'; ++message)
            {
                byte[] messageData = new byte[] { (byte)message };
                messages.Add(message, messageData);

                result = await node.AppendMessage(messageData);
                if (!result.IsSuccess)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
            }

            using (ServerByteArrayMessageConsumer consumer = new ServerByteArrayMessageConsumer(CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.ClientCache.Client, node))
            {
                #region Wait for the test message to complete
                long timeout = Stopwatch.GetTimestamp() + AutoCSer.Date.GetTimestampBySeconds(10);
                while (messages.Count != 0)
                {
                    if (timeout < Stopwatch.GetTimestamp())
                    {
                        return AutoCSer.Breakpoint.ReturnFalse();
                    }
                    await Task.Delay(1);
                }
                #endregion
            }

            return true;
        }
    }
```
## 4. 分布式锁
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDistributedLockNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/DistributedLock/IDistributedLockNode.cs) 是分布式锁节点类型，T 必须实现 IEquatable<T> 接口，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/DistributedLockNode.cs)如下：
``` csharp
    /// <summary>
    /// 分布式锁客户端节点示例
    /// </summary>
    internal static class DistributedLockNode
    {
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDistributedLockNodeClientNode<string>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateDistributedLockNode<string>(nameof(DistributedLockNode)));
        /// <summary>
        /// 分布式锁客户端节点示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDistributedLockNodeClientNode<string> node = nodeResult.Value.notNull();

            string lockKey = AutoCSer.Random.Default.Next().toString();
            Task<bool>[] tasks = new Task<bool>[Math.Max(AutoCSer.Common.ProcessorCount, 4)];
            for (int index = 0; index != tasks.Length; ++index) tasks[index] = test(node, lockKey, 1 << 10);
            foreach (Task<bool> task in tasks)
            {
                bool result = await task;
                if (!result) return false;
            }

            return true;
        }
        /// <summary>
        /// 分布式锁并发错误检查数据
        /// </summary>
        private static int checkLock;
        /// <summary>
        /// 分布式锁客户端节点示例
        /// </summary>
        /// <param name="node"></param>
        /// <param name="lockKey"></param>
        /// <param name="loopCount"></param>
        /// <returns></returns>
        private static async Task<bool> test(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDistributedLockNodeClientNode<string> node, string lockKey, int loopCount)
        {
            await AutoCSer.Threading.SwitchAwaiter.Default;
            for (int count = loopCount; count != 0; --count)
            {
                var identity = await node.Enter(lockKey, 5);
                if (!identity.IsSuccess)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
                if (System.Threading.Interlocked.Increment(ref checkLock) != 1)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
                if (System.Threading.Interlocked.Decrement(ref checkLock) != 0)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
                node.Release(lockKey, identity.Value).Discard();
            }
            return true;
        }
    }
```
## 5. 多哈希位图过滤
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IManyHashBitMapFilterNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ManyHashBitMapFilter/IManyHashBitMapFilterNode.cs) 在功能上类似于布隆过滤器，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/ManyHashBitMapFilterNode.cs)如下：
``` csharp
    /// <summary>
    /// 多哈希位图过滤节点 客户端示例
    /// </summary>
    internal static class ManyHashBitMapFilterNode
    {
        /// <summary>
        /// 测试位图大小（位数量）
        /// </summary>
        private static readonly int size = new Algorithm.ManyHashBitMapCapacity(1 << 10, 2).GetHashCapacity();
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ManyHashBitMapFilter<string> client = new AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ManyHashBitMapFilter<string>(CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateManyHashBitMapFilterNode(nameof(ManyHashBitMapFilterNode), size)), size, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ManyHashBitMapFilter.GetHashCode2);
        /// <summary>
        /// 多哈希位图过滤节点 客户端示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var result = await client.Set("AAA");
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var boolResult = await client.Check("AAA");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IManyHashBitMapClientFilterNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ManyHashBitMapFilter/IManyHashBitMapClientFilterNode.cs) 通过服务端将位图信息实时推送到客户端的方式，**直接在客户端进行检测操作**，适合容量较小的位图，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/ManyHashBitMapClientFilterNode.cs)如下：
``` csharp
    /// <summary>
    /// 多哈希位图客户端同步过滤节点 客户端示例
    /// </summary>
    internal static class ManyHashBitMapClientFilterNode
    {
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ManyHashBitMapClientFilter<string> client = new AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ManyHashBitMapClientFilter<string>(CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateManyHashBitMapClientFilterNode(nameof(ManyHashBitMapClientFilterNode), new Algorithm.ManyHashBitMapCapacity(1 << 10).GetHashCapacity())), AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ManyHashBitMapClientFilter.GetHashCode4);
        /// <summary>
        /// 多哈希位图客户端同步过滤节点 客户端示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var result = await client.Set("AAA");
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var boolResult = await client.Check("AAA");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
## 6. 平衡树
### 6.1 二叉搜索树字典
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISearchTreeDictionaryNode<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ISearchTreeDictionaryNode.cs) 是对平衡树 [AutoCSer.SearchTree.Dictionary<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Extensions/SearchTree/Dictionary.cs) 的泛型封装，KT 必须实现 IComparable<KT> 接口，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/SearchTreeDictionaryNode.cs)如下：
``` csharp
    /// <summary>
    /// 平衡树客户端节点示例
    /// </summary>
    internal static class SearchTreeDictionaryNode
    {
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISearchTreeDictionaryNodeClientNode<int, Data.TestClass>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateSearchTreeDictionaryNode<int, Data.TestClass>(nameof(SearchTreeDictionaryNode)));
        /// <summary>
        /// 平衡树客户端节点示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISearchTreeDictionaryNodeClientNode<int, Data.TestClass> node = nodeResult.Value.notNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var boolResult = await node.TryAdd(2, new Data.TestClass { Int = 2 });
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.ContainsKey(2);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Set(1, new Data.TestClass { Int = 1 });
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Set(4, new Data.TestClass { Int = 4 });
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Set(3, new Data.TestClass { Int = 3 });
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var valueResult = await node.TryGetValue(3);
            if (!valueResult.IsSuccess || valueResult.Value.Value?.Int != 3)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            valueResult = await node.TryGetValueByIndex(1);
            if (!valueResult.IsSuccess || valueResult.Value.Value?.Int != 2)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            valueResult = await node.TryGetFirstValue();
            if (!valueResult.IsSuccess || valueResult.Value.Value?.Int != 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            valueResult = await node.TryGetLastValue();
            if (!valueResult.IsSuccess || valueResult.Value.Value?.Int != 4)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var intResult = await node.IndexOf(2);
            if (!intResult.IsSuccess || intResult.Value != 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var keyResult = await node.TryGetFirstKey();
            if (!keyResult.IsSuccess || keyResult.Value.Value != 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            keyResult = await node.TryGetLastKey();
            if (!keyResult.IsSuccess || keyResult.Value.Value != 4)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            intResult = await node.CountLess(3);
            if (!intResult.IsSuccess || intResult.Value != 2)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            intResult = await node.CountThan(3);
            if (!intResult.IsSuccess || intResult.Value != 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var valuesResult = await node.GetValues(1, 2);
            if (!valuesResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            int checkKey = 2;
            await foreach (var value in valuesResult.GetAsyncEnumerable())
            {
                if (!value.IsSuccess)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
                if (checkKey == 4)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
                if (value.Value.Value?.Int != checkKey)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
                ++checkKey;
            }
            return true;
        }
    }
```
### 6.2 二叉搜索树集合
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISearchTreeSetNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ISearchTreeSetNode.cs) 是对平衡树 [AutoCSer.SearchTree.Set<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Extensions/SearchTree/Set.cs) 的泛型封装，KT 必须实现 IComparable<KT> 接口，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/SearchTreeSetNode.cs)如下：
``` csharp
    /// <summary>
    /// 平衡树客户端节点示例
    /// </summary>
    internal static class SearchTreeSetNode
    {
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISearchTreeSetNodeClientNode<int>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateSearchTreeSetNode<int>(nameof(SearchTreeSetNode)));
        /// <summary>
        /// 平衡树客户端节点示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISearchTreeSetNodeClientNode<int> node = nodeResult.Value.notNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var boolResult = await node.Add(2);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Contains(2);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Add(1);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Add(4);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Add(3);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var valueResult = await node.GetByIndex(1);
            if (!valueResult.IsSuccess || valueResult.Value.Value != 2)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            valueResult = await node.GetFrist();
            if (!valueResult.IsSuccess || valueResult.Value.Value != 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            valueResult = await node.GetLast();
            if (!valueResult.IsSuccess || valueResult.Value.Value != 4)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var intResult = await node.IndexOf(2);
            if (!intResult.IsSuccess || intResult.Value != 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            intResult = await node.CountLess(3);
            if (!intResult.IsSuccess || intResult.Value != 2)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            intResult = await node.CountThan(3);
            if (!intResult.IsSuccess || intResult.Value != 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
### 6.3 排序字典
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISortedDictionaryNode<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ISortedDictionaryNode.cs) 是对 System.Collections.Generic.SortedDictionary<KT, VT> 的泛型封装，KT 必须实现 IComparable<KT> 接口。  
虽然 System.Collections.Generic.SortedDictionary<KT, VT> 内部封装的红黑树逻辑，但是提供的 API 只能当成字典使用，优点是没有扩容问题所以性能稳定，缺点是会造成内存碎片化并占用更多内存，而且 O(log(n)) 的随机内存访问会造成吞吐性能偏低，[点击查看客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/SortedDictionaryNode.cs)。
### 6.4 排序集合
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISortedSetNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ISortedSetNode.cs) 是对 System.Collections.Generic.SortedSet<KT, VT> 的泛型封装，KT 必须实现 IComparable<KT> 接口。  
System.Collections.Generic.SortedSet<KT, VT> 的内部封装的也是红黑树逻辑，但是提供的 API 基本只能当成哈希表使用，优点是没有扩容问题所以性能稳定，缺点是会造成内存碎片化并占用更多内存，而且 O(log(n)) 的随机内存访问会造成吞吐性能偏低，[点击查看客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/SortedSetNode.cs)。
## 7. 哈希表
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashSetNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IHashSetNode.cs) 是对哈希表的泛型封装，T 必须实现 IEquatable<T> 接口，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/HashSetNode.cs)如下：
``` csharp
    /// <summary>
    /// 哈希表客户端节点示例
    /// </summary>
    internal static class HashSetNode
    {
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashSetNodeClientNode<int>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateHashSetNode<int>(nameof(HashSetNode)));
        /// <summary>
        /// 哈希表客户端节点示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashSetNodeClientNode<int> node = nodeResult.Value.notNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var boolResult = await node.Add(2);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Contains(2);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Remove(2);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IFragmentHashSetNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IFragmentHashSetNode.cs) 是对分片哈希表的泛型封装，T 必须实现 IEquatable<T> 接口，[点击查看客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/FragmentHashSetNode.cs)。
## 8. 队列
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IQueueNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IQueueNode.cs) 是对 System.Collections.Generic.Queue<T> 的泛型封装，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/QueueNode.cs)如下：
``` csharp
    /// <summary>
    /// 泛型队列客户端节点示例
    /// </summary>
    internal static class QueueNode
    {
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IQueueNodeClientNode<int>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateQueueNode<int>(nameof(QueueNode)));
        /// <summary>
        /// 泛型队列客户端节点示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IQueueNodeClientNode<int> node = nodeResult.Value.notNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            result = await node.Enqueue(2);
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var boolResult = await node.Contains(2);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var valueResult = await node.TryDequeue();
            if (!valueResult.IsSuccess || valueResult.Value.Value != 2)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayQueueNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IByteArrayQueueNode.cs) 的数据采用服务端字节数组封装，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/ByteArrayQueueNode.cs)如下：
``` csharp
    /// <summary>
    /// byte[] 队列客户端节点示例
    /// </summary>
    internal static class ByteArrayQueueNode
    {
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayQueueNodeClientNode> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateByteArrayQueueNode(nameof(ByteArrayQueueNode)));
        /// <summary>
        /// byte[] 队列客户端节点示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayQueueNodeClientNode node = nodeResult.Value.notNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            result = await node.Enqueue(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.JsonSerialize(new Data.TestClass { Int = 2 }));
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var valueResult = await node.TryDequeueJsonDeserialize<Data.TestClass>();
            if (!valueResult.IsSuccess || valueResult.Value?.Int != 2)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
## 9. 栈
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IStackNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IStackNode.cs) 是对 System.Collections.Generic.Stack<T> 的泛型封装，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/StackNode.cs)如下：
``` csharp
    /// <summary>
    /// 泛型栈客户端节点示例
    /// </summary>
    internal static class StackNode
    {
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IStackNodeClientNode<int>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateStackNode<int>(nameof(StackNode)));
        /// <summary>
        /// 泛型栈客户端节点示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IStackNodeClientNode<int> node = nodeResult.Value.notNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            result = await node.Push(2);
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var boolResult = await node.Contains(2);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var valueResult = await node.TryPop();
            if (!valueResult.IsSuccess || valueResult.Value.Value != 2)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayStackNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IByteArrayStackNode.cs) 的数据采用服务端字节数组封装，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/ByteArrayStackNode.cs)如下：
``` csharp
    /// <summary>
    /// byte[] 栈客户端节点示例
    /// </summary>
    internal static class ByteArrayStackNode
    {
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayStackNodeClientNode> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateByteArrayStackNode(nameof(ByteArrayStackNode)));
        /// <summary>
        /// byte[] 栈客户端节点示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayStackNodeClientNode node = nodeResult.Value.notNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            result = await node.Push(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.JsonSerialize(new Data.TestClass { Int = 2 }));
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var valueResult = await node.TryPopJsonDeserialize<Data.TestClass>();
            if (!valueResult.IsSuccess || valueResult.Value?.Int != 2)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
## 10. 数组
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IArrayNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IArrayNode.cs) 是对 T[] 的泛型封装，[点击查看客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/ArrayNode.cs)。  
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ILeftArrayNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ILeftArrayNode.cs) 是对 [AutoCSer.LeftArray<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/LeftArray.cs) 的泛型封装，功能类似于 System.Collections.Generic.List<T>，[点击查看客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/LeftArrayNode.cs)。  
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISortedListNode<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ISortedListNode.cs) 是对关键字排序数组 System.Collections.Generic.SortedList<KT, VT> 的泛型封装，KT 必须实现 IComparable<KT> 接口，[点击查看客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/SortedListNode.cs)。
## 11. 位图
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IBitmapNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IBitmapNode.cs) 是一个二进制位图节点，[点击查看客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/BitmapNode.cs)。
## 12. 自增 ID
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IIdentityGeneratorNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IIdentityGeneratorNode.cs) 是一个简单的 64 位自增 ID 生成节点，[点击查看客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/IdentityGeneratorNode.cs)。
## 13. 仅存档
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IOnlyPersistenceNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IOnlyPersistenceNode.cs) 是一个泛型封装，用于大量并发数据**快速存档，不修改内存数据，也不定义快照操作**，[客户端示例代码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/OnlyPersistenceNode.cs)如下：
``` csharp
    /// <summary>
    /// 仅存档数据节点客户端示例
    /// </summary>
    internal static class OnlyPersistenceNode
    {
        /// <summary>
        /// 客户端节点单例
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IOnlyPersistenceNodeClientNode<Data.TestClass>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateOnlyPersistenceNode<Data.TestClass>(nameof(OnlyPersistenceNode)));
        /// <summary>
        /// 仅存档数据节点客户端示例
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IOnlyPersistenceNodeClientNode<Data.TestClass> node = nodeResult.Value.notNull();
            var result = await node.Save(AutoCSer.RandomObject.Creator<Data.TestClass>.CreateNotNull());
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            node.SaveSendOnly(AutoCSer.RandomObject.Creator<Data.TestClass>.CreateNotNull()).Discard();
            return true;
        }
    }
```
本项目代码**仅用于测试**，实战场景应该将数据库配置 [AutoCSer.CommandService.StreamPersistenceMemoryDatabaseServiceConfig](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Server/StreamPersistenceMemoryDatabaseServiceConfig.cs).PersistenceType 设置为 **OnlyPersistence**，这个设置可以让数据库重启的时候快速重建持久化**避免加载历史数据**，比如：
``` csharp
            AutoCSer.Document.MemoryDatabaseNode.Server.ServiceConfig databaseServiceConfig = new AutoCSer.Document.MemoryDatabaseNode.Server.ServiceConfig
            {
                PersistencePath = Path.Combine(AutoCSer.TestCase.Common.Config.AutoCSerTemporaryFilePath, nameof(AutoCSer.Document.MemoryDatabaseNode)),
                PersistenceSwitchPath = Path.Combine(AutoCSer.TestCase.Common.Config.AutoCSerTemporaryFilePath, nameof(AutoCSer.Document.MemoryDatabaseNode) + nameof(AutoCSer.Document.MemoryDatabaseNode.Server.ServiceConfig.PersistenceSwitchPath)),
                PersistenceType = AutoCSer.CommandService.StreamPersistenceMemoryDatabase.PersistenceTypeEnum.OnlyPersistence
            };
```
## 14. 分布式搜索
[AutoCSer.CommandService.Search.StaticTrieGraph.IStaticTrieGraphNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/Search/StaticTrieGraph/IStaticTrieGraphNode.cs) 是一个 Trie 图节点，用于管理搜索分词并提供分词查询功能。  
[AutoCSer.CommandService.Search.IWordIdentityBlockIndexNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/Search/WordIdentityBlockIndex/IWordIdentityBlockIndexNode.cs) 是一个分词结果磁盘块索引信息节点的泛型封装，T 必须实现 IEquatable<T> 接口，基于磁盘块功能管理搜索目标对象的分词结果数据。  
[AutoCSer.CommandService.Search.DiskBlockIndex.IRemoveMarkHashIndexNode<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/Search/DiskBlockIndex/IRemoveMarkHashIndexNode.cs) 是一个哈希索引节点的泛型封装，KT 必须实现 IEquatable<KT> 接口，VT 必须实现 IEquatable<VT> 接口，基于磁盘块功能管理倒排索引数据。  
[AutoCSer.CommandService.Search.DiskBlockIndex.IRemoveMarkHashKeyIndexNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/Search/DiskBlockIndex/IRemoveMarkHashKeyIndexNode.cs) 是一个 int/uint 关键字的哈希索引节点的泛型封装，T 必须实现 IEquatable<T> 接口，基于磁盘块功能管理倒排索引数据。  
[AutoCSer.CommandService.Search.MemoryIndex.IHashIndexNode<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/Search/MemoryIndex/IHashIndexNode.cs) 是一个哈希索引节点的泛型封装，KT 必须实现 IEquatable<KT> 接口，VT 必须实现 IEquatable<VT> 接口，用于管理内存搜索模式的倒排索引数据。  
[AutoCSer.CommandService.Search.MemoryIndex.IHashCodeKeyIndexNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/Search/MemoryIndex/IHashCodeKeyIndexNode.cs) 是一个 int/uint 关键字的哈希索引节点的泛型封装，T 必须实现 IEquatable<T> 接口，用于管理内存搜索模式的倒排索引数据。  
[AutoCSer.CommandService.Search.IConditionDataNode<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/Search/ConditionData/IConditionDataNode.cs) 是一个泛型封装节点，KT 必须实现 IEquatable<KT> 接口，用于管理非索引条件查询数据。
## 15. 运维工具
[AutoCSer.CommandService.IDeployTaskNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/DeployTask/IDeployTaskNode.cs) 是一个发布任务管理节点，用于 AutoCSer 应用程序的发布操作。  
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IProcessGuardNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ProcessGuard/IProcessGuardNode.cs) 是一个进程守护管理节点，用于守护本机 AutoCSer 应用程序以及与 AutoCSer 服务的发布切换进程处理。  
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IServerRegistryNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ServerRegistry/IServerRegistryNode.cs) 是一个服务注册管理节点，用于 AutoCSer [服务的注册管理与服务信息的推送](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/10.ServerRegistry/10.ServerRegistry.md)操作。  
[AutoCSer.CommandService.InterfaceRealTimeCallMonitor.IExceptionStatisticsNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/InterfaceRealTimeCallMonitor/ExceptionStatistics/IExceptionStatisticsNode.cs) 是一个 API 异常调用统计信息节点，用于统计 AutoCSer 实时调用监视服务接收到的 API 调用异常信息。
## 16. 其它
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CustomNode.ITimeoutMessageNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/CustomNode/TimeoutMessage/ITimeoutMessageNode.cs) 是一个超时任务消息处理节点，可用于分布式事务数据一致性检查操作。
# [自定义节点](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/08.MemoryDatabaseCustomNode.md)