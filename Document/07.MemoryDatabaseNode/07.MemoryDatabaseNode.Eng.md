# In-memory database - Built-in data structure node
AutoCSer in-memory database has built-in support for some simple and commonly used data structures, mainly including dictionaries, messages, distributed locks, balanced binary trees, hash tables, hash filtering, non-precise statistics, queues, stacks, bitmaps, arrays, archive-only data, and AutoCSer operation and maintenance tool components, etc. It can also serve as a reference example for [custom nodes](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/08.MemoryDatabaseCustomNode.Eng.md).
# Server
The AutoCSer in-memory database service is a service controller implemented based on AutoCSer RPC. Therefore, creating an in-memory database service is equivalent to creating an RPC service with an instance of the in-memory database service controller.
## 1. Configuration definition
When the default configuration type [AutoCSer.CommandService.StreamPersistenceMemoryDatabaseServiceConfig](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Server/StreamPersistenceMemoryDatabaseServiceConfig.cs) does not meet the requirements, we need to derive a subclass from it for [custom configuration](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Server/ServiceConfig.cs).
``` csharp
    /// <summary>
    /// Log stream persistence in memory database service configuration
    /// </summary>
    internal sealed class ServiceConfig : AutoCSer.CommandService.StreamPersistenceMemoryDatabaseServiceConfig
    {
        /// <summary>
        /// The test environment deletes historical persistent files from the previous 15 minutes. The production environment processes the files based on site requirements
        /// </summary>
        /// <returns></returns>
        public override DateTime GetRemoveHistoryFileTime()
        {
            return AutoCSer.Threading.SecondTimer.UtcNow.AddMinutes(-15);
        }
        /// <summary>
        /// The test environment deletes persistent files once a minute. The production environment deletes persistent files based on site requirements
        /// </summary>
        /// <param name="service"></param>
        /// <returns></returns>
        public override void RemoveHistoryFile(AutoCSer.CommandService.StreamPersistenceMemoryDatabaseService service)
        {
            new AutoCSer.CommandService.StreamPersistenceMemoryDatabase.RemoveHistoryFile(service).Remove(new AutoCSer.Threading.TaskRunTimer(60.0)).AutoCSerExtensions().Catch();
        }
        /// <summary>
        /// Set the rebuild file size to at least 10MB
        /// </summary>
        /// <param name="service"></param>
        /// <returns></returns>
        public override bool CheckRebuild(AutoCSer.CommandService.StreamPersistenceMemoryDatabaseService service)
        {
            long persistencePosition = service.GetPersistencePosition();
            return (persistencePosition >> 1) >= service.RebuildSnapshotPosition && persistencePosition > 10 << 20;
        }
    }
```
## 2. Create the instance
[Call the Create method of the in-memory database configuration type](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Program.cs) to create an instance of the [in-memory database service](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Server/StreamPersistenceMemoryDatabaseService.cs) controller.
``` csharp
            AutoCSer.Document.MemoryDatabaseNode.Server.ServiceConfig databaseServiceConfig = new AutoCSer.Document.MemoryDatabaseNode.Server.ServiceConfig
            {
                PersistencePath = Path.Combine(AutoCSer.TestCase.Common.Config.AutoCSerTemporaryFilePath, nameof(AutoCSer.Document.MemoryDatabaseNode)),
                PersistenceSwitchPath = Path.Combine(AutoCSer.TestCase.Common.Config.AutoCSerTemporaryFilePath, nameof(AutoCSer.Document.MemoryDatabaseNode) + nameof(AutoCSer.Document.MemoryDatabaseNode.Server.ServiceConfig.PersistenceSwitchPath))
            };
            AutoCSer.CommandService.StreamPersistenceMemoryDatabaseService databaseService = databaseServiceConfig.Create();
```
## 3. Create the RPC server listener
The default service controller interface type for in-memory databases is [AutoCSer.CommandService.IStreamPersistenceMemoryDatabaseService](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Server/IStreamPersistenceMemoryDatabaseService.cs), and the service controller interface type that supports multi-threaded concurrent read operations is [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IReadWriteQueueService](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Server/IReadWriteQueueService.cs).  
The [sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Program.cs) does not define the [service authentication API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/04.ServiceAuthentication/04.ServiceAuthentication.Eng.md). The production environment needs to add the service authentication API to prevent illegal client access.
``` csharp
            AutoCSer.Net.CommandServerConfig commandServerConfig = new AutoCSer.Net.CommandServerConfig
            {
                Host = new AutoCSer.Net.HostEndPoint((ushort)AutoCSer.TestCase.Common.CommandServerPortEnum.Document),
            };
            await using (AutoCSer.Net.CommandListener commandListener = new AutoCSer.Net.CommandListenerBuilder(0)
                .Append<AutoCSer.CommandService.IStreamPersistenceMemoryDatabaseService>(databaseService)
                //.Append<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IReadWriteQueueService>(databaseService)
                .CreateCommandListener(commandServerConfig))
            {
                if (await commandListener.Start())
                {
                    await Client.CommandClientSocketEvent.Test();

                    Console.WriteLine("Completed");
                    Console.ReadKey();
                }
            }
```
# Client
The AutoCSer in-memory database client is an instance of an RPC client controller.
## 1. Define the RPC client instance
The [client controller instance](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/CommandClientSocketEvent.cs) of RPC is defined in a derived class of [AutoCSer.Net.CommandClientSocketEvent](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientSocketEvent/CommandClientSocketEvent.cs), and the in-memory database client needs to implement interface [AutoCSer.CommandService.IStreamPersistenceMemoryDatabaseClientSocketEvent](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Client/IStreamPersistenceMemoryDatabaseClientSocketEvent.cs).
``` csharp
    /// <summary>
    /// RPC client instance
    /// </summary>
    internal sealed class CommandClientSocketEvent : AutoCSer.Net.CommandClientSocketEventTask<CommandClientSocketEvent>, AutoCSer.CommandService.IStreamPersistenceMemoryDatabaseClientSocketEvent
    {
        /// <summary>
        /// In-memory database client interface instance
        /// </summary>
        [AllowNull]
        public AutoCSer.CommandService.IStreamPersistenceMemoryDatabaseClient StreamPersistenceMemoryDatabaseClient { get; private set; }
        /// <summary>
        /// The set of parameters for creating the client controller is used to create the client controller object during the initialization of the client socket, and also to automatically bind the controller properties based on the interface type of the client controller after the client socket passes the service authentication API
        /// </summary>
        public override IEnumerable<AutoCSer.Net.CommandClientControllerCreatorParameter> ControllerCreatorParameters
        {
            get
            {
                yield return new AutoCSer.Net.CommandClientControllerCreatorParameter(typeof(AutoCSer.CommandService.IStreamPersistenceMemoryDatabaseService), typeof(AutoCSer.CommandService.IStreamPersistenceMemoryDatabaseClient));
                //yield return new AutoCSer.Net.CommandClientControllerCreatorParameter(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IReadWriteQueueService), typeof(AutoCSer.CommandService.IStreamPersistenceMemoryDatabaseClient));
            }
        }
        /// <summary>
        /// RPC client instance
        /// </summary>
        /// <param name="client">Command client</param>
        public CommandClientSocketEvent(AutoCSer.Net.CommandClient client) : base(client) { }
    }
```
## 2. Create the RPC client
Like ordinary AutoCSer RPC clients, in-memory database clients should adopt the singleton pattern in practical applications.
``` csharp
        /// <summary>
        /// In-memory database client singleton
        /// </summary>
        public static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientCache<CommandClientSocketEvent> StreamPersistenceMemoryDatabaseClientCache = new AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientCache<CommandClientSocketEvent>(new AutoCSer.Net.CommandClientConfig
        {
            Host = new AutoCSer.Net.HostEndPoint((ushort)AutoCSer.TestCase.Common.CommandServerPortEnum.Document),
            GetSocketEventDelegate = (client) => new CommandClientSocketEvent(client)
        });
```
# Built-in data structure node
Since the invocation overhead for creating and obtaining nodes is relatively high, it can be compared to the operation of creating tables in traditional relational databases. Therefore, the operation of calling related apis should be minimized as much as possible. The [encapsulation type of the built-in provided client node cache singleton](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Client/StreamPersistenceMemoryDatabaseClientNodeCache.cs) can be used to obtain client nodes.
## 1. Key-Value dictionary
Dictionaries are the most commonly used data structures. To meet different scenarios and performance requirements, AutoCSer has built-in dictionary nodes with three different serialization strategies.  
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDictionaryNode<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IDictionaryNode.cs) is the server-side **generic encapsulation** of the dictionary (all generic encapsulation mentioned later refers to server-side generic encapsulation). KT must implement the IEquatable<KT> interface. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/DictionaryNode.cs) is as follows:
``` csharp
    /// <summary>
    /// Example of a generic dictionary client node
    /// </summary>
    internal static class DictionaryNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDictionaryNodeClientNode<string, string>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateDictionaryNode<string, string>(nameof(DictionaryNode)));
        /// <summary>
        /// Example of a generic dictionary client node
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDictionaryNodeClientNode<string, string> node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var boolResult = await node.Set("3A", "AAA");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var valueResult = await node.TryGetValue("3A");
            if (!valueResult.IsSuccess || valueResult.Value.Value != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            valueResult = await node.TryGetValue("3B");
            if (!valueResult.IsSuccess || valueResult.Value.IsValue)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Remove("3A");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayDictionaryNode<KT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IByteArrayDictionaryNode.cs) is a **generic encapsulation** of dictionary key, KT must implement the IEquatable<KT> interface, and Value encapsulates x using a [server-side byte array][AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/ServerByteArray.cs).  
The server-side byte array encapsulation supports by default four client-side parameter passing modes, namely byte[], string, JSON mixed binary serialization, and binary serialization. Different parameter passing modes require different apis to handle them separately. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/ByteArrayDictionaryNode.cs) is as follows:
``` csharp
    /// <summary>
    /// Dictionary node client example
    /// </summary>
    internal static class ByteArrayDictionaryNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayDictionaryNodeClientNode<string>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateByteArrayDictionaryNode<string>(nameof(ByteArrayDictionaryNode)));
        /// <summary>
        /// Dictionary node client example
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayDictionaryNodeClientNode<string> node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            #region byte[]
            byte[] data = new byte[] { 1, 2, 3, 4 };
            //byte[] supports implicit conversion to AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray
            var boolResult = await node.Set("ByteArray", data);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            //Get byte[] using the TryGetValue method
            var dataResult = await node.TryGetValue("ByteArray");
            if (!dataResult.IsSuccess || !AutoCSer.Common.SequenceEqual(data, dataResult.Value.Value))
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            #region string
            //string supports implicit conversion to AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray, which is essentially binary serialization to byte[]
            boolResult = await node.Set("String", "AAA");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            //Get the string using the TryGetString extension method
            var stringResult = await node.TryGetString("String");
            if (!stringResult.IsSuccess || stringResult.Value != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            #region JSON mixed binary serialization
            Data.TestClass testData = new Data.TestClass { Int = 1, String = "AAA" };
            boolResult = await node.Set("JsonSerialize", AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.JsonSerialize(testData));
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            //Get the JSON mixed binary deserialized object using the TryGetJsonDeserialize extension method
            var classResult = await node.TryGetJsonDeserialize<string, Data.TestClass>("JsonSerialize");
            if (!classResult.IsSuccess || classResult.Value?.String != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            #region Binary serialization
            boolResult = await node.Set("BinarySerialize", AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.BinarySerialize(testData));
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            //Get the binary deserialized object using the TryGetBinaryDeserialize extension method
            classResult = await node.TryGetBinaryDeserialize<string, Data.TestClass>("BinarySerialize");
            if (!classResult.IsSuccess || classResult.Value?.String != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            return true;
        }
    }
```
Both the Key and Value of [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashBytesDictionaryNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IHashBytesDictionaryNode.cs) are encapsulated in server-side byte arrays. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/HashBytesDictionaryNode.cs) is as follows:
``` csharp
    /// <summary>
    /// Dictionary node client example
    /// </summary>
    internal static class HashBytesDictionaryNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashBytesDictionaryNodeClientNode> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateHashBytesDictionaryNode(nameof(HashBytesDictionaryNode)));
        /// <summary>
        /// Dictionary node client example
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashBytesDictionaryNodeClientNode node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            #region Keyword JSON serialization
            Data.TestClass keyData = new Data.TestClass { Int = 1, String = "3A" };
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray jsonKey = AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.JsonSerialize(keyData);
            var boolResult = await node.Set(jsonKey, "AAA");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var stringResult = await node.TryGetString(jsonKey);
            if (!stringResult.IsSuccess || stringResult.Value != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            #region Keyword binary serialization
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray binarySerializeKey = AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.BinarySerialize(keyData);
            boolResult = await node.Set(binarySerializeKey, "AAA");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            stringResult = await node.TryGetString(binarySerializeKey);
            if (!stringResult.IsSuccess || stringResult.Value != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            return true;
        }
    }
```
The client interface of the data structure node is generated by default based on the interface definition of the server node using the [static code generation](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/05.CodeGenerator.Eng.md) tool of AutoCSer. The default client interface type name is to add the **ClientNode suffix** after the server interface type name. For example, the interface type of the client node corresponding to the server node interface type [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDictionaryNode<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IDictionaryNode.cs) is AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDictionaryNode**ClientNode**<KT, VT>.
### 1.1 Generic encapsulation
The prerequisite for using generic encapsulation is that the server contains and loads specific data types. This requires the server to reference the assemblies defined by the relevant data types and may need to **explicitly trigger the loading of these assemblies and type information** before the service starts.  
By default, instance objects of generic encapsulated types are serialized in binary format. The server-side memory data stores **instances of specific objects**, which is not suitable for handling complex-defined reference types because multiple reference type objects may be generated, thereby exerting greater pressure on GC.  
Generally speaking, value types without reference type members or simple reference types should be encapsulated using generics. This can achieve the best **performance and memory space usage**, such as int, long, string, enum, or struct without reference type members.
### 1.2 Server-side byte array encapsulation
Using server-side byte array encapsulation, **both serialization and deserialization operations are determined by the client**, and all related operations are carried out on the client side. The server has no concept of business data types and **only processes byte[] data**. Essentially, it is the same as the Redis server which only processes byte sequences.  
Generally speaking, the problem with server-side byte array encapsulation is that it is very **likely to cause excessive server-side memory occupation**, because byte[] is usually the serialized data of data objects. For example, the space occupation of JSON serialized data and memory object data may even differ by an order of magnitude.
## 2. Fragment dictionary
We know that for collection types implemented based on a single array, when the array space is insufficient, an expansion operation is required. Generally, the expansion operation involves applying for a new array with approximately twice the space and writing the old data. When the volume of data is large, **once the expansion operation is triggered, it will cause a long CPU usage time**. This operation will seriously affect the latency and throughput performance of the API.  
Many data structure expansion operations have this problem. For instance, the Key-Value dictionary introduced above also has this issue. When the upper limit of the number of valid data is determined, we can avoid the expansion operation by setting the capacity parameter of the constructor.  
However, in the vast majority of scenarios, we are not aware of this upper limit value, and expansion operations are basically inevitable. Therefore, AutoCSer performs a simple array encapsulation on the dictionary. It will apply for a 256-length dictionary array. In a hash value randomization environment, the data volume of each dictionary object will be **reduced to about 1/256 of the overall data volume**, which can significantly reduce the delay of a single expansion operation and stabilize the throughput performance.  
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IFragmentDictionaryNode<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IFragmentDictionaryNode.cs) is a **generic encapsulation** of the fragment dictionary. KT must implement the IEquatable<KT> interface. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/FragmentDictionaryNode.cs) is as follows:
``` csharp
    /// <summary>
    /// Example of a generic dictionary client node
    /// </summary>
    internal static class FragmentDictionaryNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IFragmentDictionaryNodeClientNode<string, string>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateFragmentDictionaryNode<string, string>(nameof(FragmentDictionaryNode)));
        /// <summary>
        /// Example of a generic dictionary client node
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IFragmentDictionaryNodeClientNode<string, string> node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var boolResult = await node.Set("3A", "AAA");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var valueResult = await node.TryGetValue("3A");
            if (!valueResult.IsSuccess || valueResult.Value.Value != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            valueResult = await node.TryGetValue("3B");
            if (!valueResult.IsSuccess || valueResult.Value.IsValue)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Remove("3A");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayFragmentDictionaryNode<KT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IByteArrayFragmentDictionaryNode.cs) is a **generic encapsulation** of the fragment dictionary key, KT must implement the IEquatable<KT> interface, and Value is encapsulated using a server-side byte array. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/ByteArrayFragmentDictionaryNode.cs) is as follows:
``` csharp
    /// <summary>
    /// Dictionary node client example
    /// </summary>
    internal static class ByteArrayFragmentDictionaryNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayFragmentDictionaryNodeClientNode<string>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateByteArrayFragmentDictionaryNode<string>(nameof(ByteArrayFragmentDictionaryNode)));
        /// <summary>
        /// Dictionary node client example
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayFragmentDictionaryNodeClientNode<string> node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            #region byte[]
            byte[] data = new byte[] { 1, 2, 3, 4 };
            //byte[] supports implicit conversion to AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray
            var boolResult = await node.Set("ByteArray", data);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            //Get byte[] using the TryGetValue method
            var dataResult = await node.TryGetValue("ByteArray");
            if (!dataResult.IsSuccess || !AutoCSer.Common.SequenceEqual(data, dataResult.Value.Value))
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            #region string
            //string supports implicit conversion to AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray, which is essentially binary serialization to byte[]
            boolResult = await node.Set("String", "AAA");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            //Get the string using the TryGetString extension method
            var stringResult = await node.TryGetString("String");
            if (!stringResult.IsSuccess || stringResult.Value != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            #region JSON mixed binary serialization
            Data.TestClass testData = new Data.TestClass { Int = 1, String = "AAA" };
            boolResult = await node.Set("JsonSerialize", AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.JsonSerialize(testData));
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            //Get the JSON mixed binary deserialized object using the TryGetJsonDeserialize extension method
            var classResult = await node.TryGetJsonDeserialize<string, Data.TestClass>("JsonSerialize");
            if (!classResult.IsSuccess || classResult.Value?.String != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            #region Binary serialization
            boolResult = await node.Set("BinarySerialize", AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.BinarySerialize(testData));
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            //Get the binary deserialized object using the TryGetBinaryDeserialize extension method
            classResult = await node.TryGetBinaryDeserialize<string, Data.TestClass>("BinarySerialize");
            if (!classResult.IsSuccess || classResult.Value?.String != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            return true;
        }
    }
```
Both the Key and Value of [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashBytesFragmentDictionaryNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IHashBytesFragmentDictionaryNode.cs) are encapsulated using server-side byte arrays. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/HashBytesFragmentDictionaryNode.cs) is as follows:
``` csharp
    /// <summary>
    /// Dictionary node client example
    /// </summary>
    internal static class HashBytesFragmentDictionaryNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashBytesFragmentDictionaryNodeClientNode> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateHashBytesFragmentDictionaryNode(nameof(HashBytesFragmentDictionaryNode)));
        /// <summary>
        /// Dictionary node client example
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashBytesFragmentDictionaryNodeClientNode node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            #region Keyword JSON serialization
            Data.TestClass keyData = new Data.TestClass { Int = 1, String = "3A" };
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray jsonKey = AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.JsonSerialize(keyData);
            var boolResult = await node.Set(jsonKey, "AAA");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var stringResult = await node.TryGetString(jsonKey);
            if (!stringResult.IsSuccess || stringResult.Value != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            #region Keyword binary serialization
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray binarySerializeKey = AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.BinarySerialize(keyData);
            boolResult = await node.Set(binarySerializeKey, "AAA");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            stringResult = await node.TryGetString(binarySerializeKey);
            if (!stringResult.IsSuccess || stringResult.Value != "AAA")
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            #endregion

            return true;
        }
    }
```
## 3. Message
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/IMessageNode.cs) is the message node interface type. According to the requirements of different message data types, it provides five types of client consumer encapsulations built-in.  
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.BinaryMessageConsumer<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/BinaryMessageConsumer.cs) is the encapsulation of the server-side generic message, and the client can use the delegation pattern [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.OnBinaryMessageConsumer<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/OnBinaryMessageConsumer.cs) to replace the overloading of the onMessage method. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/Message/BinaryMessageConsumer.cs) is as follows:
``` csharp
    /// <summary>
    /// Server-side generic message client-side consumer example
    /// </summary>
    internal sealed class BinaryMessageConsumer : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.BinaryMessageConsumer<Data.TestClass>
    {
        /// <summary>
        /// Server-side generic message client-side consumer example
        /// </summary>
        /// <param name="commandClient">Command client</param>
        /// <param name="node">Binary serialized message client node</param>
        internal BinaryMessageConsumer(AutoCSer.Net.CommandClient commandClient, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.BinaryMessage<Data.TestClass>> node) : base(commandClient, node, 1 << 10) { }
        /// <summary>
        /// Message processing. An exception also indicates that the message execution failed
        /// </summary>
        /// <param name="message"></param>
        /// <returns>Whether the message was executed successfully</returns>
        protected override Task<bool> onMessage(Data.TestClass message)
        {
            lock (messageLock) messages.Remove(message.Int);
            return AutoCSer.Common.GetCompletedTask(true);
        }

        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.BinaryMessage<Data.TestClass>>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateBinaryMessageNode<Data.TestClass>(nameof(BinaryMessageConsumer)));
        /// <summary>
        /// Message collection not completed
        /// </summary>
        private static Dictionary<int, Data.TestClass> messages = new Dictionary<int, Data.TestClass>();
        /// <summary>
        /// Access lock for consumption message testing
        /// </summary>
        private static readonly object messageLock = new object();
        /// <summary>
        /// Server-side generic message client-side consumer example
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.BinaryMessage<Data.TestClass>> node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            messages.Clear();
            for (char message = 'A'; message <= 'Z'; ++message)
            {
                Data.TestClass messageData = new Data.TestClass { Int = message, String = message.ToString() };
                messages.Add(message, messageData);

                result = await node.AppendMessage(messageData);
                if (!result.IsSuccess)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
            }

            using (BinaryMessageConsumer consumer = new BinaryMessageConsumer(CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.ClientCache.Client, node))
            {
                #region Wait for the test message to complete
                long timeout = Stopwatch.GetTimestamp() + AutoCSer.Date.GetTimestampBySeconds(10);
                while (messages.Count != 0)
                {
                    if (timeout < Stopwatch.GetTimestamp())
                    {
                        return AutoCSer.Breakpoint.ReturnFalse();
                    }
                    await Task.Delay(1);
                }
                #endregion
            }

            return true;
        }
    }
```
All non-generic messages on the server are encapsulations of the [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/ServerByteArrayMessage.cs) message type. The message data processed by the server is byte[], and serialization and deserialization operations are handled by the client.
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessageConsumer<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/ServerByteArrayMessageConsumer.cs) is the encapsulation of the client's binary serialized message, and [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.OnServerByteArrayMessageConsumer<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/OnServerByteArrayMessageConsumer.cs) is the overloaded encapsulation that uses the delegate substitution method onMessage. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/Message/ServerByteArrayBinaryMessageConsumer.cs) is as follows:
``` csharp
    /// <summary>
    /// Client binary serialized message client consumer example
    /// </summary>
    internal sealed class ServerByteArrayBinaryMessageConsumer : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessageConsumer<Data.TestClass>
    {
        /// <summary>
        /// Client binary serialized message client consumer example
        /// </summary>
        /// <param name="commandClient">Command client</param>
        /// <param name="node">Server-side byte array messages client nodes</param>
        internal ServerByteArrayBinaryMessageConsumer(AutoCSer.Net.CommandClient commandClient, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage> node) : base(commandClient, node, 1 << 10) { }
        /// <summary>
        /// Message processing. An exception also indicates that the message execution failed
        /// </summary>
        /// <param name="message"></param>
        /// <returns>Whether the message was executed successfully</returns>
        protected override Task<bool> onMessage(Data.TestClass? message)
        {
            lock (messageLock) messages.Remove(message.AutoCSerClassGenericTypeExtensions().NotNull().Int);
            return AutoCSer.Common.GetCompletedTask(true);
        }

        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateServerByteArrayMessageNode(nameof(ServerByteArrayBinaryMessageConsumer)));
        /// <summary>
        /// Message collection not completed
        /// </summary>
        private static Dictionary<int, Data.TestClass> messages = new Dictionary<int, Data.TestClass>();
        /// <summary>
        /// Access lock for consumption message testing
        /// </summary>
        private static readonly object messageLock = new object();
        /// <summary>
        /// Client binary serialized message client consumer example
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage> node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            messages.Clear();
            for (char message = 'A'; message <= 'Z'; ++message)
            {
                Data.TestClass messageData = new Data.TestClass { Int = message, String = message.ToString() };
                messages.Add(message, messageData);

                result = await node.AppendMessage(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage.BinarySerialize(messageData));
                if (!result.IsSuccess)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
            }

            using (ServerByteArrayBinaryMessageConsumer consumer = new ServerByteArrayBinaryMessageConsumer(CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.ClientCache.Client, node))
            {
                #region Wait for the test message to complete
                long timeout = Stopwatch.GetTimestamp() + AutoCSer.Date.GetTimestampBySeconds(10);
                while (messages.Count != 0)
                {
                    if (timeout < Stopwatch.GetTimestamp())
                    {
                        return AutoCSer.Breakpoint.ReturnFalse();
                    }
                    await Task.Delay(1);
                }
                #endregion
            }

            return true;
        }
    }
```
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessageJsonConsumer<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/ServerByteArrayMessageJsonConsumer.cs) is the encapsulation of the client's JSON mixed binary serialized message, and [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.OnServerByteArrayMessageJsonConsumer<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/OnServerByteArrayMessageJsonConsumer.cs) is the overloaded encapsulation that uses the delegation alternative method onMessage. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/Message/ServerByteArrayMessageJsonConsumer.cs) is as follows:
``` csharp
    /// <summary>
    /// Client JSON mixed binary message client consumer example
    /// </summary>
    internal sealed class ServerByteArrayMessageJsonConsumer : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessageJsonConsumer<Data.TestClass>
    {
        /// <summary>
        /// Client JSON mixed binary message client consumer example
        /// </summary>
        /// <param name="commandClient">Command client</param>
        /// <param name="node">Server-side byte array messages client nodes</param>
        internal ServerByteArrayMessageJsonConsumer(AutoCSer.Net.CommandClient commandClient, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage> node) : base(commandClient, node, 1 << 10) { }
        /// <summary>
        /// Message processing. An exception also indicates that the message execution failed
        /// </summary>
        /// <param name="message"></param>
        /// <returns>Whether the message was executed successfully</returns>
        protected override Task<bool> onMessage(Data.TestClass? message)
        {
            lock (messageLock) messages.Remove(message.AutoCSerClassGenericTypeExtensions().NotNull().Int);
            return AutoCSer.Common.GetCompletedTask(true);
        }

        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateServerByteArrayMessageNode(nameof(ServerByteArrayMessageJsonConsumer)));
        /// <summary>
        /// Message collection not completed
        /// </summary>
        private static Dictionary<int, Data.TestClass> messages = new Dictionary<int, Data.TestClass>();
        /// <summary>
        /// Access lock for consumption message testing
        /// </summary>
        private static readonly object messageLock = new object();
        /// <summary>
        /// Client JSON mixed binary message client consumer example
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage> node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            messages.Clear();
            for (char message = 'A'; message <= 'Z'; ++message)
            {
                Data.TestClass messageData = new Data.TestClass { Int = message, String = message.ToString() };
                messages.Add(message, messageData);

                result = await node.AppendMessage(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage.JsonSerialize(messageData));
                if (!result.IsSuccess)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
            }

            using (ServerByteArrayMessageJsonConsumer consumer = new ServerByteArrayMessageJsonConsumer(CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.ClientCache.Client, node))
            {
                #region Wait for the test message to complete
                long timeout = Stopwatch.GetTimestamp() + AutoCSer.Date.GetTimestampBySeconds(10);
                while (messages.Count != 0)
                {
                    if (timeout < Stopwatch.GetTimestamp())
                    {
                        return AutoCSer.Breakpoint.ReturnFalse();
                    }
                    await Task.Delay(1);
                }
                #endregion
            }

            return true;
        }
    }
```
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessageStringConsumer](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/ServerByteArrayMessageStringConsumer.cs) is the encapsulation of the client's string message, and [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.OnServerByteArrayMessageStringConsumer](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/OnServerByteArrayMessageStringConsumer.cs) is the overloaded encapsulation that uses the delegate substitution method onMessage. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/Message/ServerByteArrayMessageStringConsumer.cs) is as follows:
``` csharp
    /// <summary>
    /// Client string message client consumer example
    /// </summary>
    internal sealed class ServerByteArrayMessageStringConsumer : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessageStringConsumer
    {
        /// <summary>
        /// Client string message client consumer example
        /// </summary>
        /// <param name="commandClient">Command client</param>
        /// <param name="node">Server-side byte array messages client nodes</param>
        internal ServerByteArrayMessageStringConsumer(AutoCSer.Net.CommandClient commandClient, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage> node) : base(commandClient, node, 1 << 10) { }
        /// <summary>
        /// Message processing. An exception also indicates that the message execution failed
        /// </summary>
        /// <param name="message"></param>
        /// <returns>Whether the message was executed successfully</returns>
        protected override Task<bool> onMessage(string? message)
        {
            lock (messageLock) messages.Remove(message.AutoCSerClassGenericTypeExtensions().NotNull());
            return AutoCSer.Common.GetCompletedTask(true);
        }

        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateServerByteArrayMessageNode(nameof(ServerByteArrayMessageStringConsumer)));
        /// <summary>
        /// Message collection not completed
        /// </summary>
        private static HashSet<string> messages = new HashSet<string>();
        /// <summary>
        /// Access lock for consumption message testing
        /// </summary>
        private static readonly object messageLock = new object();
        /// <summary>
        /// Client string message client consumer example
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage> node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            messages.Clear();
            for (char message = 'A'; message <= 'Z'; ++message)
            {
                string messageData = message.ToString();
                messages.Add(messageData);

                result = await node.AppendMessage(messageData);
                if (!result.IsSuccess)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
            }

            using (ServerByteArrayMessageStringConsumer consumer = new ServerByteArrayMessageStringConsumer(CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.ClientCache.Client, node))
            {
                #region Wait for the test message to complete
                long timeout = Stopwatch.GetTimestamp() + AutoCSer.Date.GetTimestampBySeconds(10);
                while (messages.Count != 0)
                {
                    if (timeout < Stopwatch.GetTimestamp())
                    {
                        return AutoCSer.Breakpoint.ReturnFalse();
                    }
                    await Task.Delay(1);
                }
                #endregion
            }

            return true;
        }
    }
```
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessageConsumer](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/ServerByteArrayMessageConsumer.cs) is the encapsulation of the byte[] message, and [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.OnServerByteArrayMessageConsumer](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/Message/OnServerByteArrayMessageConsumer.cs) is the overloaded encapsulation using the proxy substitution method onMessage. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/Message/ServerByteArrayMessageStringConsumer.cs) is as follows:
``` csharp
    /// <summary>
    /// Example of the byte[] message client consumer
    /// </summary>
    internal sealed class ServerByteArrayMessageConsumer : AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessageConsumer
    {
        /// <summary>
        /// Example of the byte[] message client consumer
        /// </summary>
        /// <param name="commandClient">Command client</param>
        /// <param name="node">Server-side byte array messages client nodes</param>
        internal ServerByteArrayMessageConsumer(AutoCSer.Net.CommandClient commandClient, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage> node) : base(commandClient, node, 1 << 10) { }
        /// <summary>
        /// Message processing. An exception also indicates that the message execution failed
        /// </summary>
        /// <param name="message"></param>
        /// <returns>Whether the message was executed successfully</returns>
        protected override Task<bool> onMessage(byte[]? message)
        {
            lock (messageLock) messages.Remove(message.AutoCSerClassGenericTypeExtensions().NotNull()[0]);
            return AutoCSer.Common.GetCompletedTask(true);
        }

        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateServerByteArrayMessageNode(nameof(ServerByteArrayMessageConsumer)));
        /// <summary>
        /// Message collection not completed
        /// </summary>
        private static Dictionary<int, byte[]> messages = new Dictionary<int, byte[]>();
        /// <summary>
        /// Access lock for consumption message testing
        /// </summary>
        private static readonly object messageLock = new object();
        /// <summary>
        /// Example of the byte[] message client consumer
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNodeClientNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArrayMessage> node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }

            messages.Clear();
            for (char message = 'A'; message <= 'Z'; ++message)
            {
                byte[] messageData = new byte[] { (byte)message };
                messages.Add(message, messageData);

                result = await node.AppendMessage(messageData);
                if (!result.IsSuccess)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
            }

            using (ServerByteArrayMessageConsumer consumer = new ServerByteArrayMessageConsumer(CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.ClientCache.Client, node))
            {
                #region Wait for the test message to complete
                long timeout = Stopwatch.GetTimestamp() + AutoCSer.Date.GetTimestampBySeconds(10);
                while (messages.Count != 0)
                {
                    if (timeout < Stopwatch.GetTimestamp())
                    {
                        return AutoCSer.Breakpoint.ReturnFalse();
                    }
                    await Task.Delay(1);
                }
                #endregion
            }

            return true;
        }
    }
```
## 4. Distributed lock
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDistributedLockNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/DistributedLock/IDistributedLockNode.cs) is a distributed lock node type, and T must implement the IEquatable<T> interface. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/DistributedLockNode.cs) is as follows:
``` csharp
    /// <summary>
    /// Example of distributed lock client node
    /// </summary>
    internal static class DistributedLockNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDistributedLockNodeClientNode<string>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateDistributedLockNode<string>(nameof(DistributedLockNode)));
        /// <summary>
        /// Example of distributed lock client node
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDistributedLockNodeClientNode<string> node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();

            string lockKey = AutoCSer.Random.Default.Next().AutoCSerExtensions().ToString();
            Task<bool>[] tasks = new Task<bool>[Math.Max(AutoCSer.Common.ProcessorCount, 4)];
            for (int index = 0; index != tasks.Length; ++index) tasks[index] = test(node, lockKey, 1 << 10);
            foreach (Task<bool> task in tasks)
            {
                bool result = await task;
                if (!result) return false;
            }

            return true;
        }
        /// <summary>
        /// Distributed lock concurrent error check data
        /// </summary>
        private static int checkLock;
        /// <summary>
        /// Example of distributed lock client node
        /// </summary>
        /// <param name="node"></param>
        /// <param name="lockKey"></param>
        /// <param name="loopCount"></param>
        /// <returns></returns>
        private static async Task<bool> test(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDistributedLockNodeClientNode<string> node, string lockKey, int loopCount)
        {
            await AutoCSer.Threading.SwitchAwaiter.Default;
            for (int count = loopCount; count != 0; --count)
            {
                var identity = await node.Enter(lockKey, 5);
                if (!identity.IsSuccess)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
                if (System.Threading.Interlocked.Increment(ref checkLock) != 1)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
                if (System.Threading.Interlocked.Decrement(ref checkLock) != 0)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
                node.Release(lockKey, identity.Value).Discard();
            }
            return true;
        }
    }
```
## 5. Multi-hash bitmap filtering
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IManyHashBitMapFilterNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ManyHashBitMapFilter/IManyHashBitMapFilterNode.cs) is functionally similar to a Bloom filter. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/ManyHashBitMapFilterNode.cs) is as follows:
``` csharp
    /// <summary>
    /// Multi-hash bitmap filtering node client example
    /// </summary>
    internal static class ManyHashBitMapFilterNode
    {
        /// <summary>
        /// Test the bitmap size (number of bits)
        /// </summary>
        private static readonly int size = new Algorithm.ManyHashBitMapCapacity(1 << 10, 2).GetHashCapacity();
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ManyHashBitMapFilter<string> client = new AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ManyHashBitMapFilter<string>(CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateManyHashBitMapFilterNode(nameof(ManyHashBitMapFilterNode), size)), size, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ManyHashBitMapFilter.GetHashCode2);
        /// <summary>
        /// Multi-hash bitmap filtering node client example
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var result = await client.Set("AAA");
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var boolResult = await client.Check("AAA");
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IManyHashBitMapClientFilterNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ManyHashBitMapFilter/IManyHashBitMapClientFilterNode.cs) **directly performs detection operations** on the client by pushing bitmap information to the client in real time through the server, which is suitable for bitmaps with smaller capacity. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/ManyHashBitMapClientFilterNode.cs) is as follows:
``` csharp
    /// <summary>
    /// An example of the multi-hash bitmap client synchronously filtering node client
    /// </summary>
    internal static class ManyHashBitMapClientFilterNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ManyHashBitMapClientFilter<string> client = new AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ManyHashBitMapClientFilter<string>(CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateManyHashBitMapClientFilterNode(nameof(ManyHashBitMapClientFilterNode), new Algorithm.ManyHashBitMapCapacity(1 << 10).GetHashCapacity())), AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ManyHashBitMapClientFilter.GetHashCode4);
        /// <summary>
        /// An example of the multi-hash bitmap client synchronously filtering node client
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var result = await client.Set("AAA");
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var boolResult = client.Check("AAA");
            Console.WriteLine($"{result.IsSuccess} {boolResult}");
            return true;
        }
    }
```
## 6. Total statistics based on uniform probability
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IUniformProbabilityTotalStatisticsNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/UniformProbabilityTotalStatistics/IUniformProbabilityTotalStatisticsNode.cs) is functionally similar to HyperLogLog. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/UniformProbabilityTotalStatisticsNode.cs) is as follows:
``` csharp
    /// <summary>
    /// A client example of a total statistics node based on uniform probability
    /// </summary>
    internal static class UniformProbabilityTotalStatisticsNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IUniformProbabilityTotalStatisticsNodeClientNode> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateUniformProbabilityTotalStatisticsNode(nameof(UniformProbabilityTotalStatisticsNode), 8));
        /// <summary>
        /// A client example of a total statistics node based on uniform probability
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IUniformProbabilityTotalStatisticsNodeClientNode node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Append(AutoCSer.Random.Default.NextULong());
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var countResult = await node.Count();
            if (!countResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IUniformProbabilityClientStatisticsNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/UniformProbabilityTotalStatistics/IUniformProbabilityClientStatisticsNode.cs) **directly performs detection and statistical operations** on the client by pushing statistical data in real time from the server to the client. This method is suitable for scenarios with a small number of indexes. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/UniformProbabilityClientStatisticsNode.cs) is as follows:
``` csharp
    /// <summary>
    /// An example of a client-side synchronous total statistics node client based on uniform probability
    /// </summary>
    internal static class UniformProbabilityClientStatisticsNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabase.UniformProbabilityClientStatistics client = new AutoCSer.CommandService.StreamPersistenceMemoryDatabase.UniformProbabilityClientStatistics(CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateUniformProbabilityClientStatisticsNode(nameof(UniformProbabilityClientStatisticsNode), 8)));
        /// <summary>
        /// An example of a client-side synchronous total statistics node client based on uniform probability
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var result = await client.Append(AutoCSer.Random.Default.NextULong());
            Console.WriteLine($"{result.IsSuccess} {client.Count()}");
            return true;
        }
    }
```
## 7. Balanced tree
### 7.1 Binary search tree dictionary
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISearchTreeDictionaryNode<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ISearchTreeDictionaryNode.cs) is a generic encapsulation of the balanced tree [AutoCSer.SearchTree.Dictionary<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Extensions/SearchTree/Dictionary.cs), and KT must implement the IComparable<KT> interface. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/SearchTreeDictionaryNode.cs) is as follows:
``` csharp
    /// <summary>
    /// Example of balanced tree client node
    /// </summary>
    internal static class SearchTreeDictionaryNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISearchTreeDictionaryNodeClientNode<int, Data.TestClass>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateSearchTreeDictionaryNode<int, Data.TestClass>(nameof(SearchTreeDictionaryNode)));
        /// <summary>
        /// Example of balanced tree client node
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISearchTreeDictionaryNodeClientNode<int, Data.TestClass> node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var boolResult = await node.TryAdd(2, new Data.TestClass { Int = 2 });
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.ContainsKey(2);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Set(1, new Data.TestClass { Int = 1 });
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Set(4, new Data.TestClass { Int = 4 });
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Set(3, new Data.TestClass { Int = 3 });
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var valueResult = await node.TryGetValue(3);
            if (!valueResult.IsSuccess || valueResult.Value.Value?.Int != 3)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            valueResult = await node.TryGetValueByIndex(1);
            if (!valueResult.IsSuccess || valueResult.Value.Value?.Int != 2)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            valueResult = await node.TryGetFirstValue();
            if (!valueResult.IsSuccess || valueResult.Value.Value?.Int != 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            valueResult = await node.TryGetLastValue();
            if (!valueResult.IsSuccess || valueResult.Value.Value?.Int != 4)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var intResult = await node.IndexOf(2);
            if (!intResult.IsSuccess || intResult.Value != 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var keyResult = await node.TryGetFirstKey();
            if (!keyResult.IsSuccess || keyResult.Value.Value != 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            keyResult = await node.TryGetLastKey();
            if (!keyResult.IsSuccess || keyResult.Value.Value != 4)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            intResult = await node.CountLess(3);
            if (!intResult.IsSuccess || intResult.Value != 2)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            intResult = await node.CountThan(3);
            if (!intResult.IsSuccess || intResult.Value != 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var valuesResult = await node.GetValues(1, 2);
            if (!valuesResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            int checkKey = 2;
            await foreach (var value in valuesResult.GetAsyncEnumerable())
            {
                if (!value.IsSuccess)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
                if (checkKey == 4)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
                if (value.Value.Value?.Int != checkKey)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
                ++checkKey;
            }
            return true;
        }
    }
```
### 7.2 Binary search tree set
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISearchTreeSetNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ISearchTreeSetNode.cs) is a generic encapsulation of the balanced tree [AutoCSer.SearchTree.Set<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Extensions/SearchTree/Set.cs), and KT must implement the IComparable<KT> interface. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/SearchTreeSetNode.cs) is as follows:
``` csharp
    /// <summary>
    /// Example of balanced tree client node
    /// </summary>
    internal static class SearchTreeSetNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISearchTreeSetNodeClientNode<int>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateSearchTreeSetNode<int>(nameof(SearchTreeSetNode)));
        /// <summary>
        /// Example of balanced tree client node
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISearchTreeSetNodeClientNode<int> node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var boolResult = await node.Add(2);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Contains(2);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Add(1);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Add(4);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Add(3);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var valueResult = await node.GetByIndex(1);
            if (!valueResult.IsSuccess || valueResult.Value.Value != 2)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            valueResult = await node.GetFrist();
            if (!valueResult.IsSuccess || valueResult.Value.Value != 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            valueResult = await node.GetLast();
            if (!valueResult.IsSuccess || valueResult.Value.Value != 4)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var intResult = await node.IndexOf(2);
            if (!intResult.IsSuccess || intResult.Value != 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            intResult = await node.CountLess(3);
            if (!intResult.IsSuccess || intResult.Value != 2)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            intResult = await node.CountThan(3);
            if (!intResult.IsSuccess || intResult.Value != 1)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
### 7.3 Sorted dictionary
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISortedDictionaryNode<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ISortedDictionaryNode.cs) is a generic encapsulation of System.Collections.Generic.SortedDictionary<KT, VT>, and KT must implement the IComparable<KT> interface.  
Although System.Collections.Generic.SortedDictionary<KT, VT> encapsulates red-black tree logic internally, the provided API can only be used as a dictionary. Its advantage is that there is no scalability issue, so the performance is stable. However, its disadvantages are that it will cause memory fragmentation and occupy more memory, and the random memory access of O(log(n)) will result in low throughput performance. [Click to view the client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/SortedDictionaryNode.cs).
### 7.4 Sorted set
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISortedSetNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ISortedSetNode.cs) is a generic encapsulation of System.Collections.Generic.SortedSet<KT, VT>, and KT must implement the IComparable<KT> interface.  
The internal encapsulation of System.Collections.Generic.SortedSet<KT, VT> is also a red-black tree logic, but the provided API can basically only be used as a hash table. The advantage is that there is no scalability issue, so the performance is stable. The disadvantage is that it will cause memory fragmentation and occupy more memory, and the random memory access of O(log(n)) will result in low throughput performance. [Click to view the client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/SortedSetNode.cs).
## 8. Hash table
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashSetNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IHashSetNode.cs) is a generic encapsulation of the hash table, and T must implement the IEquatable<T> interface. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/HashSetNode.cs) is as follows:
``` csharp
    /// <summary>
    /// Example of a hash table client node
    /// </summary>
    internal static class HashSetNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashSetNodeClientNode<int>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateHashSetNode<int>(nameof(HashSetNode)));
        /// <summary>
        /// Example of a hash table client node
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashSetNodeClientNode<int> node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var boolResult = await node.Add(2);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Contains(2);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            boolResult = await node.Remove(2);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IFragmentHashSetNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IFragmentHashSetNode.cs) is a generic encapsulation of the fragment hash table, and T must implement the IEquatable<T> interface. [Click to view the client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/FragmentHashSetNode.cs).
## 9. Queue
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IQueueNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IQueueNode.cs) is a generic encapsulation of System.Collections.Generic.Queue<T>. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/QueueNode.cs) is as follows:
``` csharp
    /// <summary>
    /// Example of a generic queue client node
    /// </summary>
    internal static class QueueNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IQueueNodeClientNode<int>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateQueueNode<int>(nameof(QueueNode)));
        /// <summary>
        /// Example of a generic queue client node
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IQueueNodeClientNode<int> node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            result = await node.Enqueue(2);
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var boolResult = await node.Contains(2);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var valueResult = await node.TryDequeue();
            if (!valueResult.IsSuccess || valueResult.Value.Value != 2)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
The data of [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayQueueNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IByteArrayQueueNode.cs) is encapsulated in a server-side byte array. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/ByteArrayQueueNode.cs) is as follows:
``` csharp
    /// <summary>
    /// Example of byte[] queue client node
    /// </summary>
    internal static class ByteArrayQueueNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayQueueNodeClientNode> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateByteArrayQueueNode(nameof(ByteArrayQueueNode)));
        /// <summary>
        /// Example of byte[] queue client node
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayQueueNodeClientNode node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            result = await node.Enqueue(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.JsonSerialize(new Data.TestClass { Int = 2 }));
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var valueResult = await node.TryDequeueJsonDeserialize<Data.TestClass>();
            if (!valueResult.IsSuccess || valueResult.Value?.Int != 2)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
## 10. Stack
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IStackNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IStackNode.cs) is a generic encapsulation of System.Collections.Generic.Stack<T>. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/StackNode.cs) is as follows:
``` csharp
    /// <summary>
    /// Generic stack client node example
    /// </summary>
    internal static class StackNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IStackNodeClientNode<int>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateStackNode<int>(nameof(StackNode)));
        /// <summary>
        /// Generic stack client node example
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IStackNodeClientNode<int> node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            result = await node.Push(2);
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var boolResult = await node.Contains(2);
            if (!boolResult.Value)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var valueResult = await node.TryPop();
            if (!valueResult.IsSuccess || valueResult.Value.Value != 2)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
The data of [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayStackNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IByteArrayStackNode.cs) is encapsulated in a server-side byte array. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/ByteArrayStackNode.cs) is as follows:
``` csharp
    /// <summary>
    /// Example of byte[] stack client node
    /// </summary>
    internal static class ByteArrayStackNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayStackNodeClientNode> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateByteArrayStackNode(nameof(ByteArrayStackNode)));
        /// <summary>
        /// Example of byte[] stack client node
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayStackNodeClientNode node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Clear();
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            result = await node.Push(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray.JsonSerialize(new Data.TestClass { Int = 2 }));
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            var valueResult = await node.TryPopJsonDeserialize<Data.TestClass>();
            if (!valueResult.IsSuccess || valueResult.Value?.Int != 2)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            return true;
        }
    }
```
## 11. Array
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IArrayNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IArrayNode.cs) is a generic encapsulation of T[]. [Click to view the client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/ArrayNode.cs).  
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ILeftArrayNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ILeftArrayNode.cs) is a generic encapsulation of [AutoCSer.LeftArray<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/LeftArray.cs) and functions similarly to System.Collections.Generic.List<T>. [Click to view the client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/LeftArrayNode.cs).  
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISortedListNode<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ISortedListNode.cs) is a generic encapsulation of the keyword sorted array System.Collections.Generic.SortedList<KT, VT>, and KT must implement the IComparable<KT> interface. [Click to view the client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/SortedListNode.cs).
## 12. Bitmap
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IBitmapNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IBitmapNode.cs) is a binary bitmap node. [Click to view the client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/BitmapNode.cs).
## 13. Auto-increment ID
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IIdentityGeneratorNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IIdentityGeneratorNode.cs) is a simple 64-bit auto-increment ID generation node. [Click to view the client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/IdentityGeneratorNode.cs).
## 14. Archive-only
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IOnlyPersistenceNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/IOnlyPersistenceNode.cs) is a generic wrapper used for **quickly archiving** large amounts of concurrent data **without modifying memory data or defining snapshot operations**. The [client sample code](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/Client/OnlyPersistenceNode.cs) is as follows:
``` csharp
    /// <summary>
    /// Example of an archive-only data client
    /// </summary>
    internal static class OnlyPersistenceNode
    {
        /// <summary>
        /// Client node singleton
        /// </summary>
        private static readonly AutoCSer.CommandService.StreamPersistenceMemoryDatabaseClientNodeCache<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IOnlyPersistenceNodeClientNode<Data.TestClass>> nodeCache = CommandClientSocketEvent.StreamPersistenceMemoryDatabaseClientCache.CreateNode(client => client.GetOrCreateOnlyPersistenceNode<Data.TestClass>(nameof(OnlyPersistenceNode)));
        /// <summary>
        /// Example of an archive-only data client
        /// </summary>
        /// <returns></returns>
        internal static async Task<bool> Test()
        {
            var nodeResult = await nodeCache.GetNode();
            if (!nodeResult.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IOnlyPersistenceNodeClientNode<Data.TestClass> node = nodeResult.Value.AutoCSerClassGenericTypeExtensions().NotNull();
            var result = await node.Save(AutoCSer.RandomObject.Creator<Data.TestClass>.CreateNotNull());
            if (!result.IsSuccess)
            {
                return AutoCSer.Breakpoint.ReturnFalse();
            }
            node.SaveSendOnly(AutoCSer.RandomObject.Creator<Data.TestClass>.CreateNotNull()).Discard();
            return true;
        }
    }
```
The code of this project is **only for testing**. In practical scenarios, the database configuration [AutoCSer.CommandService.StreamPersistenceMemoryDatabaseServiceConfig](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Server/StreamPersistenceMemoryDatabaseServiceConfig.cs).PersistenceType should be set to **OnlyPersistence**. This setting enables a quick reconstruction of persistence when the database restarts to **avoid loading historical data**, for example:
``` csharp
            AutoCSer.Document.MemoryDatabaseNode.Server.ServiceConfig databaseServiceConfig = new AutoCSer.Document.MemoryDatabaseNode.Server.ServiceConfig
            {
                PersistencePath = Path.Combine(AutoCSer.TestCase.Common.Config.AutoCSerTemporaryFilePath, nameof(AutoCSer.Document.MemoryDatabaseNode)),
                PersistenceSwitchPath = Path.Combine(AutoCSer.TestCase.Common.Config.AutoCSerTemporaryFilePath, nameof(AutoCSer.Document.MemoryDatabaseNode) + nameof(AutoCSer.Document.MemoryDatabaseNode.Server.ServiceConfig.PersistenceSwitchPath)),
                PersistenceType = AutoCSer.CommandService.StreamPersistenceMemoryDatabase.PersistenceTypeEnum.OnlyPersistence
            };
```
## 15. Distributed search
[AutoCSer.CommandService.Search.StaticTrieGraph.IStaticTrieGraphNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/Search/StaticTrieGraph/IStaticTrieGraphNode.cs) is a Trie graph node used to manage search word segmentation and provide word segmentation query functionality.  
[AutoCSer.CommandService.Search.IWordIdentityBlockIndexNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/Search/WordIdentityBlockIndex/IWordIdentityBlockIndexNode.cs) is a generic encapsulation of the disk block index information node of the word segmentation result. T must implement the IEquatable<T> interface to manage the word segmentation result data of the search target object based on the disk block function.  
[AutoCSer.CommandService.Search.DiskBlockIndex.IRemoveMarkHashIndexNode<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/Search/DiskBlockIndex/IRemoveMarkHashIndexNode.cs) is a generic encapsulation of a hash index node. KT must implement the IEquatable<KT> interface, and VT must implement the IEquatable<VT> interface to manage inverted index data based on the disk block function.  
[AutoCSer.CommandService.Search.DiskBlockIndex.IRemoveMarkHashKeyIndexNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/Search/DiskBlockIndex/IRemoveMarkHashKeyIndexNode.cs) is a generic encapsulation of a hash index node with the int/uint keyword. T must implement the IEquatable<T> interface to manage inverted index data based on the disk block function.  
[AutoCSer.CommandService.Search.MemoryIndex.IHashIndexNode<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/Search/MemoryIndex/IHashIndexNode.cs) is a generic encapsulation of a hash index node. KT must implement the IEquatable<KT> interface, and VT must implement the IEquatable<VT> interface to manage inverted index data in memory search patterns.  
[AutoCSer.CommandService.Search.MemoryIndex.IHashCodeKeyIndexNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/Search/MemoryIndex/IHashCodeKeyIndexNode.cs) is a generic encapsulation of a hash index node with the int/uint keyword, and T must implement the IEquatable<T> interface to manage inverted index data in memory search patterns.  
[AutoCSer.CommandService.Search.IConditionDataNode<KT, VT>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/Search/ConditionData/IConditionDataNode.cs) is a generic encapsulated node, and KT must implement the IEquatable<KT> interface to manage non-indexed conditional query data.
## 16. Operation and maintenance tools
[AutoCSer.CommandService.IDeployTaskNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/DeployTask/IDeployTaskNode.cs) is a deployment task management node used for the deployment operations of AutoCSer applications.  
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IProcessGuardNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ProcessGuard/IProcessGuardNode.cs) is a process daemon management node used to guard the local AutoCSer application and handle the release switching processes with the AutoCSer service.  
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IServerRegistryNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/ServerRegistry/IServerRegistryNode.cs) is a service registration management node, used for the [registration management of AutoCSer services and the push operation of service information](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/10.ServerRegistry/10.ServerRegistry.Eng.md).  
[AutoCSer.CommandService.InterfaceRealTimeCallMonitor.IExceptionStatisticsNode](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/InterfaceRealTimeCallMonitor/ExceptionStatistics/IExceptionStatisticsNode.cs) is an API exception call statistics information node, used to collect API call exception information received by the AutoCSer real-time call monitoring service.
## 17. Others 
[AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CustomNode.ITimeoutMessageNode<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Node/CustomNode/TimeoutMessage/ITimeoutMessageNode.cs) is a timeout task message processing node that can be used for distributed transaction data consistency checking operations.
# [Custom node](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/08.MemoryDatabaseCustomNode.Eng.md)