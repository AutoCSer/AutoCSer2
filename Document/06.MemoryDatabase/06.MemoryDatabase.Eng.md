# In-memory databases that support object-oriented programming
AutoCSer has built-in an extensible [in-memory database component](https://github.com/AutoCSer/AutoCSer2/tree/main/Application/StreamPersistenceMemoryDatabase) that **supports object-oriented programming** and is implemented based on the secondary encapsulation of AutoCSer RPC. It supports **reliable persistence** and has the performance characteristics of **high concurrency and high throughput**.  
AutoCSer in-memory database accesses persistent data in a truly object-oriented programming way, **directly manipulating in-memory data** without the need for traditional database operations such as SQL/ORM and explicit transaction logic. It is highly suitable for applications with **small amounts of valid data** or prototype Demo development.  
When many people think of in-memory databases, the first thing that comes to mind is the Redis K-V **cache component**. So, let's understand this database component by looking at the main differences between the AutoCSer in-memory database and Redis.
# Reliable persistence
Redis supports two persistence strategies: snapshot and AOF. However, neither of them can prevent **data loss** in scenarios with high throughput performance requirements, leading a large number of developers to have the **wrong notion** that high-throughput in-memory databases cannot provide reliable persistence features.  
Because Redis is positioned as a caching component **rather than a database component**. Of course, there are also some developers who use Redis as a database because unexpected downtime is generally a **low-probability event**, and in some special real-world scenarios, losing some data may be allowed.  
AutoCSer in-memory database is a database component **specifically designed for high-concurrency scenarios**, supporting both **reliable persistence** and **high throughput performance**. Due to its relatively simple persistence strategy, from the perspective of implementation difficulty, it is **easier to ensure reliability compared** to the persistence of traditional relational databases.  
AutoCSer **sacrifices the latency metric of serial responses** for the reliability of persistence. The persistence API first flushes the request data to the storage device, and then executes the API and returns the execution result to the client. That is to say, when the client receives a successful response, the request data has already been flushed to the storage device. So there is no problem of data loss.  
Sacrificing the delay metric of serial responses will result in some loss of throughput performance in low-concurrency scenarios. However, in **high-concurrency scenarios**, the **batch operation characteristics** can be utilized to optimize **throughput performance and overall delay metrics**. The support of AutoCSer RPC for high-concurrency and high-throughput performance is based on this principle.  
The simple AOF mode will cause the persistent file to continuously expand, and the hard disk space resources cannot be released. **The cold start delay of the database is directly proportional to the size of the persistent file**. Therefore, AutoCSer supports triggering the snapshot mode **persistent reconstruction** operation by default after the **file size doubles** to avoid the file from expanding without limit.  
AutoCSer's persistence adopts a **hybrid mode of snapshots and AOF**. The first part of the persistence file is the snapshot data generated during the persistence reconstruction, while the subsequent part is the new persistence API request data generated after the snapshot operation. They are written in batches to the storage device in the AOF mode to achieve high throughput performance in high-concurrency scenarios.  
Of course, AutoCSer allows the persistence function to be disabled and can also be used as a cache component without an expiration time limit. If there is a need for cache eviction, developers need to use extensible object-oriented programming support to [implement the relevant data structures and algorithm logic by themselves](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/08.MemoryDatabaseCustomNode.Eng.md).
# Strong consistency
Due to the unreliability issue of Redis's persistence mechanism, Redis is usually used as a caching component of traditional databases, and the reliability of persistent data is guaranteed by traditional databases. This gives rise to the **problem of data consistency** in distributed systems.  
Leaving aside the unreliability issue of Redis persistence, using Redis as a caching component for traditional databases not only fails to guarantee strong data consistency but also **lacks a simple solution for eventual consistency**. For instance, the commonly used delayed double deletion strategy merely reduces the probability of problems occurring.  
The AutoCSer in-memory database can be used as an **independent database component**. The in-memory data state is the result of the sequential execution of persistent request data in memory. The two have a **strong consistency** relationship, so there is no data consistency problem in distributed systems.  
Each call to a persistent API can be regarded as a **complete database transaction operation**, equivalent to a combination of the stored procedures and transactions in a traditional relational database. The single-threaded queue execution logic does **not need to be concerned with thread safety issues**.
# Extensible support for object-oriented programming
Redis is a **functional closed** component that is difficult to customize and extend. Although it has a large number of commonly used data structures built-in, the fixed built-in data structures can only adapt to some **simple demand** scenarios. Although Lua transaction operations can expand the adaptation scenarios of Redis, they are powerless when it comes to real complex and personalized demand scenarios.  
The AutoCSer in-memory database is **scalable and supports object-oriented programming**, allowing developers to implement any data structure and API business logic using C# in the form of [custom nodes](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/08.MemoryDatabaseCustomNode.Eng.md) based on real business requirements. Of course, this not only requires developers to have sufficient knowledge of **data structures and algorithms**, but also to be capable of ensuring the **correctness and certainty** of custom logic.  
Ensuring the correctness of custom logic, I believe, should be a **basic requirement for every qualified developer**. Even if developers do not use AutoCSer, they still need to guarantee the correctness of the logic related to data persistence in business systems.  
Ensuring the determinism of custom logic means that for the same in-memory business data state, after executing the same persistent API request data, the same result of executing the in-memory data state should be obtained. In other words, it is necessary to ensure that the **execution logic of the persistent API is replayable**. When the database service restarts, the request data of these persistence apis need to be executed sequentially to restore the state of the in-memory data.  
Of course, AutoCSer also has [built-in support for some simple and commonly used data structures](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/07.MemoryDatabaseNode.Eng.md), mainly including dictionaries, messages, distributed locks, balanced binary trees, hash tables, hash filtering, queues, stacks, bitmaps, arrays, and AutoCSer operation and maintenance tool components, etc. It can also serve as a reference example for custom nodes.
# Support local embedding mode
AutoCSer in-memory database supports [local embedding mode](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/09.MemoryDatabaseLocalService/09.MemoryDatabaseLocalService.Eng.md), which can [support .NET NativeAOT](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/12.NativeAOT/12.NativeAOT.Eng.md) and has no network interaction consumption of RPC calls. Parameters of non-persistent apis also do not need to support serialization operations.  
The local embedding mode can provide better concurrent throughput performance and can be used for the business data logic of in-game services that have both high throughput performance and reliable persistence requirements.
# API Hot Update (Local embedding mode not supported)
Since the cold start operation of the in-memory database requires reading the entire persistent file data to restore the in-memory data state, the **service restart operation should be avoided as much as possible**.  
However, in a custom node requirement environment, it is very easy for operations such as adding new apis or repairing existing ones to occur. To reduce the probability of service restarts caused by these requirements, AutoCSer provides two apis, [BindNodeMethod and RepairNodeMethod](https://github.com/AutoCSer/AutoCSer2/blob/main/Application/StreamPersistenceMemoryDatabase/Client/IStreamPersistenceMemoryDatabaseClient.cs), for adding and repairing API operations.  
This feature dynamically loads assemblies carrying repair apis through System.Reflection.Assembly.Load(byte[] rawAssembly), allowing for the addition of new data definitions but **not supporting the modification of any existing data structures and data definitions**.  
Note: In a production environment, for persistent apis, it is generally not allowed to perform API repair operations, as such operations can easily **disrupt the determinism of the execution logic**, potentially causing the execution process before and after the database restart to be inconsistent with the final state of the in-memory data.
# Quasi-real-time backup (local embedding mode not supported)
Although the persistence of the AutoCSer in-memory database is reliable, after the data persistence operation, the storage device may be damaged or fail, causing the persistent files to become unusable. At this time, the [persistence backup](https://github.com/AutoCSer/AutoCSer2/tree/main/TestCase/StreamPersistenceMemoryDatabase/Backuper) function is needed to reduce the probability of the database being irreparable due to file damage.  
After the AutoCSer in-memory database persists the data and the request execution is completed, it will immediately attempt to trigger the backup operation of the persisted data. Therefore, under normal circumstances, except for network delay, it is basically a real-time backup operation. Due to network latency, the persistent backup function cannot guarantee the integrity of data in unexpected scenarios in extreme environments.
# Cross-language calls are not supported
Redis has a rich ecosystem, with client implementations for various mainstream languages, so there is basically no issue of language ecosystem isolation. Of course, this has also led to the problem of uneven quality of Redis clients. For instance, the vast majority of open-source [.NET clients have serious concurrent throughput performance issues](https://github.com/AutoCSer/AutoCSer2/tree/main/TestCase/ThirdParty/GrpcClientPerformance).  
Since AutoCSer RPC does not support cross-language calls (although simple requirements can encapsulate the client through [.NET NativeAOT](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/12.NativeAOT/12.NativeAOT.Eng.md)), and the in-memory database implemented based on it does not support cross-language calls either, AutoCSer is only suitable for the pure.NET technology stack.
# [Built-in data structure node](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/07.MemoryDatabaseNode/07.MemoryDatabaseNode.Eng.md)