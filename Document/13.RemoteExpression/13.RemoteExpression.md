# 远程 Lambda 表达式
RPC 调用传参通常为数据，而**不支持逻辑**。因为不论从安全还是性能的角度考虑，服务端 API 逻辑都应该在代码中写死，不允许存在**不明确的逻辑行为**。  
AutoCSer RPC 通过[封装 Lambda 表达式](https://github.com/AutoCSer/AutoCSer2/tree/main/AutoCSer/Extensions/Net/CommandServer/RemoteExpression)的序列化操作，利用 **Lambda 表达式的 JIT 能力**提供了一些简单的逻辑传参支持，所以该功能**不支持 .NET NativeAOT**，而且要求服务端也同时引用了**表达式涉及相关数据类型**定义的程序集。  
由于 Lambda 表达式可能由许多小对象组成，而且序列化操作涉及反射以及结构体的装箱与拆箱操作，可能会造成数量级以上的吞吐性能差异，**不建议在非必要的场景中使用它**。  
从安全角度来说，对于服务端而言，由于客户端构造的 Lambda 表达式中允许存在不明确的逻辑行为，所以只有在构造 Lambda 表达式的**客户端在完全可信任的场景中**才能够使用它。  
由于该功能属于非常用的特殊场景功能，所以它被封装在[扩展项目](https://github.com/AutoCSer/AutoCSer2/tree/main/AutoCSer/Extensions)中，需要**手动引用该项目**。
# 支持 8 种委托定义
## 1. 无返回值委托
System.Action 对应的传参类型为 [AutoCSer.Net.CommandServer.RemoteExpressionAction](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Extensions/Net/CommandServer/RemoteExpression/RemoteExpressionAction.cs)  
System.Action<T> 对应的传参类型为 AutoCSer.Net.CommandServer.RemoteExpressionAction<T>  
System.Action<T1, T2> 对应的传参类型为 AutoCSer.Net.CommandServer.RemoteExpressionAction<T1, T2>  
System.Action<T1, T2, T3> 对应的传参类型为 AutoCSer.Net.CommandServer.RemoteExpressionAction<T1, T2, T3>
## 2. 返回值委托
System.Func<RT> 对应的传参类型为 [AutoCSer.Net.CommandServer.RemoteExpressionFunc<RT>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Extensions/Net/CommandServer/RemoteExpression/RemoteExpressionFunc.cs)  
System.Func<T, RT> 对应的传参类型为 AutoCSer.Net.CommandServer.RemoteExpressionFunc<T, RT>  
System.Func<T1, T2, RT> 对应的传参类型为 AutoCSer.Net.CommandServer.RemoteExpressionFunc<T1, T2, RT>  
System.Func<T1, T2, T3, RT> 对应的传参类型为 AutoCSer.Net.CommandServer.RemoteExpressionFunc<T1, T2, T3, RT>  
  
这些传参类型虽然对 Lambda 表达式封装了序列化逻辑，但是为了避免相关元数据序列化与反射的重复操作，序列化逻辑是依赖于实时的内存缓存数据的。所以这些传参是**不支持持久化**操作的，也就是说它不能用于内存数据库的持久化 API 的传参。
# 示例代码
## 1. 服务端配置
RPC 服务端配置必须[显式指定 IsRemoteExpression 为 true](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/13.RemoteExpression/Program.cs)。
``` csharp
            AutoCSer.Net.CommandServerConfig config = new AutoCSer.Net.CommandServerConfig
            {
                Host = new AutoCSer.Net.HostEndPoint((ushort)AutoCSer.TestCase.Common.CommandServerPortEnum.Document),
                IsRemoteExpression = true
            };
```
## 2. 服务端调用
服务端通过[调用 Lambda 表达式封装类型的 Call 方法](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/13.RemoteExpression/RemoteExpressionDelegateService.cs)或者 CallState 方法实现委托调用，实战中在调用 Call 方法之前应该通过属性 IsSuccess 或者方法 GetState() 确认反序列化操作的成功状态，避免系统抛出反序列化操作失败状态的异常。
``` csharp
    /// <summary>
    /// 远程表达式委托测试服务实例
    /// </summary>
    internal sealed class RemoteExpressionDelegateService : IRemoteExpressionDelegateService
    {
        /// <summary>
        /// 无参委托 Func{T} 测试 API
        /// </summary>
        /// <param name="func">远程表达式委托 Func{RT}</param>
        /// <returns></returns>
        int IRemoteExpressionDelegateService.Func(AutoCSer.Net.CommandServer.RemoteExpressionFunc<int> func)
        {
            return func.Call();
        }
        /// <summary>
        /// 委托 Func{T, RT} 测试 API
        /// </summary>
        /// <param name="func">远程表达式委托 Func{T, RT}</param>
        /// <param name="parameter"></param>
        /// <returns></returns>
        int IRemoteExpressionDelegateService.Func1(AutoCSer.Net.CommandServer.RemoteExpressionFunc<int, int> func, int parameter)
        {
            return func.Call(parameter);
        }
        /// <summary>
        /// 委托 Func{T1, T2, RT} 测试 API
        /// </summary>
        /// <param name="func">远程表达式委托 Func{T1, T2, RT}</param>
        /// <param name="parameter1"></param>
        /// <param name="parameter2"></param>
        /// <returns></returns>
        int IRemoteExpressionDelegateService.Func2(AutoCSer.Net.CommandServer.RemoteExpressionFunc<int, int, int> func, int parameter1, int parameter2)
        {
            return func.Call(parameter1, parameter2);
        }
        /// <summary>
        /// 委托 Func{T1, T2, T3, RT} 测试 API
        /// </summary>
        /// <param name="func">远程表达式委托 Func{T1, T2, T3, RT}</param>
        /// <param name="parameter1"></param>
        /// <param name="parameter2"></param>
        /// <param name="parameter3"></param>
        /// <returns></returns>
        int IRemoteExpressionDelegateService.Func3(AutoCSer.Net.CommandServer.RemoteExpressionFunc<int, int, int, int> func, int parameter1, int parameter2, int parameter3)
        {
            return func.Call(parameter1, parameter2, parameter3);
        }

        /// <summary>
        /// 委托 Action 测试 API
        /// </summary>
        /// <param name="action">远程表达式委托 Action</param>
        /// <returns></returns>
        int IRemoteExpressionDelegateService.Action(AutoCSer.Net.CommandServer.RemoteExpressionAction action)
        {
            action.Call();
            return ActionTarget.Default.Value;
        }
        /// <summary>
        /// 委托 Action{T} 测试 API
        /// </summary>
        /// <param name="action">远程表达式委托 Action{T}</param>
        /// <param name="parameter"></param>
        /// <returns></returns>
        int IRemoteExpressionDelegateService.Action1(AutoCSer.Net.CommandServer.RemoteExpressionAction<int> action, int parameter)
        {
            action.Call(parameter);
            return ActionTarget.Default.Value;
        }
        /// <summary>
        /// 委托 Action{T1, T2} 测试 API
        /// </summary>
        /// <param name="action">远程表达式委托 Action{T1, T2}</param>
        /// <param name="parameter1"></param>
        /// <param name="parameter2"></param>
        /// <returns></returns>
        int IRemoteExpressionDelegateService.Action2(AutoCSer.Net.CommandServer.RemoteExpressionAction<int, int> action, int parameter1, int parameter2)
        {
            action.Call(parameter1, parameter2);
            return ActionTarget.Default.Value;
        }
        /// <summary>
        /// 委托 Action{T1, T2, T3} 测试 API
        /// </summary>
        /// <param name="action">远程表达式委托 Action{T1, T2, T3}</param>
        /// <param name="parameter1"></param>
        /// <param name="parameter2"></param>
        /// <param name="parameter3"></param>
        /// <returns></returns>
        int IRemoteExpressionDelegateService.Action3(AutoCSer.Net.CommandServer.RemoteExpressionAction<int, int, int> action, int parameter1, int parameter2, int parameter3)
        {
            action.Call(parameter1, parameter2, parameter3);
            return ActionTarget.Default.Value;
        }
    }
```
## 3. 客户端配置
RPC 客户端配置必须[显式指定 IsRemoteExpression 为 true](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/13.RemoteExpression/CommandClientSocketEvent.cs)。
``` csharp
        /// <summary>
        /// 客户端单例
        /// </summary>
        public static readonly AutoCSer.Net.CommandClientSocketEventCache<CommandClientSocketEvent> CommandClient = new AutoCSer.Net.CommandClientSocketEventCache<CommandClientSocketEvent>(new AutoCSer.Net.CommandClientConfig
        {
            Host = new AutoCSer.Net.HostEndPoint((ushort)AutoCSer.TestCase.Common.CommandServerPortEnum.Document),
            GetSocketEventDelegate = (client) => new CommandClientSocketEvent(client),
            IsRemoteExpression = true
        });
```
## 4. 客户端调用
由于 Lambda 表达式参数必须显式定义，无法使用隐式转换方法传参，所以客户端传参需要[调用 Lambda 表达式封装类型的构造函数](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/13.RemoteExpression/Program.cs)。
``` csharp
        /// <summary>
        /// Client-side testing
        /// </summary>
        /// <returns></returns>
        private static async Task<bool> client()
        {
            try
            {
                var client = await CommandClientSocketEvent.CommandClient.SocketEvent.Wait();
                if (client == null)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }

                ActionTarget constantParameter = new ActionTarget { Value = AutoCSer.Random.Default.Next() };
                int parameter = AutoCSer.Random.Default.Next();
                var result = await client.RemoteExpressionDelegateController.Func(new AutoCSer.Net.CommandServer.RemoteExpressionFunc<int>(() => constantParameter.Value + parameter));
                if (result.Value != constantParameter.Value + parameter)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }

                parameter = AutoCSer.Random.Default.Next();
                result = await client.RemoteExpressionDelegateController.Func1(new AutoCSer.Net.CommandServer.RemoteExpressionFunc<int, int>(p => p + 1), parameter);
                if (result.Value != parameter + 1)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }

                int parameter2 = AutoCSer.Random.Default.Next();
                result = await client.RemoteExpressionDelegateController.Func2(new AutoCSer.Net.CommandServer.RemoteExpressionFunc<int, int, int>((p1, p2) => p1 + p2), parameter, parameter2);
                if (result.Value != parameter + parameter2)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }

                int parameter3 = AutoCSer.Random.Default.Next();
                result = await client.RemoteExpressionDelegateController.Func3(new AutoCSer.Net.CommandServer.RemoteExpressionFunc<int, int, int, int>((p1, p2, p3) => p1 + p2 + p3), parameter, parameter2, parameter3);
                if (result.Value != parameter + parameter2 + parameter3)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }

                result = await client.RemoteExpressionDelegateController.Action(new AutoCSer.Net.CommandServer.RemoteExpressionAction(() => ActionTarget.Default.Set(parameter + 1)));
                if (ActionTarget.Default.Value != parameter + 1)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }

                parameter = AutoCSer.Random.Default.Next();
                result = await client.RemoteExpressionDelegateController.Action1(new AutoCSer.Net.CommandServer.RemoteExpressionAction<int>(p => ActionTarget.Default.Set(p + 1)), parameter);
                if (ActionTarget.Default.Value != parameter + 1)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }

                result = await client.RemoteExpressionDelegateController.Action2(new AutoCSer.Net.CommandServer.RemoteExpressionAction<int, int>((p1, p2) => ActionTarget.Default.Set(p1 + p2)), parameter, parameter2);
                if (ActionTarget.Default.Value != parameter + parameter2)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }

                result = await client.RemoteExpressionDelegateController.Action3(new AutoCSer.Net.CommandServer.RemoteExpressionAction<int, int, int>((p1, p2, p3) => ActionTarget.Default.Set(p1 + p2 + p3)), parameter, parameter2, parameter3);
                if (ActionTarget.Default.Value != parameter + parameter2 + parameter3)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
            }
            catch (Exception exception)
            {
                AutoCSer.Breakpoint.ConsoleWriteQueue(exception.ToString());
            }
            Console.WriteLine("Completed");
            return true;
        }
```
Lambda 表达式中**不支持匿名类型**，使用的**局部变量**或者**局部变量的成员**都会被当成常量节点处理，这些数据类型**必须支持序列化**操作，比如下面代码中的 constantParameter.Value 与 parameter 都是常量节点。
``` csharp
                ActionTarget constantParameter = new ActionTarget { Value = AutoCSer.Random.Default.Next() };
                int parameter = AutoCSer.Random.Default.Next();
                var result = await client.RemoteExpressionDelegateController.Func(new AutoCSer.Net.CommandServer.RemoteExpressionFunc<int>(() => constantParameter.Value + parameter));
                if (result.Value != constantParameter.Value + parameter)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }

```
# 支持持久化的远程 Lambda 表达式
[AutoCSer.Net.CommandServer.RemoteLambdaExpression<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Extensions/Net/CommandServer/RemoteExpression/RemoteLambdaExpression.cs) 是**支持持久化**的远程 Lambda 表达式封装，泛型参数 T 允许指定任意委托类型。它的序列化操作不依赖于内存缓存数据状态，可用于内存数据库的持久化 API 的传参。  
由于它的序列化操作无法利用缓存优化，相对于不支持持久化的远程 Lambda 表达式，序列化数据内容的字节数量可能会**增加两个数量级**左右。它的反序列化结果也不适合使用缓存优化，编译方法 Compile() 的调用更是重量级操作。总的来说，就是它非常**不适合用于性能敏感**的需求场景，特别**不适合用于委托传参**，可用于支持 Lambda 表达式的 ORM 条件传参。
## 1. 服务端调用
``` csharp
        /// <summary>
        /// 可持久化的 Lambda 表达式测试 API
        /// </summary>
        /// <param name="func">可持久化的远程 Lambda 表达式</param>
        /// <returns></returns>
        int IRemoteExpressionDelegateService.Persistent(AutoCSer.Net.CommandServer.RemoteLambdaExpression<Func<int>> func)
        {
            return func.Compile()();
        }
```
## 2. 客户端调用
``` csharp
                constantParameter = new ActionTarget { Value = AutoCSer.Random.Default.Next() };
                parameter = AutoCSer.Random.Default.Next();
                result = await client.RemoteExpressionDelegateController.Persistent(new AutoCSer.Net.CommandServer.RemoteLambdaExpression<Func<int>>(() => constantParameter.Value + parameter));
                if (result.Value != constantParameter.Value + parameter)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
```