# Remote Lambda expression
RPC calls usually pass parameters as data and do **not support logic**. Because, whether from the perspective of security or performance, the server-side API logic should be rigidly written in the code, and no **ambiguous logical behavior** is allowed.  
AutoCSer RPC [encapsulates the serialization operation of Lambda expressions](https://github.com/AutoCSer/AutoCSer2/tree/main/AutoCSer/Extensions/Net/CommandServer/RemoteExpression) and utilizes the **JIT capability of Lambda expressions** to provide some simple logical parameter support. Therefore, this feature does **not support .NET NativeAOT**. Moreover, it is required that the server also simultaneously references the assembly where the **expression involves the definition of the relevant data type**.  
Because Lambda expressions may consist of many small objects, and serialization operations involve reflection as well as boxing and unboxing of structures, which may cause throughput performance differences of more than an order of magnitude, **it is not recommended to use it in non-essential scenarios**.  
From a security perspective, for the server side, since the Lambda expression constructed by the client allows for ambiguous logical behavior, it can only be used by the client that constructs the Lambda expression in a **fully trusted scenario**.  
Because this function is a special scenario function that is not very useful, it is encapsulated in the [extension project](https://github.com/AutoCSer/AutoCSer2/tree/main/AutoCSer/Extensions), which needs to be **referenced manually**.
# Supports 8 types of delegate definitions
## 1. Delegate with no return value
The parameter type corresponding to System.Action is [AutoCSer.Net.CommandServer.RemoteExpressionAction](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Extensions/Net/CommandServer/RemoteExpression/RemoteExpressionAction.cs)  
The parameter type corresponding to System.Action<T> is AutoCSer.Net.CommandServer.RemoteExpressionAction<T>  
The parameter type corresponding to System.Action<T1, T2> is AutoCSer.Net.CommandServer.RemoteExpressionAction<T1, T2>  
The parameter type corresponding to System.Action<T1, T2, T3> is AutoCSer.Net.CommandServer.RemoteExpressionAction<T1, T2, T3>
## 2. Delegate with a return value
The parameter type corresponding to System.Func<RT> is [AutoCSer.Net.CommandServer.RemoteExpressionFunc<RT>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Extensions/Net/CommandServer/RemoteExpression/RemoteExpressionFunc.cs)  
The parameter type corresponding to System.Func<T, RT> is AutoCSer.Net.CommandServer.RemoteExpressionFunc<T, RT>  
The parameter type corresponding to System.Func<T1, T2, RT> is AutoCSer.Net.CommandServer.RemoteExpressionFunc<T1, T2, RT>  
The parameter type corresponding to System.Func<T1, T2, T3, RT> is AutoCSer.Net.CommandServer.RemoteExpressionFunc<T1, T2, T3, RT>  
  
Although these parameter types encapsulate serialization logic for Lambda expressions, to avoid repetitive operations of serialization and reflection of related metadata, the serialization logic relies on real-time in-memory cache data. So these parameter passes do **not support persistence** operations, that is to say, they cannot be used for parameter passes in the persistence API of in-memory databases.
# Sample code
## 1. Server-side configuration
The RPC server configuration must [explicitly specify IsRemoteExpression as true](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/13.RemoteExpression/Program.cs).
``` csharp
            AutoCSer.Net.CommandServerConfig config = new AutoCSer.Net.CommandServerConfig
            {
                Host = new AutoCSer.Net.HostEndPoint((ushort)AutoCSer.TestCase.Common.CommandServerPortEnum.Document),
                IsRemoteExpression = true
            };
```
## 2. Server side call
The server implements delegation calls by [invoking the Call method](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/13.RemoteExpression/RemoteExpressionDelegateService.cs) or CallState method of the Lambda expression encapsulation type. In practice, before invoking the Call method, the successful status of the deserialization operation should be confirmed through the property IsSuccess or the method GetState() Avoid the system throwing an exception indicating that the deserialization operation has failed.
``` csharp
    /// <summary>
    /// Remote expression delegate test service instance
    /// </summary>
    internal sealed class RemoteExpressionDelegateService : IRemoteExpressionDelegateService
    {
        /// <summary>
        /// The test API of the parameterless delegate Func{T}
        /// </summary>
        /// <param name="func">Remote expression delegate Func{RT}</param>
        /// <returns></returns>
        int IRemoteExpressionDelegateService.Func(AutoCSer.Net.CommandServer.RemoteExpressionFunc<int> func)
        {
            return func.Call();
        }
        /// <summary>
        /// The test API of the delegate Func{T, RT}
        /// </summary>
        /// <param name="func">Remote expression delegate Func{T, RT}</param>
        /// <param name="parameter"></param>
        /// <returns></returns>
        int IRemoteExpressionDelegateService.Func1(AutoCSer.Net.CommandServer.RemoteExpressionFunc<int, int> func, int parameter)
        {
            return func.Call(parameter);
        }
        /// <summary>
        /// The test API of the delegate Func{T1, T2, RT}
        /// </summary>
        /// <param name="func">Remote expression delegate Func{T1, T2, RT}</param>
        /// <param name="parameter1"></param>
        /// <param name="parameter2"></param>
        /// <returns></returns>
        int IRemoteExpressionDelegateService.Func2(AutoCSer.Net.CommandServer.RemoteExpressionFunc<int, int, int> func, int parameter1, int parameter2)
        {
            return func.Call(parameter1, parameter2);
        }
        /// <summary>
        /// The test API of the delegate Func{T1, T2, T3, RT}
        /// </summary>
        /// <param name="func">Remote expression delegate Func{T1, T2, T3, RT}</param>
        /// <param name="parameter1"></param>
        /// <param name="parameter2"></param>
        /// <param name="parameter3"></param>
        /// <returns></returns>
        int IRemoteExpressionDelegateService.Func3(AutoCSer.Net.CommandServer.RemoteExpressionFunc<int, int, int, int> func, int parameter1, int parameter2, int parameter3)
        {
            return func.Call(parameter1, parameter2, parameter3);
        }

        /// <summary>
        /// The test API of the parameterless delegate Action
        /// </summary>
        /// <param name="action">Remote expression delegate Action</param>
        /// <returns></returns>
        int IRemoteExpressionDelegateService.Action(AutoCSer.Net.CommandServer.RemoteExpressionAction action)
        {
            action.Call();
            return ActionTarget.Default.Value;
        }
        /// <summary>
        /// The test API of the delegate Action{T}
        /// </summary>
        /// <param name="action">Remote expression delegate Action{T}</param>
        /// <param name="parameter"></param>
        /// <returns></returns>
        int IRemoteExpressionDelegateService.Action1(AutoCSer.Net.CommandServer.RemoteExpressionAction<int> action, int parameter)
        {
            action.Call(parameter);
            return ActionTarget.Default.Value;
        }
        /// <summary>
        /// The test API of the delegate Action{T1, T2}
        /// </summary>
        /// <param name="action">Remote expression delegate Action{T1, T2}</param>
        /// <param name="parameter1"></param>
        /// <param name="parameter2"></param>
        /// <returns></returns>
        int IRemoteExpressionDelegateService.Action2(AutoCSer.Net.CommandServer.RemoteExpressionAction<int, int> action, int parameter1, int parameter2)
        {
            action.Call(parameter1, parameter2);
            return ActionTarget.Default.Value;
        }
        /// <summary>
        /// The test API of the delegate Action{T1, T2, T3}
        /// </summary>
        /// <param name="action">Remote expression delegate Action{T1, T2, T3}</param>
        /// <param name="parameter1"></param>
        /// <param name="parameter2"></param>
        /// <param name="parameter3"></param>
        /// <returns></returns>
        int IRemoteExpressionDelegateService.Action3(AutoCSer.Net.CommandServer.RemoteExpressionAction<int, int, int> action, int parameter1, int parameter2, int parameter3)
        {
            action.Call(parameter1, parameter2, parameter3);
            return ActionTarget.Default.Value;
        }
    }
```
## 3. Client configuration
The RPC client configuration must [explicitly specify IsRemoteExpression as true](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/13.RemoteExpression/CommandClientSocketEvent.cs).
``` csharp
        /// <summary>
        /// Client singleton
        /// </summary>
        public static readonly AutoCSer.Net.CommandClientSocketEventCache<CommandClientSocketEvent> CommandClient = new AutoCSer.Net.CommandClientSocketEventCache<CommandClientSocketEvent>(new AutoCSer.Net.CommandClientConfig
        {
            Host = new AutoCSer.Net.HostEndPoint((ushort)AutoCSer.TestCase.Common.CommandServerPortEnum.Document),
            GetSocketEventDelegate = (client) => new CommandClientSocketEvent(client),
            IsRemoteExpression = true
        });
```
## 4. Client call
The generated client API parameter type is x, and the client code directly [passes the parameters in the form of a delegate](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/13.RemoteExpression/Program.cs).
``` csharp
        /// <summary>
        /// Client-side testing
        /// </summary>
        /// <returns></returns>
        private static async Task<bool> client()
        {
            try
            {
                var client = await CommandClientSocketEvent.CommandClient.SocketEvent.Wait();
                if (client == null)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }

                ActionTarget constantParameter = new ActionTarget { Value = AutoCSer.Random.Default.Next() };
                int parameter = AutoCSer.Random.Default.Next();
                var result = await client.RemoteExpressionDelegateController.Func(() => constantParameter.Value + parameter);
                if (result.Value != constantParameter.Value + parameter)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }

                parameter = AutoCSer.Random.Default.Next();
                result = await client.RemoteExpressionDelegateController.Func1(p => p + 1, parameter);
                if (result.Value != parameter + 1)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }

                int parameter2 = AutoCSer.Random.Default.Next();
                result = await client.RemoteExpressionDelegateController.Func2((p1, p2) => p1 + p2, parameter, parameter2);
                if (result.Value != parameter + parameter2)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }

                int parameter3 = AutoCSer.Random.Default.Next();
                result = await client.RemoteExpressionDelegateController.Func3((p1, p2, p3) => p1 + p2 + p3, parameter, parameter2, parameter3);
                if (result.Value != parameter + parameter2 + parameter3)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }

                result = await client.RemoteExpressionDelegateController.Action(() => ActionTarget.Default.Set(parameter + 1));
                if (ActionTarget.Default.Value != parameter + 1)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }

                parameter = AutoCSer.Random.Default.Next();
                result = await client.RemoteExpressionDelegateController.Action1(p => ActionTarget.Default.Set(p + 1), parameter);
                if (ActionTarget.Default.Value != parameter + 1)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }

                result = await client.RemoteExpressionDelegateController.Action2((p1, p2) => ActionTarget.Default.Set(p1 + p2), parameter, parameter2);
                if (ActionTarget.Default.Value != parameter + parameter2)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }

                result = await client.RemoteExpressionDelegateController.Action3((p1, p2, p3) => ActionTarget.Default.Set(p1 + p2 + p3), parameter, parameter2, parameter3);
                if (ActionTarget.Default.Value != parameter + parameter2 + parameter3)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
            }
            catch (Exception exception)
            {
                AutoCSer.Breakpoint.ConsoleWriteQueue(exception.ToString());
            }
            Console.WriteLine("Completed");
            return true;
        }
```
**Anonymous types are not supported** in Lambda expressions. **Local variables** or **members of local variables** used will be treated as constant nodes. These data types **must support serialization** operations. For example, both constantParameter.Value and parameter in the following code are constant nodes.
``` csharp
                ActionTarget constantParameter = new ActionTarget { Value = AutoCSer.Random.Default.Next() };
                int parameter = AutoCSer.Random.Default.Next();
                var result = await client.RemoteExpressionDelegateController.Func(new AutoCSer.Net.CommandServer.RemoteExpressionFunc<int>(() => constantParameter.Value + parameter));
                if (result.Value != constantParameter.Value + parameter)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }

```
# Support persistent remote Lambda expressions
[AutoCSer.Net.CommandServer.RemoteLambdaExpression<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Extensions/Net/CommandServer/RemoteExpression/RemoteLambdaExpression.cs) is a remote Lambda expression encapsulation that **supports persistence**, and the generic parameter T allows the specification of any delegate type. Its serialization operation does not rely on the in-memory cache data state and can be used for parameter passing in the persistence API of in-memory databases.  
Because its serialization operation cannot take advantage of cache optimization, the number of bytes of serialized data content may **increase by about two orders of magnitude** compared to remote Lambda expressions that do not support persistence. Its deserialization result is also not suitable for cache optimization, and the call to the compilation method Compile() is a heavyweight operation. Overall, it is highly **unsuitable for performance-sensitive** demand scenarios, **especially for parameter passing through delegates**. It can be used for ORM conditional parameter passing that supports Lambda expressions.
## 1. Server side call
``` csharp
        /// <summary>
        /// Test API for persistent Lambda expressions
        /// </summary>
        /// <param name="func">Persistent remote Lambda expressions</param>
        /// <returns></returns>
        int IRemoteExpressionDelegateService.Persistent(AutoCSer.Net.CommandServer.RemoteLambdaExpression<Func<int>> func)
        {
            return func.Compile()();
        }
```
## 2. Client call
``` csharp
                constantParameter = new ActionTarget { Value = AutoCSer.Random.Default.Next() };
                parameter = AutoCSer.Random.Default.Next();
                result = await client.RemoteExpressionDelegateController.Persistent(() => constantParameter.Value + parameter);
                if (result.Value != constantParameter.Value + parameter)
                {
                    return AutoCSer.Breakpoint.ReturnFalse();
                }
```