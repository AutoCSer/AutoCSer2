# RPC 线程调度策略
接口对称的异步 API 可以满足绝大多数应用需求，但是它不能根据需求场景选择合适的线程调度模式，所以无法针对不同需求场景优化代码结构与提升吞吐性能上限。  
本节内容属于进阶知识，需要有一定的**多线程知识**基础，对于不关心极限吞吐性能优化或者框架线程调度原理的开发者，可以[跳过本节内容](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/04.ServiceAuthentication/04.ServiceAuthentication.md)。
# 应答方式
AutoCSer RPC 是基于 TCP 长连接实现的全双工 RPC 组件，所以 API 支持 3 种应答方式。
## 1. 一次性响应
最常见的应答方式，一次客户端请求有且只有一次服务端响应或者异常响应，接口对称 API 就是这种应答方式。
## 2. 持续响应
**服务端推送**方式，有的 RPC 称之为流。一次客户端请求用于创建一个响应通道，服务端利用通道多次响应客户端。  
当然一次性响应方式也能实现推送需求，但是客户端会产生大量请求，而且串行的应答方式会造成巨大延时，严重影响吞吐性能。  
除了常规的服务端推送需求以外，对于 RPC 而言还有个现实的需求，**大数据包应该拆分为大小合适的小数据**的集合，分多次响应输出。  
由于 RPC 的一次响应数据需要序列化为一个整体数据包来处理，过大的数据包会造成网络通讯缓冲区的抖动，可能严重影响吞吐性能，大数据包是常见的性能杀手。  
如果是开放服务，由于客户端数量不可控，过大的数据包在高并发环境中会造成服务端占用大量内存，容易产生内存不足。而内存不足是很严重的问题，很容易造成系统级故障。  
如果是内部服务，由于客户端数量较少且可控，设置较大的缓冲区可以解决大部分问题，但是数据包大小仍然应该适配缓冲区大小。
## 3. 无响应
客户端推送方式，这种方式服务端不对客户端请求产生响应数据，客户端无法直接感知服务端的执行结果。  
这种方式可应用于**允许丢失请求**的场景，对于要求可靠性的场景，需要引入业务逻辑辅助验证与重试机制。
## 请求与响应
AutoCSer RPC 的服务端响应客户端，并不是直接把数据发送到客户端，而是将响应数据对象添加到一个**输出队列**中，由其它线程异步发送到客户端，类似于生产者与消费者模式。  
客户端对服务端发送的请求数据也是类似模式，因为这样**有利于发送数据的批量处理**。  
这种方案是通过**牺牲串行应答的延时指标**（实际上这种牺牲可以基本忽略不计）来换取批量操作特性，以此来优化**高并发**需求场景中的**吞吐性能与整体延时指标**，因为并发低场景牺牲一丁点性能是无关紧要的。一般简单的理解来说，就是在达到并发吞吐性能上限之前，**并发越高吞吐性能越好**。
# 服务端线程调度策略
由于大部分线程调度策略可以由 API 定义来指定，为了避免不必要的 Attribute 配置操作，经权衡 AutoCSer RPC 主要**通过 API 的定义来默认指定线程调度策略**，特殊场景才使用 Attribute 辅助申明线程调度策略。  
在 RPC 的调用关系中，服务端与客户端有着本质上的不同。服务端是被调用方，被调用与返回操作是一个整体；客户端是调用方，调用与回调则是两个步骤。  
所以服务端与客户端的线程调度原理与策略模型存在**本质上的差异**，这也是 AutoCSer 自带的应用服务组件采用非对称 API 定义的原因。  
在介绍 API 定义与线程调度之间的关系之前，特别强调一下高性能并发的常识原则，**线程阻塞是并发性能禁忌**问题，原则上任何时候都不应该出现线程阻塞逻辑，特别是服务端。  
AutoCSer RPC 的服务端共支持 7 种[线程调度策略](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Metadata/ServerMethodTypeEnum.cs)，所以服务端 API 定义有 7 大类型，每种线程调度类型都支持 3 种应答方式，同一种应答方式又可能存在多种 API 定义方式。
## 1. Task API
要求返回值类型为 System.Threading.Tasks.Task<T> 或者 System.Threading.Tasks.Task，采用系统异步任务调度，适合大量**无序任务并发**，是常规需求的**推荐类型**。
### 1.1 一次性响应
``` csharp
        /// <summary>
        /// 一次性响应 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be System.Threading.Tasks.Task or System.Threading.Tasks.Task{T}</returns>
        System.Threading.Tasks.Task<int> ISynchronousController.Add(int left, int right)
        {
            return System.Threading.Tasks.Task.FromResult(left + right);
        }
```
除了[同步响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Task/ISynchronousController.cs) 以外，还是支持[委托回调响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Task/IKeepCallbackController.cs)，允许服务端在合适的时候通过委托回调的方式响应客户端请求，主要用于事件触发回调响应需求。  
要求返回值类型为 System.Threading.Tasks.Task，最后一个参数类型为 [AutoCSer.Net.CommandServerCallback<T> 或者 AutoCSer.Net.CommandServerCallback](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerCallback.cs) 表示回调委托。  
该模式对开发者要求较高，在触发回调操作之前**不能丢弃委托对象**，否则会造成客户端 API 调用者一直处于等待响应状态直到关闭套接字连接。
``` csharp
        /// <summary>
        /// 回调委托 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">最后一个参数类型必须为 AutoCSer.Net.CommandServerCallback{T} 或者 AutoCSer.Net.CommandServerCallback</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        System.Threading.Tasks.Task ICallbackController.Add(int left, int right, AutoCSer.Net.CommandServerCallback<int> callback)
        {
            callback.Callback(left + right);
            return AutoCSer.Common.CompletedTask;
        }
```
### 1.2 持续响应
[委托回调持续响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Task/IKeepCallbackController.cs) 返回值类型为 System.Threading.Tasks.Task，最后一个参数类型为 [AutoCSer.Net.CommandServerKeepCallback<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallback.cs) 表示回调委托，是常规需求的推荐类型。
``` csharp
        /// <summary>
        /// 回调委托 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">回调委托包装，最后一个参数类型必须是 AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        System.Threading.Tasks.Task IKeepCallbackController.Callback(int left, int right, AutoCSer.Net.CommandServerKeepCallback<int> callback)
        {
            do
            {
                if (!callback.Callback(left)) break;
            }
            while (left++ != right);
            return AutoCSer.Common.CompletedTask;
        }
```
如果回调响应操作频率过高，可能导致网络输出操作跟不上回调操作的进度，输出队列累积大量输出数据对象会占用大量内存，不仅会对 GC 造成性能问题，甚至可能引发内存不足问题。  
这种需求场景应该限制回调响应操作的频率，让回调响应操作等待网络输出，使用具有**计数等待**功能的委托回调响应 API 可以控制输出对象的内存占用量，但是可能会牺牲一些当前 API 的吞吐性能。  
**回调计数委托 API** 返回值类型为 System.Threading.Tasks.Task，最后一个参数类型为 [AutoCSer.Net.CommandServerKeepCallbackCount<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallbackCount.cs) 表示回调委托。  
响应计数**默认为 1** 会导致批量操作特性受限，应该根据实际业务需求合理调整 [AutoCSer.Net.CommandServerMethodAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerMethodAttribute.cs).KeepCallbackOutputCount 配置值。
``` csharp
        /// <summary>
        /// 回调计数委托 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">回调委托包装，最后一个参数类型必须是 AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        [AutoCSer.Net.CommandServerMethod(KeepCallbackOutputCount = 1 << 10)]
        System.Threading.Tasks.Task CallbackCount(int left, int right, AutoCSer.Net.CommandServerKeepCallbackCount<int> callback);
```
``` csharp
        /// <summary>
        /// 回调计数委托 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">回调委托包装，最后一个参数类型必须是 AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        async System.Threading.Tasks.Task IKeepCallbackController.CallbackCount(int left, int right, AutoCSer.Net.CommandServerKeepCallbackCount<int> callback)
        {
            do
            {
                if (!await callback.CallbackAsync(left)) return;
            }
            while (left++ != right);
        }
```
**集合封装 API** 返回值类型为 System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<T>>，是对回调计数委托 API 的封装，一般用于返回的大数据量集合。
``` csharp
        /// <summary>
        /// 集合封装 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{T}}</returns>
        System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<int>> IKeepCallbackController.Enumerable(int left, int right)
        {
            return System.Threading.Tasks.Task.FromResult(Enumerable.Range(left, right - left + 1));
        }
```
**异步流 API** 返回值类型为 System.Collections.Generic.IAsyncEnumerable<T>，是对回调计数委托 API 的封装。
``` csharp
        /// <summary>
        /// 异步流 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be System.Collections.Generic.IAsyncEnumerable{T}</returns>
        async System.Collections.Generic.IAsyncEnumerable<int> IKeepCallbackController.AsyncEnumerable(int left, int right)
        {
            do
            {
                yield return left;
            }
            while (left++ != right);
        }
```
### 1.3 无响应
[无响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Task/ISendOnlyController.cs) 返回值类型为 System.Threading.Tasks.Task<[AutoCSer.Net.CommandServerSendOnly](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerSendOnly.cs)>。
``` csharp
        /// <summary>
        /// 无响应 API 示例
        /// </summary>
        /// <param name="value"></param>
        /// <returns>The return value type must be System.Threading.Tasks.Task{AutoCSer.Net.CommandServerSendOnly}</returns>
        System.Threading.Tasks.Task<AutoCSer.Net.CommandServerSendOnly> ISendOnlyController.Call(int value)
        {
            Console.WriteLine($"{nameof(SendOnlyController)} {value}");
            return AutoCSer.Net.CommandServerSendOnly.NullTask;
        }
```
## 2. Task 读写队列 API
采用 AutoCSer 内置的异步读写队列任务调度，由于每个队列的**写操作都是串行化**的，可以大幅降低数据库事务之间的资源竞争概率，也就是可以大幅降低锁超时与死锁产生的概率，是**高并发数据库事务访问的推荐策略**。  
合理的队列隔离设计方案可以在支持**大量队列并发**访问的同时，避免数据库事务之间的资源竞争问题，也就是避免锁超时与死锁的产生。  
队列写操作串行化，可以让队列上下文中的**缓存数据与持久化数据同步保持强一致性**，对缓存数据的读写操作也不用考虑线程安全问题。  
读写队列会**牺牲单个队列的并发吞吐延时与性能**，所以最佳实践是通过 127.0.0.1 访问本地数据库，最差的环境也应该**保证数据库访问的 0ms 延时**，避免延时问题影响数据库访问吞吐性能。  
表面上看写操作串行化会牺牲单个队列的并发吞吐延时与性能，但实战中的重点应该要保障高峰期事务不因为资源竞争问题而产生锁超时问题，锁超时不仅严重影响用户体验，而且高峰期一旦产生锁超时必定会产生雪崩效应。  
比如多租户模式下各租户之间资源竞争关系比较弱，按照租户设计隔离队列，各租户的事务是并发的，租户内的事务是串行的。  
Task 读写队列 API 要求返回值类型为 System.Threading.Tasks.Task<T> 或者 System.Threading.Tasks.Task，不允许存在名称为 queueKey 的数据参数。在**第一个数据参数之前增加队列上下文参数**，类型 [AutoCSer.Net.CommandServerCallTaskLowPriorityQueue<KT>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/TaskQueue/CommandServerCallTaskLowPriorityQueue.cs) 表示串行 API 用于写操作，类型 [AutoCSer.Net.CommandServerCallTaskQueue<KT>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/TaskQueue/CommandServerCallTaskQueue.cs) 表示并发 API 用于读操作，关键字类型 KT 必须实现接口 IEquatable<KT>，字段 Key 为当前队列关键字，字段 ContextObject 用于保存当前队列的上下文缓存数据。
### 2.1 一次性响应
``` csharp
        /// <summary>
        /// 一次性响应 API 示例
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be System.Threading.Tasks.Task or System.Threading.Tasks.Task{T}</returns>
        System.Threading.Tasks.Task<int> ISynchronousController.Add(AutoCSer.Net.CommandServerCallTaskQueue<int> queue, int left, int right)
        {
            return System.Threading.Tasks.Task.FromResult(left + right);
        }
```
除了[同步响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/TaskQueue/ISynchronousController.cs) 以外，还支持[委托回调响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/TaskQueue/IKeepCallbackController.cs)，返回值类型为 System.Threading.Tasks.Task，最后一个参数类型为 [AutoCSer.Net.CommandServerCallback<T> 或者 AutoCSer.Net.CommandServerCallback](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerCallback.cs) 表示回调委托。
``` csharp
        /// <summary>
        /// 回调委托 API 示例
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">最后一个参数类型必须为 AutoCSer.Net.CommandServerCallback{T} 或者 AutoCSer.Net.CommandServerCallback</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        System.Threading.Tasks.Task ICallbackController.Add(AutoCSer.Net.CommandServerCallTaskQueue<int> queue, int left, int right, AutoCSer.Net.CommandServerCallback<int> callback)
        {
            callback.Callback(left + right);
            return AutoCSer.Common.CompletedTask;
        }
```
### 2.2 持续响应
[委托回调持续响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/TaskQueue/IKeepCallbackController.cs) 返回值类型为 System.Threading.Tasks.Task，最后一个参数类型为 [AutoCSer.Net.CommandServerKeepCallback<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallback.cs) 表示回调委托。
``` csharp
        /// <summary>
        /// 回调委托 API 示例
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">回调委托包装，最后一个参数类型必须是 AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        System.Threading.Tasks.Task IKeepCallbackController.Callback(AutoCSer.Net.CommandServerCallTaskQueue<int> queue, int left, int right, AutoCSer.Net.CommandServerKeepCallback<int> callback)
        {
            do
            {
                if (!callback.Callback(left)) break;
            }
            while (left++ != right);
            return AutoCSer.Common.CompletedTask;
        }
```
**回调计数委托 API** 返回值类型为 System.Threading.Tasks.Task，最后一个参数类型为 [AutoCSer.Net.CommandServerKeepCallbackCount<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallbackCount.cs) 表示回调委托。
``` csharp
        /// <summary>
        /// 回调计数委托 API 示例
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">回调委托包装，最后一个参数类型必须是 AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        async System.Threading.Tasks.Task IKeepCallbackController.CallbackCount(AutoCSer.Net.CommandServerCallTaskQueue<int> queue, int left, int right, AutoCSer.Net.CommandServerKeepCallbackCount<int> callback)
        {
            do
            {
                if (!await callback.CallbackAsync(left)) return;
            }
            while (left++ != right);
        }
```
**集合封装 API** 返回值类型为 System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<T>>，是对回调计数委托 API 的封装，一般用于返回的大数据量集合。
``` csharp
        /// <summary>
        /// 集合封装 API 示例
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{T}}</returns>
        System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<int>> IKeepCallbackController.Enumerable(AutoCSer.Net.CommandServerCallTaskQueue<int> queue, int left, int right)
        {
            return System.Threading.Tasks.Task.FromResult(Enumerable.Range(left, right - left + 1));
        }
```
**异步流 API** 返回值类型为 System.Collections.Generic.IAsyncEnumerable<T>，是对回调计数委托 API 的封装。
``` csharp
        /// <summary>
        /// 异步流 API 示例
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be System.Collections.Generic.IAsyncEnumerable{T}</returns>
        async System.Collections.Generic.IAsyncEnumerable<int> IKeepCallbackController.AsyncEnumerable(AutoCSer.Net.CommandServerCallTaskQueue<int> queue, int left, int right)
        {
            do
            {
                yield return left;
            }
            while (left++ != right);
        }
```
### 2.3 无响应
[无响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/TaskQueue/ISendOnlyController.cs) 返回值类型为 System.Threading.Tasks.Task<[AutoCSer.Net.CommandServerSendOnly](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerSendOnly.cs)>。
``` csharp
        /// <summary>
        /// 无响应 API 示例
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="value"></param>
        /// <returns>The return value type must be System.Threading.Tasks.Task{AutoCSer.Net.CommandServerSendOnly}</returns>
        System.Threading.Tasks.Task<AutoCSer.Net.CommandServerSendOnly> ISendOnlyController.Call(AutoCSer.Net.CommandServerCallTaskQueue<int> queue, int value)
        {
            Console.WriteLine($"{nameof(SendOnlyController)} {queue.Key}.{value}");
            return AutoCSer.Net.CommandServerSendOnly.NullTask;
        }
```
### 2.4 控制器队列
服务控制器支持绑定一个 Task 读写队列的单例实例，控制器内 API 的队列上下文参数没有关键字类型参数，这种单例队列模式不适合存在高并发需求的数据库访问操作，一般用于简单的自定义持久化操作。  
[控制器队列 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/TaskQueue/ITaskQueueController.cs) 要求在第一个数据参数之前增加队列上下文参数，类型 [AutoCSer.Net.CommandServerCallTaskLowPriorityQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/TaskQueue/CommandServerCallTaskLowPriorityQueue.cs) 表示串行 API 用于写操作，类型 [AutoCSer.Net.CommandServerCallTaskQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/TaskQueue/CommandServerCallTaskQueue.cs) 表示并发 API 用于读操作，字段 ContextObject 用于保存当前队列的上下文缓存数据。  
要绑定 Task 读写队列，服务端控制器接口上需要配置 [AutoCSer.Net.CommandServerControllerInterfaceAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerControllerInterfaceAttribute.cs).TaskQueueMaxConcurrent 参数。
``` csharp
    /// <summary>
    /// 服务端控制器 Task 异步读写队列 API 示例接口
    /// </summary>
    [AutoCSer.Net.CommandServerControllerInterface(TaskQueueMaxConcurrent = 16)]
    public partial interface ITaskQueueController
```
## 3. Task 队列控制器 API
Task 队列控制器中的每一个 API 都是队列 API，是严格的串行队列操作，本质上是 Task 读写队列 API 的一种简化封装特例。  
控制器必须派生于 [AutoCSer.Net.CommandServerTaskQueueService<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerTaskQueueService.cs)，队列关键字通过字段 Key 来获取，队列上下文通过字段 Queue 来获取，当前服务套接字上下文通过属性 Socket 来获取。
``` csharp
    /// <summary>
    /// 服务端 Task 异步队列控制器 一次性响应 API 示例控制器
    /// </summary>
    internal sealed class SynchronousController : AutoCSer.Net.CommandServerTaskQueueService<int>, ISynchronousController
    {
        /// <summary>
        /// 服务端 Task 异步队列控制器
        /// </summary>
        /// <param name="task">服务端异步调用队列任务</param>
        /// <param name="key">Queue keyword</param>
        public SynchronousController(AutoCSer.Net.CommandServerCallTaskQueueNode task, int key) : base(task, key) { }
    }
```
### 3.1 一次性响应
``` csharp
        /// <summary>
        /// 一次性响应 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be System.Threading.Tasks.Task or System.Threading.Tasks.Task{T}</returns>
        System.Threading.Tasks.Task<int> ISynchronousController.Add(int left, int right)
        {
            return System.Threading.Tasks.Task.FromResult(left + right);
        }
```
除了[同步响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/TaskQueueController/ISynchronousController.cs) 以外，还支持[委托回调响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/TaskQueueController/IKeepCallbackController.cs)，返回值类型为 System.Threading.Tasks.Task，最后一个参数类型为 [AutoCSer.Net.CommandServerCallback<T> 或者 AutoCSer.Net.CommandServerCallback](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerCallback.cs) 表示回调委托。
``` csharp
        /// <summary>
        /// 回调委托 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">最后一个参数类型必须为 AutoCSer.Net.CommandServerCallback{T} 或者 AutoCSer.Net.CommandServerCallback</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        System.Threading.Tasks.Task ICallbackController.Add(int left, int right, AutoCSer.Net.CommandServerCallback<int> callback)
        {
            callback.Callback(left + right);
            return AutoCSer.Common.CompletedTask;
        }
```
### 3.2 持续响应
[委托回调持续响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/TaskQueueController/IKeepCallbackController.cs) 返回值类型为 System.Threading.Tasks.Task，最后一个参数类型为 [AutoCSer.Net.CommandServerKeepCallback<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallback.cs) 表示回调委托。
``` csharp
        /// <summary>
        /// 回调委托 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">回调委托包装，最后一个参数类型必须是 AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        System.Threading.Tasks.Task IKeepCallbackController.Callback(int left, int right, AutoCSer.Net.CommandServerKeepCallback<int> callback)
        {
            do
            {
                if (!callback.Callback(left)) break;
            }
            while (left++ != right);
            return AutoCSer.Common.CompletedTask;
        }
```
**回调计数委托 API** 返回值类型为 System.Threading.Tasks.Task，最后一个参数类型为 [AutoCSer.Net.CommandServerKeepCallbackCount<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallbackCount.cs) 表示回调委托。
``` csharp
        /// <summary>
        /// 回调计数委托 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">回调委托包装，最后一个参数类型必须是 AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        async System.Threading.Tasks.Task IKeepCallbackController.CallbackCount(int left, int right, AutoCSer.Net.CommandServerKeepCallbackCount<int> callback)
        {
            do
            {
                if (!await callback.CallbackAsync(left)) return;
            }
            while (left++ != right);
        }
```
**集合封装 API** 返回值类型为 System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<T>>，是对回调计数委托 API 的封装，一般用于返回的大数据量集合。
``` csharp
        /// <summary>
        /// 集合封装 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{T}}</returns>
        System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<int>> IKeepCallbackController.Enumerable(int left, int right)
        {
            return System.Threading.Tasks.Task.FromResult(Enumerable.Range(left, right - left + 1));
        }
```
**异步流 API** 返回值类型为 System.Collections.Generic.IAsyncEnumerable<T>，是对回调计数委托 API 的封装。
``` csharp
        /// <summary>
        /// 异步流 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be System.Collections.Generic.IAsyncEnumerable{T}</returns>
        async System.Collections.Generic.IAsyncEnumerable<int> IKeepCallbackController.AsyncEnumerable(int left, int right)
        {
            do
            {
                yield return left;
            }
            while (left++ != right);
        }
```
### 2.3 无响应
[无响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/TaskQueueController/ISendOnlyController.cs) 返回值类型为 System.Threading.Tasks.Task<[AutoCSer.Net.CommandServerSendOnly](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerSendOnly.cs)>。
``` csharp
        /// <summary>
        /// 无响应 API 示例
        /// </summary>
        /// <param name="value"></param>
        /// <returns>The return value type must be System.Threading.Tasks.Task{AutoCSer.Net.CommandServerSendOnly}</returns>
        System.Threading.Tasks.Task<AutoCSer.Net.CommandServerSendOnly> ISendOnlyController.Call(int value)
        {
            Console.WriteLine($"{nameof(SendOnlyController)} {Key}.{value}");
            return AutoCSer.Net.CommandServerSendOnly.NullTask;
        }
```
## 4. 线程队列 API
严格的单线程串行操作，适合没有持久化需求的**轻量级内存计算**服务，比如内存缓存服务、内存数据库服务、消息队列服务、内存搜索引擎服务、游戏局内服务、内存数据流计算服务等。  
每个队列占用一个常驻线程，每个服务控制器可以配置一个默认队列，除此之外最多支持 255 个附加队列。对于常规服务建议根据并发压力预期合理分配队列线程，队列总数不应该超过 CPU 核心线程数量。  
线程队列 API 要求在第一个数据参数之前增加队列上下文参数，一般场景使用类型 [AutoCSer.Net.CommandServerCallQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/Queue/CommandServerCallQueue.cs)，特殊场景使用类型 [AutoCSer.Net.CommandServerCallLowPriorityQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/Queue/CommandServerCallLowPriorityQueue.cs)，区别在于前者比后者拥有更高优先级的执行概率，字段 ContextObject 用于保存当前队列的上下文缓存数据。
### 4.1 一次性响应
[同步响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Queue/ISynchronousController.cs) 支持但不建议使用 ref / out 参数，因为 ref / out 参数将导致客户端只能使用线程阻塞同步等待 API 模式。
``` csharp
        /// <summary>
        /// 同步 API 示例，支持 ref / out 参数
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        int Add(AutoCSer.Net.CommandServerCallQueue queue, int left, int right);
```
[委托回调响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Queue/ICallbackController.cs) 返回值类型为 void，最后一个参数类型为 [AutoCSer.Net.CommandServerCallback<T> 或者 AutoCSer.Net.CommandServerCallback](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerCallback.cs) 表示回调委托。
``` csharp
        /// <summary>
        /// 回调委托 API 示例，支持 ref / out 参数
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">回调委托包装，必须是最后一个参数</param>
        void ICallbackController.Add(AutoCSer.Net.CommandServerCallQueue queue, int left, int right, AutoCSer.Net.CommandServerCallback<int> callback)
        {
            callback.Callback(left + right);
        }
```
### 4.2 持续响应
[委托回调持续响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Queue/IKeepCallbackController.cs) 返回值类型为 void，最后一个参数类型为 [AutoCSer.Net.CommandServerKeepCallback<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallback.cs) 表示回调委托。
``` csharp
        /// <summary>
        /// 回调委托 API 示例
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">回调委托包装，最后一个参数类型必须是 AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be void</returns>
        void IKeepCallbackController.Callback(AutoCSer.Net.CommandServerCallQueue queue, int left, int right, AutoCSer.Net.CommandServerKeepCallback<int> callback)
        {
            Task.KeepCallbackController.Callback(left, right, callback);
        }
```
**回调计数委托 API** 返回值类型为 void，最后一个参数类型为 [AutoCSer.Net.CommandServerKeepCallbackCount<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallbackCount.cs) 表示回调委托。由于该回调采用 Task 异步模式，不建议在同步 API 中触发 GetResult() 等同步阻塞操作。
``` csharp
        /// <summary>
        /// 回调计数委托 API 示例
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">回调委托包装，最后一个参数类型必须是 AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be void</returns>
        void IKeepCallbackController.CallbackCount(AutoCSer.Net.CommandServerCallQueue queue, int left, int right, AutoCSer.Net.CommandServerKeepCallbackCount<int> callback)
        {
            do
            {
                if (!callback.CallbackAsync(left).GetResult()) return;
            }
            while (left++ != right);
        }
```
### 4.3 无响应
[无响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Queue/ISendOnlyController.cs) 返回值类型为 [AutoCSer.Net.CommandServerSendOnly](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerSendOnly.cs)。
``` csharp
        /// <summary>
        /// 无响应 API 示例
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="value"></param>
        /// <returns>The return value type must be AutoCSer.Net.CommandServerSendOnly</returns>
        AutoCSer.Net.CommandServerSendOnly ISendOnlyController.Call(AutoCSer.Net.CommandServerCallQueue queue, int value)
        {
            Console.WriteLine($"{nameof(SendOnlyController)} {value}");
            return AutoCSer.Net.CommandServerSendOnly.Null;
        }
```
## 5. 可并发读线程队列 API
为 AutoCSer [内存数据库](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/06.MemoryDatabase/06.MemoryDatabase.md)定制的默认线程调度策略，常规操作也是严格的单线程串行操作，为了降低[获取重建持久化快照数据操作](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/08.MemoryDatabaseCustomNode.md)阻塞正常服务的影响，该模式允许该操作与其它正常读请求操作并行。  
每个队列占用两个常驻线程，每个服务控制器都可以绑定一个独立队列实例，如果服务控制器中没有定义相关 API 则不会创建队列实例。  
可并发读线程队列 API 要求在第一个数据参数之前增加队列上下文参数，类型 [AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/ConcurrencyReadQueue/CommandServerCallConcurrencyReadWriteQueue.cs) 表示写操作，类型 [AutoCSer.Net.CommandServerCallConcurrencyReadQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/ConcurrencyReadQueue/CommandServerCallConcurrencyReadQueue.cs) 表示读操作，字段 ContextObject 用于保存当前队列的上下文缓存数据。
### 5.1 一次性响应
[同步响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/ConcurrencyReadQueue/ISynchronousController.cs) 支持但不建议使用 ref / out 参数，因为 ref / out 参数将导致客户端只能使用线程阻塞同步等待 API 模式。
``` csharp
        /// <summary>
        /// 同步 API 示例，支持 ref / out 参数
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        int Add(AutoCSer.Net.CommandServerCallConcurrencyReadQueue queue, int left, int right);
```
[委托回调响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/ConcurrencyReadQueue/ICallbackController.cs) 返回值类型为 void，最后一个参数类型为 [AutoCSer.Net.CommandServerCallback<T> 或者 AutoCSer.Net.CommandServerCallback](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerCallback.cs) 表示回调委托。
``` csharp
        /// <summary>
        /// 回调委托 API 示例，支持 ref / out 参数
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">回调委托包装，必须是最后一个参数</param>
        void ICallbackController.Add(AutoCSer.Net.CommandServerCallConcurrencyReadQueue queue, int left, int right, AutoCSer.Net.CommandServerCallback<int> callback)
        {
            callback.Callback(left + right);
        }
```
### 5.2 持续响应
[委托回调持续响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/ConcurrencyReadQueue/IKeepCallbackController.cs) 返回值类型为 void，最后一个参数类型为 [AutoCSer.Net.CommandServerKeepCallback<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallback.cs) 表示回调委托。
``` csharp
        /// <summary>
        /// 回调委托 API 示例
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">回调委托包装，最后一个参数类型必须是 AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be void</returns>
        void IKeepCallbackController.Callback(AutoCSer.Net.CommandServerCallConcurrencyReadQueue queue, int left, int right, AutoCSer.Net.CommandServerKeepCallback<int> callback)
        {
            do
            {
                if (!callback.Callback(left)) break;
            }
            while (left++ != right);
        }
```
**回调计数委托 API** 返回值类型为 void，最后一个参数类型为 [AutoCSer.Net.CommandServerKeepCallbackCount<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallbackCount.cs) 表示回调委托。由于该回调采用 Task 异步模式，不建议在同步 API 中触发 GetResult() 等同步阻塞操作。
``` csharp
        /// <summary>
        /// 回调计数委托 API 示例
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">回调委托包装，最后一个参数类型必须是 AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be void</returns>
        void IKeepCallbackController.CallbackCount(AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue queue, int left, int right, AutoCSer.Net.CommandServerKeepCallbackCount<int> callback)
        {
            do
            {
                if (!callback.CallbackAsync(left).GetResult()) return;
            }
            while (left++ != right);
        }
```
### 5.3 无响应
[无响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/ConcurrencyReadQueue/ISendOnlyController.cs) 返回值类型为 [AutoCSer.Net.CommandServerSendOnly](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerSendOnly.cs)。
``` csharp
        /// <summary>
        /// 无响应 API 示例
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="value"></param>
        /// <returns>The return value type must be AutoCSer.Net.CommandServerSendOnly</returns>
        AutoCSer.Net.CommandServerSendOnly ISendOnlyController.Call(AutoCSer.Net.CommandServerCallConcurrencyReadQueue queue, int value)
        {
            Console.WriteLine($"{nameof(SendOnlyController)} {value}");
            return AutoCSer.Net.CommandServerSendOnly.Null;
        }
```
## 6. 读写队列线程 API
为 AutoCSer [内存数据库](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/06.MemoryDatabase/06.MemoryDatabase.md)定制的可选线程调度策略，该模式允许指定读操作的线程数量以并行执行读操作，适合以读操作为主并且 CPU 核心线程数量较多的需求场景。  
每个队列占用指定数量的常驻线程，每个服务控制器都可以绑定一个独立队列实例，如果服务控制器中没有定义相关 API 则不会创建队列实例。  
读写队列线程 API 要求在第一个数据参数之前增加队列上下文参数，类型 [AutoCSer.Net.CommandServerCallWriteQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/ReadWriteQueue/CommandServerCallWriteQueue.cs) 表示写操作，类型 [AutoCSer.Net.CommandServerCallReadQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/ReadWriteQueue/CommandServerCallReadQueue.cs) 表示并发读操作，字段 ContextObject 用于保存当前队列的上下文缓存数据。
### 6.1 一次性响应
[同步响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/ReadWriteQueue/ISynchronousController.cs) 支持但不建议使用 ref / out 参数，因为 ref / out 参数将导致客户端只能使用线程阻塞同步等待 API 模式。
``` csharp
        /// <summary>
        /// 同步 API 示例，支持 ref / out 参数
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        int Add(AutoCSer.Net.CommandServerCallReadQueue queue, int left, int right);
```
[委托回调响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/ReadWriteQueue/ICallbackController.cs) 返回值类型为 void，最后一个参数类型为 [AutoCSer.Net.CommandServerCallback<T> 或者 AutoCSer.Net.CommandServerCallback](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerCallback.cs) 表示回调委托。
``` csharp
        /// <summary>
        /// 回调委托 API 示例，支持 ref / out 参数
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">回调委托包装，必须是最后一个参数</param>
        void ICallbackController.Add(AutoCSer.Net.CommandServerCallReadQueue queue, int left, int right, AutoCSer.Net.CommandServerCallback<int> callback)
        {
            callback.Callback(left + right);
        }
```
### 6.2 持续响应
[委托回调持续响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/ReadWriteQueue/IKeepCallbackController.cs) 返回值类型为 void，最后一个参数类型为 [AutoCSer.Net.CommandServerKeepCallback<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallback.cs) 表示回调委托。
``` csharp
        /// <summary>
        /// 回调委托 API 示例
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">回调委托包装，最后一个参数类型必须是 AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be void</returns>
        void IKeepCallbackController.Callback(AutoCSer.Net.CommandServerCallReadQueue queue, int left, int right, AutoCSer.Net.CommandServerKeepCallback<int> callback)
        {
            do
            {
                if (!callback.Callback(left)) break;
            }
            while (left++ != right);
        }
```
**回调计数委托 API** 返回值类型为 void，最后一个参数类型为 [AutoCSer.Net.CommandServerKeepCallbackCount<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallbackCount.cs) 表示回调委托。由于该回调采用 Task 异步模式，不建议在同步 API 中触发 GetResult() 等同步阻塞操作。
``` csharp
        /// <summary>
        /// 回调计数委托 API 示例
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">回调委托包装，最后一个参数类型必须是 AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be void</returns>
        void IKeepCallbackController.CallbackCount(AutoCSer.Net.CommandServerCallWriteQueue queue, int left, int right, AutoCSer.Net.CommandServerKeepCallbackCount<int> callback)
        {
            do
            {
                if (!callback.CallbackAsync(left).GetResult()) return;
            }
            while (left++ != right);
        }
```
### 6.3 无响应
[无响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/ReadWriteQueue/ISendOnlyController.cs) 返回值类型为 [AutoCSer.Net.CommandServerSendOnly](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerSendOnly.cs)。
``` csharp
        /// <summary>
        /// 无响应 API 示例
        /// </summary>
        /// <param name="queue">当前执行队列上下文，必须定义在第一个数据参数之前</param>
        /// <param name="value"></param>
        /// <returns>The return value type must be AutoCSer.Net.CommandServerSendOnly</returns>
        AutoCSer.Net.CommandServerSendOnly ISendOnlyController.Call(AutoCSer.Net.CommandServerCallReadQueue queue, int value)
        {
            Console.WriteLine($"{nameof(SendOnlyController)} {value}");
            return AutoCSer.Net.CommandServerSendOnly.Null;
        }
```
## 7. IO 线程同步 API
直接在 **Socket 接收数据的 IO 回调线程**中执行，没有线程切换开销，仅适合**轻量级内存计算** API，比如获取服务端当前时间、分配全局 Identity 等。
### 7.1 一次性响应
[同步响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Synchronous/ISynchronousController.cs) 支持但不建议使用 ref / out 参数，因为 ref / out 参数将导致客户端只能使用线程阻塞同步等待 API 模式。
``` csharp
        /// <summary>
        /// 同步 API 示例，支持 ref / out 参数
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        int Add(int left, int right);
```
[委托回调响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Synchronous/ICallbackController.cs) 返回值类型为 void，最后一个参数类型为 [AutoCSer.Net.CommandServerCallback<T> 或者 AutoCSer.Net.CommandServerCallback](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerCallback.cs) 表示回调委托。
``` csharp
        /// <summary>
        /// 回调委托 API 示例，支持 ref / out 参数
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">回调委托包装，必须是最后一个参数</param>
        void ICallbackController.Add(int left, int right, AutoCSer.Net.CommandServerCallback<int> callback)
        {
            callback.Callback(left + right);
        }
```
### 7.2 持续响应
[委托回调持续响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Synchronous/IKeepCallbackController.cs) 返回值类型为 void，最后一个参数类型为 [AutoCSer.Net.CommandServerKeepCallback<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallback.cs) 表示回调委托。
``` csharp
        /// <summary>
        /// 回调委托 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">回调委托包装，最后一个参数类型必须是 AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be void</returns>
        void IKeepCallbackController.Callback(int left, int right, AutoCSer.Net.CommandServerKeepCallback<int> callback)
        {
            do
            {
                if (!callback.Callback(left)) break;
            }
            while (left++ != right);
        }
```
**回调计数委托 API** 返回值类型为 void，最后一个参数类型为 [AutoCSer.Net.CommandServerKeepCallbackCount<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallbackCount.cs) 表示回调委托。由于该回调采用 Task 异步模式，不建议在同步 API 中触发 GetResult() 等同步阻塞操作。
``` csharp
        /// <summary>
        /// 回调计数委托 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">回调委托包装，最后一个参数类型必须是 AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be void</returns>
        void IKeepCallbackController.CallbackCount(int left, int right, AutoCSer.Net.CommandServerKeepCallbackCount<int> callback)
        {
            do
            {
                if (!callback.CallbackAsync(left).GetResult()) return;
            }
            while (left++ != right);
        }
```
### 7.3 无响应
[无响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Synchronous/ISendOnlyController.cs) 返回值类型为 [AutoCSer.Net.CommandServerSendOnly](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerSendOnly.cs)。
``` csharp
        /// <summary>
        /// 无响应 API 示例
        /// </summary>
        /// <param name="value"></param>
        /// <returns>The return value type must be AutoCSer.Net.CommandServerSendOnly</returns>
        AutoCSer.Net.CommandServerSendOnly ISendOnlyController.Call(int value)
        {
            Console.WriteLine($"{nameof(SendOnlyController)} {value}");
            return AutoCSer.Net.CommandServerSendOnly.Null;
        }
```
# 客户端回调线程调度策略
[客户端 API 定义](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Metadata/ClientMethodTypeEnum.cs)取决于服务端 API 的**应答方式**，与服务端线程调度策略无关。同一种应答方式可能存在多种客户端 API 定义方式，所以允许多个客户端 API 匹配到同一个服务端 API。  
客户端 API 的返回值类型、数据参数类型、名称、顺序都必须与服务端 API 匹配。虽然常规需求都可以使用[静态代码生成](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/05.CodeGenerator.md)工具生成默认的客户端接口与 API 定义，但还是建议简单了解一下手工代码模式。  
对于服务端 Task 队列控制器 API 匹配的客户端关键字参数名称必须为 queueKey，并且必须放在第一个参数位置。
## 1. 一次性响应
### 1.1 await 回调
[await 回调 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/IReturnCommandController.cs) 返回值类型为 [AutoCSer.Net.ReturnCommand<T> 或者 AutoCSer.Net.ReturnCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/ReturnCommand.cs)，通过 [AutoCSer.Net.CommandClientMethodAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandClientMethodAttribute.cs).CallbackType 指定回调方式，是常规需求的**默认推荐类型**。
``` csharp
        /// <summary>
        /// 一次性响应 API 客户端 await 回调 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be AutoCSer.Net.ReturnCommand or AutoCSer.Net.ReturnCommand{T}</returns>
        [AutoCSer.Net.CommandClientMethod(CallbackType = AutoCSer.Net.CommandServer.ClientCallbackTypeEnum.RunTask)]
        AutoCSer.Net.ReturnCommand<int> Add(int left, int right);
```
**Task API** 返回值类型为 System.Threading.Tasks.Task<T> 或者 System.Threading.Tasks.Task，调用状态错误会抛出异常，不建议用于性能敏感的项目。
``` csharp
        /// <summary>
        /// 一次性响应 API 客户端 Task API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        [AutoCSer.Net.CommandClientMethod(MatchMethodName = nameof(Add))]
        System.Threading.Tasks.Task<int> AddAsync(int left, int right);
```
### 1.2 队列 await 回调
[队列 await 回调 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/IReturnQueueCommandController.cs) 返回值类型为 [AutoCSer.Net.ReturnQueueCommand<T> 或者 AutoCSer.Net.ReturnQueueCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/ReturnQueueCommand.cs)。  
由于是队列线程同步触发回调，可以保证回调操作的串行执行，但不能保证后续 await 操作的串行执行。回调后续不允许存在同步阻塞操作，否则会严重影响回调队列的吞吐性能，甚至在复杂的依赖场景中可能造成队列调度死锁。
``` csharp
        /// <summary>
        /// 一次性响应 API 客户端队列 await 回调 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be AutoCSer.Net.ReturnCommand or AutoCSer.Net.ReturnCommand{T}</returns>
        AutoCSer.Net.ReturnQueueCommand<int> Add(int left, int right);
```
### 1.3 委托回调
[委托回调 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/ICallbackController.cs) 返回值类型为 [AutoCSer.Net.CallbackCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/CallbackCommand.cs)，通过 [AutoCSer.Net.CommandClientMethodAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandClientMethodAttribute.cs).CallbackType 指定回调方式，最后一个参数类型为 Action<[AutoCSer.Net.CommandClientReturnValue<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs)> 或者 Action<[AutoCSer.Net.CommandClientReturnValue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs)> 或者 [AutoCSer.Net.CommandClientCallback<T> 或者 AutoCSer.Net.CommandClientCallback](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientCallback.cs) 表示回调委托。
``` csharp
        /// <summary>
        /// 一次性响应 API 客户端回调 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">最后一个参数必须为 Action{AutoCSer.Net.CommandClientReturnValue{T}} 或者 Action{AutoCSer.Net.CommandClientReturnValue} 或者 AutoCSer.Net.CommandClientCallback{T} 或者 AutoCSer.Net.CommandClientCallback</param>
        /// <returns>The return value type must be AutoCSer.Net.CallbackCommand</returns>
        AutoCSer.Net.CallbackCommand Add(int left, int right, Action<AutoCSer.Net.CommandClientReturnValue<int>> callback);
        /// <summary>
        /// 一次性响应 API 客户端回调 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">最后一个参数必须为 Action{AutoCSer.Net.CommandClientReturnValue{T}} 或者 Action{AutoCSer.Net.CommandClientReturnValue} 或者 AutoCSer.Net.CommandClientCallback{T} 或者 AutoCSer.Net.CommandClientCallback</param>
        /// <returns>The return value type must be AutoCSer.Net.CallbackCommand</returns>
        AutoCSer.Net.CallbackCommand Add(int left, int right, AutoCSer.Net.CommandClientCallback<int> callback);
```
### 1.4 队列委托回调
[队列委托回调 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/ICallbackQueueController.cs) 返回值类型为 [AutoCSer.Net.CallbackCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/CallbackCommand.cs)，最后一个参数类型为 Action<[AutoCSer.Net.CommandClientReturnValue<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs), [AutoCSer.Net.CommandClientCallQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientCallQueue.cs)> 或者 Action<[AutoCSer.Net.CommandClientReturnValue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs), [AutoCSer.Net.CommandClientCallQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientCallQueue.cs)> 或者 [AutoCSer.Net.CommandClientCallbackQueueNode<T> 或者 AutoCSer.Net.CommandClientCallbackQueueNode](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientCallbackQueueNode.cs) 表示回调委托。  
由于是队列线程同步触发回调，可以保证回调操作的串行执行，但不能保证后续 await 操作的串行执行。回调后续不允许存在同步阻塞操作，否则会严重影响回调队列的吞吐性能，甚至在复杂的依赖场景中可能造成队列调度死锁。
``` csharp
        /// <summary>
        /// 一次性响应 API 客户端队列回调 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">最后一个参数必须为 Action{AutoCSer.Net.CommandClientReturnValue{T}, AutoCSer.Net.CommandClientCallQueue} 或者 Action{AutoCSer.Net.CommandClientReturnValue, AutoCSer.Net.CommandClientCallQueue} 或者 AutoCSer.Net.CommandClientCallbackQueueNode{T} 或者 AutoCSer.Net.CommandClientCallbackQueueNode</param>
        /// <returns>The return value type must be AutoCSer.Net.CallbackCommand</returns>
        AutoCSer.Net.CallbackCommand Add(int left, int right, Action<AutoCSer.Net.CommandClientReturnValue<int>, AutoCSer.Net.CommandClientCallQueue> callback);
        /// <summary>
        /// 一次性响应 API 客户端队列回调 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">最后一个参数必须为 Action{AutoCSer.Net.CommandClientReturnValue{T}, AutoCSer.Net.CommandClientCallQueue} 或者 Action{AutoCSer.Net.CommandClientReturnValue, AutoCSer.Net.CommandClientCallQueue} 或者 AutoCSer.Net.CommandClientCallbackQueueNode{T} 或者 AutoCSer.Net.CommandClientCallbackQueueNode</param>
        /// <returns>The return value type must be AutoCSer.Net.CallbackCommand</returns>
        AutoCSer.Net.CallbackCommand Add(int left, int right, AutoCSer.Net.CommandClientCallbackQueueNode<int> callback);
```
### 1.5 同步 API
[同步 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/ICommandClientReturnValueController.cs) 返回值类型为 [AutoCSer.Net.CommandClientReturnValue<T> 或者 AutoCSer.Net.CommandClientReturnValue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs)，支持 ref / out 参数，通过 [AutoCSer.Net.CommandClientMethodAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandClientMethodAttribute.cs).CallbackType 指定回调方式，不推荐使用。
``` csharp
        /// <summary>
        /// 一次性响应 API 客户端同步 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be AutoCSer.Net.CommandClientReturnValue or AutoCSer.Net.CommandClientReturnValue{T}</returns>
        AutoCSer.Net.CommandClientReturnValue<int> Add(int left, int right);
```
## 2. 持续响应
### 2.1 await 回调
[await 回调 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/IEnumeratorCommandController.cs) 返回值类型为 [AutoCSer.Net.EnumeratorCommand<T> 或者 AutoCSer.Net.EnumeratorCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/EnumeratorCommand.cs)，通过 [AutoCSer.Net.CommandClientMethodAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandClientMethodAttribute.cs).CallbackType 指定回调方式，是常规需求的**默认推荐类型**。
``` csharp
        /// <summary>
        /// 持续响应 API 客户端 await API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be AutoCSer.Net.EnumeratorCommand or AutoCSer.Net.EnumeratorCommand{T}</returns>
        AutoCSer.Net.EnumeratorCommand<int> Callback(int left, int right);
```
### 2.2 队列 await 回调
[队列 await 回调 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/IEnumeratorQueueCommandController.cs) 返回值类型为 [AutoCSer.Net.EnumeratorQueueCommand<T> 或者 AutoCSer.Net.EnumeratorQueueCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/EnumeratorQueueCommand.cs)。  
由于是队列线程同步触发回调，可以保证回调操作的串行执行，但不能保证后续 await 操作的串行执行。回调后续不允许存在同步阻塞操作，否则会严重影响回调队列的吞吐性能，甚至在复杂的依赖场景中可能造成队列调度死锁。
``` csharp
        /// <summary>
        /// 持续响应 API 客户端队列 await API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be AutoCSer.Net.EnumeratorQueueCommand or AutoCSer.Net.EnumeratorQueueCommand{T}</returns>
        AutoCSer.Net.EnumeratorQueueCommand<int> Callback(int left, int right);
```
### 2.3 委托回调
[委托回调 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/IKeepCallbackController.cs) 返回值类型为 [AutoCSer.Net.KeepCallbackCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/KeepCallbackCommand.cs)，通过 [AutoCSer.Net.CommandClientMethodAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandClientMethodAttribute.cs).CallbackType 指定回调方式，最后一个参数类型为 Action<[AutoCSer.Net.CommandClientReturnValue<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs), [AutoCSer.Net.KeepCallbackCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/KeepCallbackCommand.cs)> 或者 Action<[AutoCSer.Net.CommandClientReturnValue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs), [AutoCSer.Net.KeepCallbackCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/KeepCallbackCommand.cs)> 或者 [AutoCSer.Net.CommandClientKeepCallback<T> 或者 AutoCSer.Net.CommandClientKeepCallback](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientKeepCallback.cs) 表示回调委托，性能优于 await 回调 API。
``` csharp
        /// <summary>
        /// 持续响应 API 客户端回调 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">最后一个参数必须为 Action{AutoCSer.Net.CommandClientReturnValue{T}, AutoCSer.Net.KeepCallbackCommand} 或者 Action{AutoCSer.Net.CommandClientReturnValue, AutoCSer.Net.KeepCallbackCommand} 或者 AutoCSer.Net.CommandClientKeepCallback{T} 或者 AutoCSer.Net.CommandClientKeepCallback</param>
        /// <returns>The return value type must be AutoCSer.Net.KeepCallbackCommand</returns>
        AutoCSer.Net.KeepCallbackCommand Callback(int left, int right, Action<AutoCSer.Net.CommandClientReturnValue<int>, AutoCSer.Net.KeepCallbackCommand> callback);
        /// <summary>
        /// 持续响应 API 客户端回调 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">最后一个参数必须为 Action{AutoCSer.Net.CommandClientReturnValue{T}, AutoCSer.Net.KeepCallbackCommand} 或者 Action{AutoCSer.Net.CommandClientReturnValue, AutoCSer.Net.KeepCallbackCommand} 或者 AutoCSer.Net.CommandClientKeepCallback{T} 或者 AutoCSer.Net.CommandClientKeepCallback</param>
        /// <returns>The return value type must be AutoCSer.Net.KeepCallbackCommand</returns>
        AutoCSer.Net.KeepCallbackCommand Callback(int left, int right, AutoCSer.Net.CommandClientKeepCallback<int> callback);
```
### 2.4 队列委托回调
[队列委托回调 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/IKeepCallbackQueueController.cs) 返回值类型为 [AutoCSer.Net.KeepCallbackCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/KeepCallbackCommand.cs)，最后一个参数类型为 Action<[AutoCSer.Net.CommandClientReturnValue<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs), [AutoCSer.Net.CommandClientCallQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientCallQueue.cs), [AutoCSer.Net.KeepCallbackCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/KeepCallbackCommand.cs)> 或者 Action<[AutoCSer.Net.CommandClientReturnValue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs), [AutoCSer.Net.CommandClientCallQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientCallQueue.cs), [AutoCSer.Net.KeepCallbackCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/KeepCallbackCommand.cs)> 或者 [AutoCSer.Net.CommandClientKeepCallbackQueue<T> 或者 AutoCSer.Net.CommandClientKeepCallbackQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientKeepCallbackQueue.cs) 表示回调委托，性能优于队列 await 回调 API。  
由于是队列线程同步触发回调，可以保证回调操作的串行执行，但不能保证后续 await 操作的串行执行。回调后续不允许存在同步阻塞操作，否则会严重影响回调队列的吞吐性能，甚至在复杂的依赖场景中可能造成队列调度死锁。
``` csharp
        /// <summary>
        /// 持续响应 API 客户端队列回调 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">最后一个参数类型必须为 Action{AutoCSer.Net.CommandClientReturnValue{T}, AutoCSer.Net.CommandClientCallQueue, AutoCSer.Net.KeepCallbackCommand} 或者 Action{AutoCSer.Net.CommandClientReturnValue, AutoCSer.Net.CommandClientCallQueue, AutoCSer.Net.KeepCallbackCommand} 或者 AutoCSer.Net.CommandClientKeepCallbackQueue{T} 或者 AutoCSer.Net.CommandClientKeepCallbackQueue</param>
        /// <returns>The return value type must be AutoCSer.Net.KeepCallbackCommand</returns>
        AutoCSer.Net.KeepCallbackCommand Callback(int left, int right, Action<AutoCSer.Net.CommandClientReturnValue<int>, AutoCSer.Net.CommandClientCallQueue, AutoCSer.Net.KeepCallbackCommand> callback);
        /// <summary>
        /// 持续响应 API 客户端队列回调 API 示例
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">最后一个参数类型必须为 Action{AutoCSer.Net.CommandClientReturnValue{T}, AutoCSer.Net.CommandClientCallQueue, AutoCSer.Net.KeepCallbackCommand} 或者 Action{AutoCSer.Net.CommandClientReturnValue, AutoCSer.Net.CommandClientCallQueue, AutoCSer.Net.KeepCallbackCommand} 或者 AutoCSer.Net.CommandClientKeepCallbackQueue{T} 或者 AutoCSer.Net.CommandClientKeepCallbackQueue</param>0
        /// <returns>The return value type must be AutoCSer.Net.KeepCallbackCommand</returns>
        AutoCSer.Net.KeepCallbackCommand Callback(int left, int right, AutoCSer.Net.CommandClientKeepCallbackQueue<int> callback);
```
## 3. 无响应
[无响应 API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/ISendOnlyCommandController.cs) 返回值类型为 [AutoCSer.Net.SendOnlyCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/SendOnlyCommand.cs)。
``` csharp
        /// <summary>
        /// 无响应 API 客户端 API 示例
        /// </summary>
        /// <param name="value"></param>
        /// <returns>The return value type must be AutoCSer.Net.SendOnlyCommand</returns>
        AutoCSer.Net.SendOnlyCommand Call(int value);
```
# 性能测试
从 .NET gRPC 与 AutoCSer RPC 的并发吞吐测试结果来看，对于同样的需求在高并发场景下，AutoCSer 的测试吞吐性能上限超过 .NET gRPC **一个数量级**。  
当然，无论 RPC 框架组件的吞吐性能有多高，它也不会是银弹，并**不能解决业务逻辑性能瓶颈问题**，它只能在网络交互这一个环节提供高吞吐性能。如果 API 的业务逻辑本身消耗比较大，那么框架组件提供的性能优势可能也就没有太多意义了。  
[.NET gRPC 测试服务端项目](https://github.com/AutoCSer/AutoCSer2/tree/main/TestCase/ThirdParty/GrpcServicePerformance)  
[.NET gRPC 测试客户端项目](https://github.com/AutoCSer/AutoCSer2/tree/main/TestCase/ThirdParty/GrpcClientPerformance)  
[AutoCSer RPC 测试服务端项目](https://github.com/AutoCSer/AutoCSer2/tree/main/TestCase/CommandServerPerformance)  
[AutoCSer RPC 测试客户端项目](https://github.com/AutoCSer/AutoCSer2/tree/main/TestCase/CommandServerPerformance/Client)  
# [鉴权与传输数据编码](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/04.ServiceAuthentication/04.ServiceAuthentication.md)