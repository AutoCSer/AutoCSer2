# RPC thread scheduling strategy
Symmetrical asynchronous apis can meet the requirements of the vast majority of applications, but they cannot select the appropriate thread scheduling mode based on the demand scenarios, so they cannot optimize the code structure and increase the upper limit of throughput performance for different demand scenarios.  
The content of this section is advanced knowledge and requires a **certain foundation in multithreading**. For developers who are not concerned about extreme throughput performance optimization or the thread scheduling principles of frameworks, they can [skip this section](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/04.ServiceAuthentication/04.ServiceAuthentication.Eng.md).
Due to the extensive content in this section, beginners may find some parts difficult to understand. Therefore, it is recommended that beginners only focus on the basic chapter content marked with **(Necessary)**. Other chapters can be gradually familiarized with as advanced knowledge after mastering the necessary basic chapter content.
# Response method **(Necessary)**
AutoCSer RPC is a full-duplex RPC component implemented based on TCP long connections, so the API supports three basic response methods.
## 1. One-time response **(Necessary)**
The most common response method is that there is only one server response or exception response per client request. The interface symmetric API is this response method.
## 2. Keep response **(Necessary)**
The **server-side push** method is sometimes referred to as a stream in some RPCS. A client request is used to create a response channel, and the server responds to the client multiple times using the channel.  
Of course, the one-time response method can also meet the push requirements, but the client will generate a large number of requests, and the serial response method will cause huge delays, seriously affecting the throughput performance.  
In addition to the regular server-side push requirements, there is a practical need for RPC: **large data packets should be split into appropriately sized small data sets** and responded to and output in multiple times.  
Since the response data of an RPC needs to be serialized into a single data packet for processing, overly large data packets can cause jitter in the network communication buffer, which may seriously affect throughput performance. Large data packets are common performance killers.  
If it is an open service, due to the uncontrollable number of clients, overly large data packets in a high-concurrency environment will cause the server to occupy a large amount of memory, easily leading to insufficient memory. Insufficient memory is a very serious problem and can easily lead to system-level failures.  
If it is an internal service, since the number of clients is small and controllable, setting a larger buffer can solve most problems, but the size of the data packets should still be adapted to the size of the buffer.
## 3. Unresponsive
The client-side push method, in this way, the server does not generate response data for the client's request, and the client cannot directly perceive the execution result of the server.  
This approach can be applied in scenarios where **lost requests are allowed**. For scenarios that require reliability, business logic needs to be introduced to assist in verification and retry mechanisms.
## 4. Two-stage response
For server-side push requirements related to status, it may be necessary to first push an initial data to the client, and then push a data change log record based on the initial data.  
Although combining one-time response and continuous response apis can meet this requirement, correctly implementing this function may require manual handling of some complex state processing logics. For instance, obtaining the initial data first and then triggering the continuous response might result in the loss of data change log records during this period.  
The two-stage response **encapsulates two callback delegates at once through an API**, which can simplify the state handling logic between the server and the client, and ensure the integrity of the client's data and the correctness of the data state from the perspective of network data interaction.
## Requests and Responses
When the server of AutoCSer RPC responds to the client, it does not directly send data to the client. Instead, it adds the response data object to an **output queue** and sends it asynchronously to the client by other threads, similar to the producer-consumer pattern.  
The request data sent by the client to the server is also in a similar pattern, as this is **conducive to the batch processing of the sent data**.  
This solution optimizes **throughput performance and overall latency metrics** in **high-concurrency** scenarios by **sacrificing the latency metrics of serial responses** (In fact, such sacrifices can be basically disregarded) in exchange for batch operation characteristics, as sacrificing a little bit of performance in low-concurrency scenarios is insignificant. In a simple and general understanding, it means that **the higher the concurrency, the better the throughput performance** before reaching the upper limit of concurrent throughput performance.
# Server-side thread scheduling strategy **(Necessary)**
Since most thread scheduling policies can be specified by API definitions, to avoid unnecessary Attribute configuration operations, after weighing the options, AutoCSer RPC mainly **defaults to specifying thread scheduling policies through API definitions**, and only uses attributes to assist in declaring thread scheduling policies in special scenarios.  
In the calling relationship of RPC, there are essential differences between the server and the client. The server is the called party, and the called and returned operations are an integrated whole. The client is the caller, while the call and callback are two separate steps.  
Therefore, there are **essential differences** in the thread scheduling principles and policy models between the server and the client. This is also the reason why the application service components that come with AutoCSer are defined using asymmetric apis.  
Before introducing the relationship between API definition and thread scheduling, it is particularly important to emphasize the common sense principle of high-performance concurrency. **Thread blocking is a taboo issue in concurrent performance**. In principle, thread blocking logic should never occur at any time, especially on the server side.  
The server of AutoCSer RPC supports a total of 7 [thread scheduling strategies](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Metadata/ServerMethodTypeEnum.cs). Therefore, there are 7 major types of server API definitions. Each thread scheduling type supports 4 response methods, and the same response method may have multiple API definition methods.
## 1. Task API **(Necessary)**
The return value type is required to be System.Threading.Tasks.Task<T> or System.Threading.Tasks.Task, and the system's asynchronous task scheduling is adopted. It is suitable for a large number of **unordered concurrent tasks** and is the **recommended type** for regular requirements.
### 1.1 One-time response **(Necessary)**
``` csharp
        /// <summary>
        /// One-time response API example
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be System.Threading.Tasks.Task or System.Threading.Tasks.Task{T}</returns>
        System.Threading.Tasks.Task<int> ISynchronousController.Add(int left, int right)
        {
            return System.Threading.Tasks.Task.FromResult(left + right);
        }
```
In addition to the necessary [synchronous pesponse API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Task/ISynchronousController.cs) that needs to be mastered, the [callback delegate response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Task/IKeepCallbackController.cs) is also supported, allowing the server to respond to client requests through delegate callbacks at appropriate times. It is mainly used for event-triggered callback response requirements.  
The return value type should be System.Threading.Tasks.Task, and the last parameter type should be [AutoCSer.Net.CommandServerCallback<T> or AutoCSer.Net.CommandServerCallback](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerCallback.cs) to indicate the callback delegate.  
This mode has high requirements for developers. **The delegate object cannot be discarded** before the callback operation is triggered; otherwise, the client API caller will remain in a state of waiting for a response until the socket connection is closed.
``` csharp
        /// <summary>
        /// Callback delegate API example
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">The last parameter type must be AutoCSer.Net.CommandServerCallback{T} or AutoCSer.Net.CommandServerCallback</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        System.Threading.Tasks.Task ICallbackController.Add(int left, int right, AutoCSer.Net.CommandServerCallback<int> callback)
        {
            callback.Callback(left + right);
            return AutoCSer.Common.CompletedTask;
        }
```
### 1.2 Keep response **(Necessary)**
The [keep callback delegate response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Task/IKeepCallbackController.cs) return value type is System.Threading.Tasks.Task, and the last parameter type is [AutoCSer.Net.CommandServerKeepCallback<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallback.cs), indicating a callback delegate, which is the recommended type for regular requirements.
``` csharp
        /// <summary>
        /// Callback delegate API example
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">For the callback delegate wrapper, the last parameter type must be AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        System.Threading.Tasks.Task IKeepCallbackController.Callback(int left, int right, AutoCSer.Net.CommandServerKeepCallback<int> callback)
        {
            do
            {
                if (!callback.Callback(left)) break;
            }
            while (left++ != right);
            return AutoCSer.Common.CompletedTask;
        }
```
In addition to the necessary **keep callback delegate response API**, the keep response API also supports multiple other definition methods for special demand scenarios.
If the frequency of callback response operations is too high, it may cause the network output operations to fail to keep up with the progress of the callback operations. The accumulation of a large number of output data objects in the output queue will occupy a large amount of memory, which not only causes performance issues for GC but may even lead to insufficient memory problems.  
This demand scenario should limit the frequency of callback response operations, allowing them to wait for network output. Using a callback delegate response API with **counting and waiting** functionality can control the memory usage of the output object, but it may sacrifice some of the current API's throughput performance.  
The **callback count delegate API** return value type is System.Threading.Tasks.Task, and the last parameter type of [AutoCSer.Net.CommandServerKeepCallbackCount<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallbackCount.cs) indicates the callback delegate.  
A **default response count of 1** will limit the batch operation characteristics. The [AutoCSer.Net.CommandServerMethodAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerMethodAttribute.cs).KeepCallbackOutputCount configuration value should be reasonably adjusted according to the actual business requirements.
``` csharp
        /// <summary>
        /// Callback count delegate API example
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">For the callback delegate wrapper, the last parameter type must be AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        [AutoCSer.Net.CommandServerMethod(KeepCallbackOutputCount = 1 << 10)]
        System.Threading.Tasks.Task CallbackCount(int left, int right, AutoCSer.Net.CommandServerKeepCallbackCount<int> callback);
```
``` csharp
        /// <summary>
        /// Callback count delegate API example
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">For the callback delegate wrapper, the last parameter type must be AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        async System.Threading.Tasks.Task IKeepCallbackController.CallbackCount(int left, int right, AutoCSer.Net.CommandServerKeepCallbackCount<int> callback)
        {
            do
            {
                if (!await callback.CallbackAsync(left)) return;
            }
            while (left++ != right);
        }
```
The return type of the **collection encapsulation API** is System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<T>>, which is an encapsulation of the callback count delegation API and is generally used for large data volume collections to be returned.
``` csharp
        /// <summary>
        /// Collection encapsulation API example
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{T}}</returns>
        System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<int>> IKeepCallbackController.Enumerable(int left, int right)
        {
            return System.Threading.Tasks.Task.FromResult(Enumerable.Range(left, right - left + 1));
        }
```
The return type of the **asynchronous flow API** is System.Collections.Generic.IAsyncEnumerable<T>, which is an encapsulation of the callback counting delegate API.
``` csharp
        /// <summary>
        /// Example of asynchronous stream API
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be System.Collections.Generic.IAsyncEnumerable{T}</returns>
        async System.Collections.Generic.IAsyncEnumerable<int> IKeepCallbackController.AsyncEnumerable(int left, int right)
        {
            do
            {
                yield return left;
            }
            while (left++ != right);
        }
```
### 1.3 Unresponsive
The return type of the [unresponsive API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Task/ISendOnlyController.cs) is System.Threading.Tasks.Task<[AutoCSer.Net.CommandServerSendOnly](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerSendOnly.cs)>.
``` csharp
        /// <summary>
        /// Unresponsive API example
        /// </summary>
        /// <param name="value"></param>
        /// <returns>The return value type must be System.Threading.Tasks.Task{AutoCSer.Net.CommandServerSendOnly}</returns>
        System.Threading.Tasks.Task<AutoCSer.Net.CommandServerSendOnly> ISendOnlyController.Call(int value)
        {
            Console.WriteLine($"{nameof(SendOnlyController)} {value}");
            return AutoCSer.Net.CommandServerSendOnly.NullTask;
        }
```
### 1.4 Two-stage response
For all [two-stage response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Task/ITwoStage‌CallbackController.cs), the penultimate parameter type of [AutoCSer.Net.CommandServerCallback<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerCallback.cs) represents the first-stage callback delegate, and the last parameter type of [AutoCSer.Net.CommandServerKeepCallback<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallback.cs) or [AutoCSer.Net.CommandServerKeepCallbackCount<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallbackCount.cs) represents the second-stage callback delegate. Data parameters named callback or keepCallback are not allowed.  
This type of API does not support [AutoCSer.Net.CommandServerMethodAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerMethodAttribute.cs) configuration, which means it does not support the automatic cancellation of callback operations. After all output operations are completed, **CancelKeep() must be manually called** to cancel the callback.  
The two-stage response API only has the return value type determined by the thread scheduling type. Other rules are independent of the thread scheduling type and will not be repeated below. For example, the return value type of the Task API is System.Threading.Tasks.Task.
``` csharp
        /// <summary>
        /// Callback delegate API example
        /// </summary>
        /// <param name="left"></param>
        /// <param name="count"></param>
        /// <param name="callback">For the callback wrapper in the first stage, the type of the penultimate parameter must be AutoCSer.Net.CommandServerCallback{T}</param>
        /// <param name="keepCallback">For the callback delegate wrapper of the second stage of continuous response, the last parameter type must be AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        System.Threading.Tasks.Task ITwoStage‌CallbackController.Callback(int left, int count, AutoCSer.Net.CommandServerCallback<TwoStageCallbackParameter> callback, AutoCSer.Net.CommandServerKeepCallback<int> keepCallback)
        {
            if (callback.Callback(new TwoStageCallbackParameter { Start = left, Count = count }))
            {
                int right = left + count;
                do
                {
                    if (!keepCallback.Callback(left)) return AutoCSer.Common.CompletedTask;
                }
                while (++left != right);
                keepCallback.CancelKeep();
            }
            return AutoCSer.Common.CompletedTask;
        }
        /// <summary>
        /// Callback count delegate API example
        /// </summary>
        /// <param name="left"></param>
        /// <param name="count"></param>
        /// <param name="callback">For the callback wrapper in the first stage, the type of the penultimate parameter must be AutoCSer.Net.CommandServerCallback{T}</param>
        /// <param name="keepCallback">For the callback delegate wrapper of the second stage of continuous response, the last parameter type must be AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        async System.Threading.Tasks.Task ITwoStage‌CallbackController.CallbackCount(int left, int count, AutoCSer.Net.CommandServerCallback<TwoStageCallbackParameter> callback, AutoCSer.Net.CommandServerKeepCallbackCount<int> keepCallback)
        {
            if (callback.Callback(new TwoStageCallbackParameter { Start = left, Count = count }))
            {
                int right = left + count;
                do
                {
                    if (!await keepCallback.CallbackAsync(left)) return;
                }
                while (++left != right);
                keepCallback.CancelKeep();
            }
        }
```
## 2. Task Read/write queue API
By adopting the asynchronous read-write queue task scheduling built into AutoCSer, since the **write operations of each queue are serialized**, the probability of resource contention between database transactions can be significantly reduced, that is, the probability of lock timeouts and deadlocks can be greatly decreased. It is a **recommended strategy for high-concurrency database transaction access**.  
A reasonable queue isolation design scheme can support **a large number of concurrent queue** accesses while avoiding resource competition issues between database transactions, that is, preventing lock timeouts and deadlocks.  
Serializing queue write operations can **ensure strong consistency between cache data and persistent data** in the queue context, and there is no need to consider thread safety issues when performing read and write operations on cache data.  
Read-write queues **sacrifice the concurrent throughput delay and performance of a single queue**. Therefore, the best practice is to access the local database through 127.0.0.1. Even in the worst environment, a **0ms delay for database access** should be guaranteed to avoid delay issues affecting the throughput performance of database access.  
On the surface, serializing write operations may sacrifice the concurrent throughput delay and performance of a single queue. However, in practice, the key point should be to ensure that transactions during peak hours do not experience lock timeouts due to resource competition issues. Lock timeouts not only seriously affect user experience but also, once they occur during peak hours, they will definitely cause an avalanche effect.  
For instance, in a multi-tenant model, the competition for resources among tenants is relatively weak. Isolation queues are designed based on tenants, and transactions within each tenant are concurrent, while transactions within a tenant are serial.  
The Task read-write queue API requires the return value type to be either System.Threading.Tasks.Task<T> or System.Threading.Tasks.Task, and does not allow data parameters named queueKey to exist. **Add a queue context parameter before the first data parameter**. Type [AutoCSer.Net.CommandServerCallTaskLowPriorityQueue<KT>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/TaskQueue/CommandServerCallTaskLowPriorityQueue.cs) represents a serial API for write operations, type [AutoCSer.Net.CommandServerCallTaskQueue<KT>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/TaskQueue/CommandServerCallTaskQueue.cs) represents a concurrent API for read operations, and the keyword type KT must implement the interface IEquatable<KT>. The field Key is the current queue keyword. The field ContextObject is used to store the context cache data of the current queue.
### 2.1 One-time response
``` csharp
        /// <summary>
        /// One-time response API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be System.Threading.Tasks.Task or System.Threading.Tasks.Task{T}</returns>
        System.Threading.Tasks.Task<int> ISynchronousController.Add(AutoCSer.Net.CommandServerCallTaskQueue<int> queue, int left, int right)
        {
            return System.Threading.Tasks.Task.FromResult(left + right);
        }
```
In addition to the [synchronous pesponse API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/TaskQueue/ISynchronousController.cs), the [callback delegate response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/TaskQueue/IKeepCallbackController.cs) is also supported, the return value type is System.Threading.Tasks.Task, and the last parameter type of [AutoCSer.Net.CommandServerCallback<T> or AutoCSer.Net.CommandServerCallback](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerCallback.cs) indicates a callback delegate.
``` csharp
        /// <summary>
        /// Callback delegate API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">The last parameter type must be AutoCSer.Net.CommandServerCallback{T} or AutoCSer.Net.CommandServerCallback</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        System.Threading.Tasks.Task ICallbackController.Add(AutoCSer.Net.CommandServerCallTaskQueue<int> queue, int left, int right, AutoCSer.Net.CommandServerCallback<int> callback)
        {
            callback.Callback(left + right);
            return AutoCSer.Common.CompletedTask;
        }
```
### 2.2 Keep response
The [keep callback delegate response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/TaskQueue/IKeepCallbackController.cs) return value type is System.Threading.Tasks.Task, and the last parameter type is [AutoCSer.Net.CommandServerKeepCallback<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallback.cs) indicates the callback delegate.
``` csharp
        /// <summary>
        /// Callback delegate API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">For the callback delegate wrapper, the last parameter type must be AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        System.Threading.Tasks.Task IKeepCallbackController.Callback(AutoCSer.Net.CommandServerCallTaskQueue<int> queue, int left, int right, AutoCSer.Net.CommandServerKeepCallback<int> callback)
        {
            do
            {
                if (!callback.Callback(left)) break;
            }
            while (left++ != right);
            return AutoCSer.Common.CompletedTask;
        }
```
The **callback count delegate API** return value type is System.Threading.Tasks.Task, and the last parameter type of [AutoCSer.Net.CommandServerKeepCallbackCount<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallbackCount.cs) indicates the callback delegate.
``` csharp
        /// <summary>
        /// Callback count delegate API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">For the callback delegate wrapper, the last parameter type must be AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        async System.Threading.Tasks.Task IKeepCallbackController.CallbackCount(AutoCSer.Net.CommandServerCallTaskQueue<int> queue, int left, int right, AutoCSer.Net.CommandServerKeepCallbackCount<int> callback)
        {
            do
            {
                if (!await callback.CallbackAsync(left)) return;
            }
            while (left++ != right);
        }
```
The return type of the **collection encapsulation API** is System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<T>>, which is an encapsulation of the callback count delegation API and is generally used for large data volume collections to be returned.
``` csharp
        /// <summary>
        /// Collection encapsulation API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{T}}</returns>
        System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<int>> IKeepCallbackController.Enumerable(AutoCSer.Net.CommandServerCallTaskQueue<int> queue, int left, int right)
        {
            return System.Threading.Tasks.Task.FromResult(Enumerable.Range(left, right - left + 1));
        }
```
The return type of the **asynchronous flow API** is System.Collections.Generic.IAsyncEnumerable<T>, which is an encapsulation of the callback counting delegate API.
``` csharp
        /// <summary>
        /// Example of asynchronous stream API
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be System.Collections.Generic.IAsyncEnumerable{T}</returns>
        async System.Collections.Generic.IAsyncEnumerable<int> IKeepCallbackController.AsyncEnumerable(AutoCSer.Net.CommandServerCallTaskQueue<int> queue, int left, int right)
        {
            do
            {
                yield return left;
            }
            while (left++ != right);
        }
```
### 2.3 Unresponsive
The return type of the [unresponsive API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/TaskQueue/ISendOnlyController.cs) is System.Threading.Tasks.Task<[AutoCSer.Net.CommandServerSendOnly](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerSendOnly.cs)>.
``` csharp
        /// <summary>
        /// Unresponsive API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="value"></param>
        /// <returns>The return value type must be System.Threading.Tasks.Task{AutoCSer.Net.CommandServerSendOnly}</returns>
        System.Threading.Tasks.Task<AutoCSer.Net.CommandServerSendOnly> ISendOnlyController.Call(AutoCSer.Net.CommandServerCallTaskQueue<int> queue, int value)
        {
            Console.WriteLine($"{nameof(SendOnlyController)} {queue.Key}.{value}");
            return AutoCSer.Net.CommandServerSendOnly.NullTask;
        }
```
### 2.4 Two-stage response
The return value type of the [two-stage response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/TaskQueue/ITwoStage‌CallbackController.cs) is System.Threading.Tasks.Task.
``` csharp
        /// <summary>
        /// Callback delegate API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="count"></param>
        /// <param name="callback">For the callback wrapper in the first stage, the type of the penultimate parameter must be AutoCSer.Net.CommandServerCallback{T}</param>
        /// <param name="keepCallback">For the callback delegate wrapper of the second stage of continuous response, the last parameter type must be AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        System.Threading.Tasks.Task ITwoStage‌CallbackController.Callback(AutoCSer.Net.CommandServerCallTaskQueue<int> queue, int left, int count, AutoCSer.Net.CommandServerCallback<TwoStageCallbackParameter> callback, AutoCSer.Net.CommandServerKeepCallback<int> keepCallback)
        {
            if (callback.Callback(new TwoStageCallbackParameter { Start = left, Count = count }))
            {
                int right = left + count;
                do
                {
                    if (!keepCallback.Callback(left)) return AutoCSer.Common.CompletedTask;
                }
                while (++left != right);
                keepCallback.CancelKeep();
            }
            return AutoCSer.Common.CompletedTask;
        }
        /// <summary>
        /// Callback count delegate API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="count"></param>
        /// <param name="callback">For the callback wrapper in the first stage, the type of the penultimate parameter must be AutoCSer.Net.CommandServerCallback{T}</param>
        /// <param name="keepCallback">For the callback delegate wrapper of the second stage of continuous response, the last parameter type must be AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        async System.Threading.Tasks.Task ITwoStage‌CallbackController.CallbackCount(AutoCSer.Net.CommandServerCallTaskQueue<int> queue, int left, int count, AutoCSer.Net.CommandServerCallback<TwoStageCallbackParameter> callback, AutoCSer.Net.CommandServerKeepCallbackCount<int> keepCallback)
        {
            if (callback.Callback(new TwoStageCallbackParameter { Start = left, Count = count }))
            {
                int right = left + count;
                do
                {
                    if (!await keepCallback.CallbackAsync(left)) return;
                }
                while (++left != right);
                keepCallback.CancelKeep();
            }
        }
```
### 2.5 Controller queue
The service controller supports binding a singleton instance of a Task read/write queue. The queue context parameters of the API within the controller do not have keyword type parameters. This singleton queue pattern is not suitable for database access operations with high concurrency requirements and is generally used for simple custom persistence operations.  
The [controller queue API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/TaskQueue/ITaskQueueController.cs) requires adding a queue context parameter before the first data parameter. Type [AutoCSer.Net.CommandServerCallTaskLowPriorityQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/TaskQueue/CommandServerCallTaskLowPriorityQueue.cs) represents a serial API for write operations, type [AutoCSer.Net.CommandServerCallTaskQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/TaskQueue/CommandServerCallTaskQueue.cs) represents a concurrent API for read operations, and the field ContextObject is used to store the context cache data of the current queue.  
To bind the Task read-write queue, the [AutoCSer.Net.CommandServerControllerInterfaceAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerControllerInterfaceAttribute.cs).TaskQueueMaxConcurrent parameter needs to be configured on the server controller interface.
``` csharp
    /// <summary>
    /// Server controller Task asynchronous read/write queue API sample interface
    /// </summary>
    [AutoCSer.Net.CommandServerControllerInterface(TaskQueueMaxConcurrent = 16)]
    public partial interface ITaskQueueController
```
## 3. Task queue controller API
Every API in the Task queue controller is a queue API, which is a strict serial queue operation. Essentially, it is a simplified and encapsulated special case of the Task read-write queue API.  
The controller must be derived from [AutoCSer.Net.CommandServerTaskQueueService<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerTaskQueueService.cs). The Queue keyword is obtained through the field Key, the queue context is obtained through the field Queue, and the current service socket context is obtained through the property Socket.
``` csharp
    /// <summary>
    /// Server-side Task asynchronous queue controller one-time response API sample controller
    /// </summary>
    internal sealed class SynchronousController : AutoCSer.Net.CommandServerTaskQueueService<int>, ISynchronousController
    {
        /// <summary>
        /// Server-side Task asynchronous queue controller
        /// </summary>
        /// <param name="task">The server asynchronously invokes the queue task</param>
        /// <param name="key">Queue keyword</param>
        public SynchronousController(AutoCSer.Net.CommandServerCallTaskQueueNode task, int key) : base(task, key) { }
    }
```
### 3.1 One-time response
``` csharp
        /// <summary>
        /// One-time response API example
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be System.Threading.Tasks.Task or System.Threading.Tasks.Task{T}</returns>
        System.Threading.Tasks.Task<int> ISynchronousController.Add(int left, int right)
        {
            return System.Threading.Tasks.Task.FromResult(left + right);
        }
```
In addition to the [synchronous pesponse API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/TaskQueueController/ISynchronousController.cs), the [callback delegate response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/TaskQueueController/IKeepCallbackController.cs) is also supported, the return value type is System.Threading.Tasks.Task, and the last parameter type of [AutoCSer.Net.CommandServerCallback<T> or AutoCSer.Net.CommandServerCallback](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerCallback.cs) indicates a callback delegate.
``` csharp
        /// <summary>
        /// Callback delegate API example
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">The last parameter type must be AutoCSer.Net.CommandServerCallback{T} or AutoCSer.Net.CommandServerCallback</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        System.Threading.Tasks.Task ICallbackController.Add(int left, int right, AutoCSer.Net.CommandServerCallback<int> callback)
        {
            callback.Callback(left + right);
            return AutoCSer.Common.CompletedTask;
        }
```
### 3.2 Keep response
The [keep callback delegate response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/TaskQueueController/IKeepCallbackController.cs) return value type is System.Threading.Tasks.Task, and the last parameter type is [AutoCSer.Net.CommandServerKeepCallback<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallback.cs) indicates the callback delegate.
``` csharp
        /// <summary>
        /// Callback delegate API example
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">For the callback delegate wrapper, the last parameter type must be AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        System.Threading.Tasks.Task IKeepCallbackController.Callback(int left, int right, AutoCSer.Net.CommandServerKeepCallback<int> callback)
        {
            do
            {
                if (!callback.Callback(left)) break;
            }
            while (left++ != right);
            return AutoCSer.Common.CompletedTask;
        }
```
The **callback count delegate API** return value type is System.Threading.Tasks.Task, and the last parameter type of [AutoCSer.Net.CommandServerKeepCallbackCount<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallbackCount.cs) indicates the callback delegate.
``` csharp
        /// <summary>
        /// Callback count delegate API example
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">For the callback delegate wrapper, the last parameter type must be AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be System.Threading.Tasks.Task</returns>
        async System.Threading.Tasks.Task IKeepCallbackController.CallbackCount(int left, int right, AutoCSer.Net.CommandServerKeepCallbackCount<int> callback)
        {
            do
            {
                if (!await callback.CallbackAsync(left)) return;
            }
            while (left++ != right);
        }
```
The return type of the **collection encapsulation API** is System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<T>>, which is an encapsulation of the callback count delegation API and is generally used for large data volume collections to be returned.
``` csharp
        /// <summary>
        /// Collection encapsulation API example
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{T}}</returns>
        System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<int>> IKeepCallbackController.Enumerable(int left, int right)
        {
            return System.Threading.Tasks.Task.FromResult(Enumerable.Range(left, right - left + 1));
        }
```
The return type of the **asynchronous flow API** is System.Collections.Generic.IAsyncEnumerable<T>, which is an encapsulation of the callback counting delegate API.
``` csharp
        /// <summary>
        /// Example of asynchronous stream API
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be System.Collections.Generic.IAsyncEnumerable{T}</returns>
        async System.Collections.Generic.IAsyncEnumerable<int> IKeepCallbackController.AsyncEnumerable(int left, int right)
        {
            do
            {
                yield return left;
            }
            while (left++ != right);
        }
```
### 2.3 Unresponsive
The return type of the [unresponsive API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/TaskQueueController/ISendOnlyController.cs) is System.Threading.Tasks.Task<[AutoCSer.Net.CommandServerSendOnly](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerSendOnly.cs)>.
``` csharp
        /// <summary>
        /// Unresponsive API example
        /// </summary>
        /// <param name="value"></param>
        /// <returns>The return value type must be System.Threading.Tasks.Task{AutoCSer.Net.CommandServerSendOnly}</returns>
        System.Threading.Tasks.Task<AutoCSer.Net.CommandServerSendOnly> ISendOnlyController.Call(int value)
        {
            Console.WriteLine($"{nameof(SendOnlyController)} {Key}.{value}");
            return AutoCSer.Net.CommandServerSendOnly.NullTask;
        }
```
## 4. Thread queue API
Strict single-threaded serial operation is suitable for **lightweight in-memory computing** services without persistence requirements, such as in-memory cache services, in-memory database services, message queue services, in-memory search engine services, in-game services, and in-memory data flow computing services, etc.  
Each queue occupies one resident thread. Each service controller can be configured with one default queue. In addition, up to 255 additional queues are supported. For regular services, it is recommended to allocate queue threads reasonably based on the expected concurrent pressure. The total number of queues should not exceed the number of CPU core threads.  
The thread queue API requires adding a queue context parameter before the first data parameter. In general scenarios, type [AutoCSer.Net.CommandServerCallQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/Queue/CommandServerCallQueue.cs) is used, while in special scenarios, type [AutoCSer.Net.CommandServerCallLowPriorityQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/Queue/CommandServerCallLowPriorityQueue.cs) is used. The difference lies in that the former has a higher execution probability of priority than the latter. The field ContextObject is used to store the context cache data of the current queue.
### 4.1 One-time response
The [synchronous pesponse API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Queue/ISynchronousController.cs) supports but does not recommend using the ref/out parameter, as it will cause the client to only use the thread blocking synchronization waiting API mode.
``` csharp
        /// <summary>
        /// Synchronous API example, supporting ref/out parameters
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        int Add(AutoCSer.Net.CommandServerCallQueue queue, int left, int right);
```
The [callback delegate response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Queue/ICallbackController.cs) return value type is void, and the last parameter type of [AutoCSer.Net.CommandServerCallback<T> or AutoCSer.Net.CommandServerCallback](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerCallback.cs) indicates a callback delegate.
``` csharp
        /// <summary>
        /// Callback delegate API example, supporting ref/out parameters
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">The callback commission wrapper must be the last parameter</param>
        void ICallbackController.Add(AutoCSer.Net.CommandServerCallQueue queue, int left, int right, AutoCSer.Net.CommandServerCallback<int> callback)
        {
            callback.Callback(left + right);
        }
```
### 4.2 Keep response
The [keep callback delegate response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Queue/IKeepCallbackController.cs) return value type is System.Threading.Tasks.Task, and the last parameter type is [AutoCSer.Net.CommandServerKeepCallback<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallback.cs) indicates the callback delegate.
``` csharp
        /// <summary>
        /// Callback delegate API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">For the callback delegate wrapper, the last parameter type must be AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be void</returns>
        void IKeepCallbackController.Callback(AutoCSer.Net.CommandServerCallQueue queue, int left, int right, AutoCSer.Net.CommandServerKeepCallback<int> callback)
        {
            Task.KeepCallbackController.Callback(left, right, callback);
        }
```
The **callback count delegate API** return value type is void, and the last parameter type of [AutoCSer.Net.CommandServerKeepCallbackCount<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallbackCount.cs) indicates the callback delegate. Since this callback adopts the Task asynchronous mode, it is not recommended to trigger synchronous blocking operations such as GetResult() in the synchronous API.
``` csharp
        /// <summary>
        /// Callback count delegate API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">For the callback delegate wrapper, the last parameter type must be AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be void</returns>
        void IKeepCallbackController.CallbackCount(AutoCSer.Net.CommandServerCallQueue queue, int left, int right, AutoCSer.Net.CommandServerKeepCallbackCount<int> callback)
        {
            do
            {
                if (!callback.CallbackAsync(left).GetResult()) return;
            }
            while (left++ != right);
        }
```
### 4.3 Unresponsive
The return type of the [unresponsive API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Queue/ISendOnlyController.cs) is [AutoCSer.Net.CommandServerSendOnly](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerSendOnly.cs).
``` csharp
        /// <summary>
        /// Unresponsive API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="value"></param>
        /// <returns>The return value type must be AutoCSer.Net.CommandServerSendOnly</returns>
        AutoCSer.Net.CommandServerSendOnly ISendOnlyController.Call(AutoCSer.Net.CommandServerCallQueue queue, int value)
        {
            Console.WriteLine($"{nameof(SendOnlyController)} {value}");
            return AutoCSer.Net.CommandServerSendOnly.Null;
        }
```
### 4.4 Two-stage response
The return value type of the [two-stage response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Queue/ITwoStage‌CallbackController.cs) is void.
``` csharp
        /// <summary>
        /// Callback delegate API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="count"></param>
        /// <param name="callback">For the callback wrapper in the first stage, the type of the penultimate parameter must be AutoCSer.Net.CommandServerCallback{T}</param>
        /// <param name="keepCallback">For the callback delegate wrapper of the second stage of continuous response, the last parameter type must be AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be void</returns>
        void ITwoStage‌CallbackController.Callback(AutoCSer.Net.CommandServerCallQueue queue, int left, int count, AutoCSer.Net.CommandServerCallback<TwoStageCallbackParameter> callback, AutoCSer.Net.CommandServerKeepCallback<int> keepCallback)
        {
            if (callback.Callback(new TwoStageCallbackParameter { Start = left, Count = count }))
            {
                int right = left + count;
                do
                {
                    if (!keepCallback.Callback(left)) return;
                }
                while (++left != right);
                keepCallback.CancelKeep();
            }
        }
```
## 5. Concurrent read thread queue API
The default thread scheduling strategy customized for the AutoCSer [in-memory database](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/06.MemoryDatabase/06.MemoryDatabase.Eng.md) also strictly follows a single-threaded serial operation for regular operations. To reduce the impact of [the operation to obtain and reconstruct persistent snapshot data](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/08.MemoryDatabaseCustomNode/08.MemoryDatabaseCustomNode.Eng.md) blocking normal services, this mode allows this operation to run in parallel with other normal read request operations.  
Each queue occupies two resident threads. Each service controller can bind an independent queue instance. If the relevant API is not defined in the service controller, no queue instance will be created.  
The concurrent read thread queue API requires adding a queue context parameter before the first data parameter. Type [AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/ConcurrencyReadQueue/CommandServerCallConcurrencyReadWriteQueue.cs) represents a write operation, type [AutoCSer.Net.CommandServerCallConcurrencyReadQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/ConcurrencyReadQueue/CommandServerCallConcurrencyReadQueue.cs) represents a read operation, and the field ContextObject is used to store the context cache data of the current queue.
### 5.1 One-time response
The [synchronous pesponse API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/ConcurrencyReadQueue/ISynchronousController.cs) supports but does not recommend using the ref/out parameter, as it will cause the client to only use the thread blocking synchronization waiting API mode.
``` csharp
        /// <summary>
        /// Synchronous API example, supporting ref/out parameters
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        int Add(AutoCSer.Net.CommandServerCallConcurrencyReadQueue queue, int left, int right);
```
The [callback delegate response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/ConcurrencyReadQueue/ICallbackController.cs) return value type is void, and the last parameter type of [AutoCSer.Net.CommandServerCallback<T> or AutoCSer.Net.CommandServerCallback](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerCallback.cs) indicates a callback delegate.
``` csharp
        /// <summary>
        /// Callback delegate API example, supporting ref/out parameters
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">The callback commission wrapper must be the last parameter</param>
        void ICallbackController.Add(AutoCSer.Net.CommandServerCallConcurrencyReadQueue queue, int left, int right, AutoCSer.Net.CommandServerCallback<int> callback)
        {
            callback.Callback(left + right);
        }
```
### 5.2 Keep response
The [keep callback delegate response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/ConcurrencyReadQueue/IKeepCallbackController.cs) return value type is void, and the last parameter type is [AutoCSer.Net.CommandServerKeepCallback<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallback.cs) indicates the callback delegate.
``` csharp
        /// <summary>
        /// Callback delegate API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">For the callback delegate wrapper, the last parameter type must be AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be void</returns>
        void IKeepCallbackController.Callback(AutoCSer.Net.CommandServerCallConcurrencyReadQueue queue, int left, int right, AutoCSer.Net.CommandServerKeepCallback<int> callback)
        {
            do
            {
                if (!callback.Callback(left)) break;
            }
            while (left++ != right);
        }
```
The **callback count delegate API** return value type is void, and the last parameter type of [AutoCSer.Net.CommandServerKeepCallbackCount<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallbackCount.cs) indicates the callback delegate. Since this callback adopts the Task asynchronous mode, it is not recommended to trigger synchronous blocking operations such as GetResult() in the synchronous API.
``` csharp
        /// <summary>
        /// Callback count delegate API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">For the callback delegate wrapper, the last parameter type must be AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be void</returns>
        void IKeepCallbackController.CallbackCount(AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue queue, int left, int right, AutoCSer.Net.CommandServerKeepCallbackCount<int> callback)
        {
            do
            {
                if (!callback.CallbackAsync(left).GetResult()) return;
            }
            while (left++ != right);
        }
```
### 5.3 Unresponsive
The return type of the [unresponsive API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/ConcurrencyReadQueue/ISendOnlyController.cs) is [AutoCSer.Net.CommandServerSendOnly](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerSendOnly.cs).
``` csharp
        /// <summary>
        /// Unresponsive API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="value"></param>
        /// <returns>The return value type must be AutoCSer.Net.CommandServerSendOnly</returns>
        AutoCSer.Net.CommandServerSendOnly ISendOnlyController.Call(AutoCSer.Net.CommandServerCallConcurrencyReadQueue queue, int value)
        {
            Console.WriteLine($"{nameof(SendOnlyController)} {value}");
            return AutoCSer.Net.CommandServerSendOnly.Null;
        }
```
### 5.4 Two-stage response
The return value type of the [two-stage response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/ConcurrencyReadQueue/ITwoStage‌CallbackController.cs) is void.
``` csharp
        /// <summary>
        /// Callback delegate API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="count"></param>
        /// <param name="callback">For the callback wrapper in the first stage, the type of the penultimate parameter must be AutoCSer.Net.CommandServerCallback{T}</param>
        /// <param name="keepCallback">For the callback delegate wrapper of the second stage of continuous response, the last parameter type must be AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be void</returns>
        void ITwoStage‌CallbackController.Callback(AutoCSer.Net.CommandServerCallConcurrencyReadQueue queue, int left, int count, AutoCSer.Net.CommandServerCallback<TwoStageCallbackParameter> callback, AutoCSer.Net.CommandServerKeepCallback<int> keepCallback)
        {
            if (callback.Callback(new TwoStageCallbackParameter { Start = left, Count = count }))
            {
                int right = left + count;
                do
                {
                    if (!keepCallback.Callback(left)) return;
                }
                while (++left != right);
                keepCallback.CancelKeep();
            }
        }
```
## 6. Read-write queue thread API
An optional thread scheduling strategy customized for the AutoCSer [in-memory database](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/06.MemoryDatabase/06.MemoryDatabase.Eng.md). This mode allows specifying the number of threads for read operations to execute read operations in parallel, making it suitable for scenarios where read operations are dominant and there are a large number of CPU core threads.  
Each queue occupies a specified number of resident threads. Each service controller can bind an independent queue instance. If the relevant API is not defined in the service controller, no queue instance will be created.  
The read-write queue thread API requires adding a queue context parameter before the first data parameter. Type [AutoCSer.Net.CommandServerCallWriteQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/ReadWriteQueue/CommandServerCallWriteQueue.cs) represents a write operation, type [AutoCSer.Net.CommandServerCallReadQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/ReadWriteQueue/CommandServerCallReadQueue.cs) represents a concurrent read operation, and the field ContextObject is used to store the context cache data of the current queue.
### 6.1 One-time response
The [synchronous pesponse API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/ReadWriteQueue/ISynchronousController.cs) supports but does not recommend using the ref/out parameter, as it will cause the client to only use the thread blocking synchronization waiting API mode.
``` csharp
        /// <summary>
        /// Synchronous API example, supporting ref/out parameters
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        int Add(AutoCSer.Net.CommandServerCallReadQueue queue, int left, int right);
```
The [callback delegate response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/ReadWriteQueue/ICallbackController.cs) return value type is void, and the last parameter type of [AutoCSer.Net.CommandServerCallback<T> or AutoCSer.Net.CommandServerCallback](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerCallback.cs) indicates a callback delegate.
``` csharp
        /// <summary>
        /// Callback delegate API example, supporting ref/out parameters
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">The callback commission wrapper must be the last parameter</param>
        void ICallbackController.Add(AutoCSer.Net.CommandServerCallReadQueue queue, int left, int right, AutoCSer.Net.CommandServerCallback<int> callback)
        {
            callback.Callback(left + right);
        }
```
### 6.2 Keep response
The [keep callback delegate response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/ReadWriteQueue/IKeepCallbackController.cs) return value type is void, and the last parameter type is [AutoCSer.Net.CommandServerKeepCallback<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallback.cs) indicates the callback delegate.
``` csharp
        /// <summary>
        /// Callback delegate API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">For the callback delegate wrapper, the last parameter type must be AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be void</returns>
        void IKeepCallbackController.Callback(AutoCSer.Net.CommandServerCallReadQueue queue, int left, int right, AutoCSer.Net.CommandServerKeepCallback<int> callback)
        {
            do
            {
                if (!callback.Callback(left)) break;
            }
            while (left++ != right);
        }
```
The **callback count delegate API** return value type is void, and the last parameter type of [AutoCSer.Net.CommandServerKeepCallbackCount<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallbackCount.cs) indicates the callback delegate. Since this callback adopts the Task asynchronous mode, it is not recommended to trigger synchronous blocking operations such as GetResult() in the synchronous API.
``` csharp
        /// <summary>
        /// Callback count delegate API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">For the callback delegate wrapper, the last parameter type must be AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be void</returns>
        void IKeepCallbackController.CallbackCount(AutoCSer.Net.CommandServerCallWriteQueue queue, int left, int right, AutoCSer.Net.CommandServerKeepCallbackCount<int> callback)
        {
            do
            {
                if (!callback.CallbackAsync(left).GetResult()) return;
            }
            while (left++ != right);
        }
```
### 6.3 Unresponsive
The return type of the [unresponsive API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/ReadWriteQueue/ISendOnlyController.cs) is [AutoCSer.Net.CommandServerSendOnly](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerSendOnly.cs).
``` csharp
        /// <summary>
        /// Unresponsive API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="value"></param>
        /// <returns>The return value type must be AutoCSer.Net.CommandServerSendOnly</returns>
        AutoCSer.Net.CommandServerSendOnly ISendOnlyController.Call(AutoCSer.Net.CommandServerCallReadQueue queue, int value)
        {
            Console.WriteLine($"{nameof(SendOnlyController)} {value}");
            return AutoCSer.Net.CommandServerSendOnly.Null;
        }
```
### 6.4 Two-stage response
The return value type of the [two-stage response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/ReadWriteQueue/ITwoStage‌CallbackController.cs) is void.
``` csharp
        /// <summary>
        /// Callback delegate API example
        /// </summary>
        /// <param name="queue">The current execution queue context must be defined before the first data parameter</param>
        /// <param name="left"></param>
        /// <param name="count"></param>
        /// <param name="callback">For the callback wrapper in the first stage, the type of the penultimate parameter must be AutoCSer.Net.CommandServerCallback{T}</param>
        /// <param name="keepCallback">For the callback delegate wrapper of the second stage of continuous response, the last parameter type must be AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be void</returns>
        void ITwoStage‌CallbackController.Callback(AutoCSer.Net.CommandServerCallReadQueue queue, int left, int count, AutoCSer.Net.CommandServerCallback<TwoStageCallbackParameter> callback, AutoCSer.Net.CommandServerKeepCallback<int> keepCallback)
        {
            if (callback.Callback(new TwoStageCallbackParameter { Start = left, Count = count }))
            {
                int right = left + count;
                do
                {
                    if (!keepCallback.Callback(left)) return;
                }
                while (++left != right);
                keepCallback.CancelKeep();
            }
        }
```
## 7. IO thread synchronization API
It is directly **executed in the I/O callback thread that receives data through the socket**, without the overhead of thread switching. It is only suitable for **lightweight in-memory computing** apis, such as obtaining the current time of the server and allocating global identities.
### 7.1 One-time response
The [synchronous pesponse API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Synchronous/ISynchronousController.cs) supports but does not recommend using the ref/out parameter, as it will cause the client to only use the thread blocking synchronization waiting API mode.
``` csharp
        /// <summary>
        /// Synchronous API example, supporting ref/out parameters
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        int Add(int left, int right);
```
The [callback delegate response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Synchronous/ICallbackController.cs) return value type is void, and the last parameter type of [AutoCSer.Net.CommandServerCallback<T> or AutoCSer.Net.CommandServerCallback](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerCallback.cs) indicates a callback delegate.
``` csharp
        /// <summary>
        /// Callback delegate API example, supporting ref/out parameters
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">The callback commission wrapper must be the last parameter</param>
        void ICallbackController.Add(int left, int right, AutoCSer.Net.CommandServerCallback<int> callback)
        {
            callback.Callback(left + right);
        }
```
### 7.2 Keep response
The [keep callback delegate response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Synchronous/IKeepCallbackController.cs) return value type is void, and the last parameter type is [AutoCSer.Net.CommandServerKeepCallback<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallback.cs) indicates the callback delegate.
``` csharp
        /// <summary>
        /// Callback delegate API example
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">For the callback delegate wrapper, the last parameter type must be AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be void</returns>
        void IKeepCallbackController.Callback(int left, int right, AutoCSer.Net.CommandServerKeepCallback<int> callback)
        {
            do
            {
                if (!callback.Callback(left)) break;
            }
            while (left++ != right);
        }
```
The **callback count delegate API** return value type is void, and the last parameter type of [AutoCSer.Net.CommandServerKeepCallbackCount<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerCall/CommandServerKeepCallbackCount.cs) indicates the callback delegate. Since this callback adopts the Task asynchronous mode, it is not recommended to trigger synchronous blocking operations such as GetResult() in the synchronous API.
``` csharp
        /// <summary>
        /// Callback count delegate API example
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">For the callback delegate wrapper, the last parameter type must be AutoCSer.Net.CommandServerKeepCallbackCount{T}</param>
        /// <returns>The return value type must be void</returns>
        void IKeepCallbackController.CallbackCount(int left, int right, AutoCSer.Net.CommandServerKeepCallbackCount<int> callback)
        {
            do
            {
                if (!callback.CallbackAsync(left).GetResult()) return;
            }
            while (left++ != right);
        }
```
### 7.3 Unresponsive
The return type of the [unresponsive API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Synchronous/ISendOnlyController.cs) is [AutoCSer.Net.CommandServerSendOnly](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerSendOnly.cs).
``` csharp
        /// <summary>
        /// Unresponsive API example
        /// </summary>
        /// <param name="value"></param>
        /// <returns>The return value type must be AutoCSer.Net.CommandServerSendOnly</returns>
        AutoCSer.Net.CommandServerSendOnly ISendOnlyController.Call(int value)
        {
            Console.WriteLine($"{nameof(SendOnlyController)} {value}");
            return AutoCSer.Net.CommandServerSendOnly.Null;
        }
```
### 7.4 Two-stage response
The return value type of the [two-stage response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Server/Synchronous/ITwoStage‌CallbackController.cs) is void.
``` csharp
        /// <summary>
        /// Callback delegate API example
        /// </summary>
        /// <param name="left"></param>
        /// <param name="count"></param>
        /// <param name="callback">For the callback wrapper in the first stage, the type of the penultimate parameter must be AutoCSer.Net.CommandServerCallback{T}</param>
        /// <param name="keepCallback">For the callback delegate wrapper of the second stage of continuous response, the last parameter type must be AutoCSer.Net.CommandServerKeepCallback{T}</param>
        /// <returns>The return value type must be void</returns>
        void ITwoStage‌CallbackController.Callback(int left, int count, AutoCSer.Net.CommandServerCallback<TwoStageCallbackParameter> callback, AutoCSer.Net.CommandServerKeepCallback<int> keepCallback)
        {
            if (callback.Callback(new TwoStageCallbackParameter { Start = left, Count = count }))
            {
                int right = left + count;
                do
                {
                    if (!keepCallback.Callback(left)) return;
                }
                while (++left != right);
                keepCallback.CancelKeep();
            }
        }
```
# Client callback thread scheduling strategy **(Necessary)**
The [definition of the client API](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Metadata/ClientMethodTypeEnum.cs) depends on the **response method** of the server API and is independent of the server's thread scheduling strategy. The same response method may have multiple client API definition methods, so it is allowed for multiple client apis to match to the same server API.  
The return value type, data parameter type, name and order of the client API must all match those of the server API. Although the default client interfaces and API definitions for regular requirements can be generated using [static code generation tools](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/05.CodeGenerator.Eng.md), it is still recommended to have a brief understanding of the manual code pattern.  
The client keyword parameter name matched by the server-side Task queue controller API must be queueKey and must be placed in the first parameter position.
## 1. One-time response **(Necessary)**
### 1.1 await callback **(Necessary)**
The [await callback API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/IReturnCommandController.cs) return value type is [AutoCSer.Net.ReturnCommand<T> or AutoCSer.Net.ReturnCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/ReturnCommand.cs), and the callback method is specified through [AutoCSer.Net.CommandClientMethodAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandClientMethodAttribute.cs).CallbackType, which is the **default recommended type** for regular requirements.
``` csharp
        /// <summary>
        /// One-time response API client await callback API sample
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be AutoCSer.Net.ReturnCommand or AutoCSer.Net.ReturnCommand{T}</returns>
        [AutoCSer.Net.CommandClientMethod(CallbackType = AutoCSer.Net.CommandServer.ClientCallbackTypeEnum.RunTask)]
        AutoCSer.Net.ReturnCommand<int> Add(int left, int right);
```
The **Task API** return value type is System.Threading.Tasks.Task<T> or System.Threading.Tasks.Task. A call status error will throw an exception. It is not recommended for performance-sensitive projects.
``` csharp
        /// <summary>
        /// One-time response API client Task API sample
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        [AutoCSer.Net.CommandClientMethod(MatchMethodName = nameof(Add))]
        System.Threading.Tasks.Task<int> AddAsync(int left, int right);
```
### 1.2 Queue await callback
The [queue await callback API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/IReturnQueueCommandController.cs) return value type is [AutoCSer.Net.ReturnQueueCommand<T> or AutoCSer.Net.ReturnQueueCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/ReturnQueueCommand.cs).  
Since the callback is triggered synchronously by the queue thread, it can ensure the serial execution of the callback operation, but it cannot guarantee the serial execution of the subsequent await operation. No synchronous blocking operations are allowed after the callback; otherwise, it will seriously affect the throughput performance of the callback queue and may even cause a queue scheduling deadlock in complex dependency scenarios.
``` csharp
        /// <summary>
        /// One-time response API client queue await callback API sample
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be AutoCSer.Net.ReturnCommand or AutoCSer.Net.ReturnCommand{T}</returns>
        AutoCSer.Net.ReturnQueueCommand<int> Add(int left, int right);
```
### 1.3 Delegate callback
The [delegate callback API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/ICallbackController.cs) return value type is [AutoCSer.Net.CallbackCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/CallbackCommand.cs). The callback method is specified through [AutoCSer.Net.CommandClientMethodAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandClientMethodAttribute.cs).CallbackType. The last parameter type is Action<[AutoCSer.Net.CommandClientReturnValue<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs)>, Action<[AutoCSer.Net.CommandClientReturnValue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs)>, [AutoCSer.Net.CommandClientCallback<T> or AutoCSer.Net.CommandClientCallback](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientCallback.cs), indicating the callback delegate.
``` csharp
        /// <summary>
        /// One-time response API client callback API sample
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">The last parameter type must be Action{AutoCSer.Net.CommandClientReturnValue{T}} or Action{AutoCSer.Net.CommandClientReturnValue} or AutoCSer.Net.CommandClientCallback{T} or AutoCSer.Net.CommandClientCallback</param>
        /// <returns>The return value type must be AutoCSer.Net.CallbackCommand</returns>
        AutoCSer.Net.CallbackCommand Add(int left, int right, Action<AutoCSer.Net.CommandClientReturnValue<int>> callback);
        /// <summary>
        /// One-time response API client callback API sample
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">The last parameter type must be Action{AutoCSer.Net.CommandClientReturnValue{T}} or Action{AutoCSer.Net.CommandClientReturnValue} or AutoCSer.Net.CommandClientCallback{T} or AutoCSer.Net.CommandClientCallback</param>
        /// <returns>The return value type must be AutoCSer.Net.CallbackCommand</returns>
        AutoCSer.Net.CallbackCommand Add(int left, int right, AutoCSer.Net.CommandClientCallback<int> callback);
```
### 1.4 Queue delegate callback
The [queue delegate callback API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/ICallbackQueueController.cs) return value type is [AutoCSer.Net.CallbackCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/CallbackCommand.cs). The callback method is specified through [AutoCSer.Net.CommandClientMethodAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandClientMethodAttribute.cs).CallbackType. The last parameter type is Action<[AutoCSer.Net.CommandClientReturnValue<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs), [AutoCSer.Net.CommandClientCallQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientCallQueue.cs)>, Action<[AutoCSer.Net.CommandClientReturnValue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs), [AutoCSer.Net.CommandClientCallQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientCallQueue.cs)>, [AutoCSer.Net.CommandClientCallbackQueueNode<T> or AutoCSer.Net.CommandClientCallbackQueueNode](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientCallbackQueueNode.cs), indicating the callback delegate.  
Since the callback is triggered synchronously by the queue thread, it can ensure the serial execution of the callback operation, but it cannot guarantee the serial execution of the subsequent await operation. No synchronous blocking operations are allowed after the callback; otherwise, it will seriously affect the throughput performance of the callback queue and may even cause a queue scheduling deadlock in complex dependency scenarios.
``` csharp
        /// <summary>
        /// One-time response API client queue callback API sample
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">The last parameter type must be Action{AutoCSer.Net.CommandClientReturnValue{T}, AutoCSer.Net.CommandClientCallQueue} or Action{AutoCSer.Net.CommandClientReturnValue, AutoCSer.Net.CommandClientCallQueue} or AutoCSer.Net.CommandClientCallbackQueueNode{T} or AutoCSer.Net.CommandClientCallbackQueueNode</param>
        /// <returns>The return value type must be AutoCSer.Net.CallbackCommand</returns>
        AutoCSer.Net.CallbackCommand Add(int left, int right, Action<AutoCSer.Net.CommandClientReturnValue<int>, AutoCSer.Net.CommandClientCallQueue> callback);
        /// <summary>
        /// One-time response API client queue callback API sample
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">The last parameter type must be Action{AutoCSer.Net.CommandClientReturnValue{T}, AutoCSer.Net.CommandClientCallQueue} or Action{AutoCSer.Net.CommandClientReturnValue, AutoCSer.Net.CommandClientCallQueue} or AutoCSer.Net.CommandClientCallbackQueueNode{T} or AutoCSer.Net.CommandClientCallbackQueueNode</param>
        /// <returns>The return value type must be AutoCSer.Net.CallbackCommand</returns>
        AutoCSer.Net.CallbackCommand Add(int left, int right, AutoCSer.Net.CommandClientCallbackQueueNode<int> callback);
```
### 1.5 Synchronous API
The [synchronous API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/ICommandClientReturnValueController.cs) return value type is [AutoCSer.Net.CommandClientReturnValue<T> or AutoCSer.Net.CommandClientReturnValue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs), supports ref/out parameters, and specifies the callback method through [AutoCSer.Net.CommandClientMethodAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandClientMethodAttribute.cs).CallbackType. It is not recommended.
``` csharp
        /// <summary>
        /// One-time response API client synchronization API sample
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be AutoCSer.Net.CommandClientReturnValue or AutoCSer.Net.CommandClientReturnValue{T}</returns>
        AutoCSer.Net.CommandClientReturnValue<int> Add(int left, int right);
```
## 2. Keep response **(Necessary)**
### 2.1 await callback **(Necessary)**
The [await callback API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/IEnumeratorCommandController.cs) return value type is [AutoCSer.Net.EnumeratorCommand<T> or AutoCSer.Net.EnumeratorCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/EnumeratorCommand.cs), and the callback method is specified through [AutoCSer.Net.CommandClientMethodAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandClientMethodAttribute.cs).CallbackType, which is the **default recommended type** for regular requirements.
``` csharp
        /// <summary>
        /// Keep response API client await API sample
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be AutoCSer.Net.EnumeratorCommand or AutoCSer.Net.EnumeratorCommand{T}</returns>
        AutoCSer.Net.EnumeratorCommand<int> Callback(int left, int right);
```
### 2.2 Queue await callback
The [queue await callback API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/IEnumeratorQueueCommandController.cs) return value type is [AutoCSer.Net.EnumeratorQueueCommand<T> or AutoCSer.Net.EnumeratorQueueCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/EnumeratorQueueCommand.cs).  
Since the callback is triggered synchronously by the queue thread, it can ensure the serial execution of the callback operation, but it cannot guarantee the serial execution of the subsequent await operation. No synchronous blocking operations are allowed after the callback; otherwise, it will seriously affect the throughput performance of the callback queue and may even cause a queue scheduling deadlock in complex dependency scenarios.
``` csharp
        /// <summary>
        /// Keep response API client queue await API sample
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns>The return value type must be AutoCSer.Net.EnumeratorQueueCommand or AutoCSer.Net.EnumeratorQueueCommand{T}</returns>
        AutoCSer.Net.EnumeratorQueueCommand<int> Callback(int left, int right);
```
### 2.3 Delegate callback
The [delegate callback API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/IKeepCallbackController.cs) return value type is [AutoCSer.Net.KeepCallbackCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/KeepCallbackCommand.cs), and the callback method is specified through [AutoCSer.Net.CommandClientMethodAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandClientMethodAttribute.cs).CallbackType. The last parameter type of Action<[AutoCSer.Net.CommandClientReturnValue<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs), [AutoCSer.Net.KeepCallbackCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/KeepCallbackCommand.cs)>, Action<[AutoCSer.Net.CommandClientReturnValue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs), [AutoCSer.Net.KeepCallbackCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/KeepCallbackCommand.cs)>, [AutoCSer.Net.CommandClientKeepCallback<T> or AutoCSer.Net.CommandClientKeepCallback](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientKeepCallback.cs) indicates a callback delegate, which performs better than the await callback API.
``` csharp
        /// <summary>
        /// Keep response API client callback API sample
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">The last parameter type must be Action{AutoCSer.Net.CommandClientReturnValue{T}, AutoCSer.Net.KeepCallbackCommand} or Action{AutoCSer.Net.CommandClientReturnValue, AutoCSer.Net.KeepCallbackCommand} or AutoCSer.Net.CommandClientKeepCallback{T} or AutoCSer.Net.CommandClientKeepCallback</param>
        /// <returns>The return value type must be AutoCSer.Net.KeepCallbackCommand</returns>
        AutoCSer.Net.KeepCallbackCommand Callback(int left, int right, Action<AutoCSer.Net.CommandClientReturnValue<int>, AutoCSer.Net.KeepCallbackCommand> callback);
        /// <summary>
        /// Keep response API client callback API sample
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">The last parameter type must be Action{AutoCSer.Net.CommandClientReturnValue{T}, AutoCSer.Net.KeepCallbackCommand} or Action{AutoCSer.Net.CommandClientReturnValue, AutoCSer.Net.KeepCallbackCommand} or AutoCSer.Net.CommandClientKeepCallback{T} or AutoCSer.Net.CommandClientKeepCallback</param>
        /// <returns>The return value type must be AutoCSer.Net.KeepCallbackCommand</returns>
        AutoCSer.Net.KeepCallbackCommand Callback(int left, int right, AutoCSer.Net.CommandClientKeepCallback<int> callback);
```
### 2.4 Queue delegate callback
The [queue delegate callback API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/IKeepCallbackQueueController.cs) return value type is [AutoCSer.Net.KeepCallbackCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/KeepCallbackCommand.cs), and the callback method is specified through [AutoCSer.Net.CommandClientMethodAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandClientMethodAttribute.cs).CallbackType. The last parameter type of Action<[AutoCSer.Net.CommandClientReturnValue<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs), [AutoCSer.Net.CommandClientCallQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientCallQueue.cs), [AutoCSer.Net.KeepCallbackCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/KeepCallbackCommand.cs)>, Action<[AutoCSer.Net.CommandClientReturnValue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs), [AutoCSer.Net.CommandClientCallQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientCallQueue.cs), [AutoCSer.Net.KeepCallbackCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/KeepCallbackCommand.cs)>, [AutoCSer.Net.CommandClientKeepCallbackQueue<T> or AutoCSer.Net.CommandClientKeepCallbackQueue](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientKeepCallbackQueue.cs) indicates a callback delegate, which performs better than the queue await callback API.  
Since the callback is triggered synchronously by the queue thread, it can ensure the serial execution of the callback operation, but it cannot guarantee the serial execution of the subsequent await operation. No synchronous blocking operations are allowed after the callback; otherwise, it will seriously affect the throughput performance of the callback queue and may even cause a queue scheduling deadlock in complex dependency scenarios.
``` csharp
        /// <summary>
        /// Keep response API client queue callback API sample
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">The last parameter type must be Action{AutoCSer.Net.CommandClientReturnValue{T}, AutoCSer.Net.CommandClientCallQueue, AutoCSer.Net.KeepCallbackCommand} or Action{AutoCSer.Net.CommandClientReturnValue, AutoCSer.Net.CommandClientCallQueue, AutoCSer.Net.KeepCallbackCommand} or AutoCSer.Net.CommandClientKeepCallbackQueue{T} or AutoCSer.Net.CommandClientKeepCallbackQueue</param>
        /// <returns>The return value type must be AutoCSer.Net.KeepCallbackCommand</returns>
        AutoCSer.Net.KeepCallbackCommand Callback(int left, int right, Action<AutoCSer.Net.CommandClientReturnValue<int>, AutoCSer.Net.CommandClientCallQueue, AutoCSer.Net.KeepCallbackCommand> callback);
        /// <summary>
        /// Keep response API client queue callback API sample
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="callback">The last parameter type must be Action{AutoCSer.Net.CommandClientReturnValue{T}, AutoCSer.Net.CommandClientCallQueue, AutoCSer.Net.KeepCallbackCommand} or Action{AutoCSer.Net.CommandClientReturnValue, AutoCSer.Net.CommandClientCallQueue, AutoCSer.Net.KeepCallbackCommand} or AutoCSer.Net.CommandClientKeepCallbackQueue{T} or AutoCSer.Net.CommandClientKeepCallbackQueue</param>
        /// <returns>The return value type must be AutoCSer.Net.KeepCallbackCommand</returns>
        AutoCSer.Net.KeepCallbackCommand Callback(int left, int right, AutoCSer.Net.CommandClientKeepCallbackQueue<int> callback);
```
## 3. Unresponsive
The [unresponsive API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/ISendOnlyCommandController.cs) return value type is [AutoCSer.Net.SendOnlyCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/SendOnlyCommand.cs).
``` csharp
        /// <summary>
        /// Example of an unresponsive API client API
        /// </summary>
        /// <param name="value"></param>
        /// <returns>The return value type must be AutoCSer.Net.SendOnlyCommand</returns>
        AutoCSer.Net.SendOnlyCommand Call(int value);
```
## 4. Two-stage response
The return value type of the [two-stage response API](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/Client/ITwoStageCallbackController.cs) is [AutoCSer.Net.KeepCallbackCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/KeepCallbackCommand.cs). The second-to-last parameter type Action<[AutoCSer.Net.CommandClientReturnValue<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs)> represents the first-stage callback delegation, and the last parameter type Action<[AutoCSer.Net.CommandClientReturnValue<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandClientCall/CommandClientReturnValue.cs), [AutoCSer.Net.KeepCallbackCommand](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/Command/KeepCallbackCommand.cs)> represents the second-stage callback delegation.  
To ensure the correctness of the response data operation sequence, the two-stage response API directly uses IO threads to synchronize callbacks. Therefore, **blocking operations are not allowed during callback operations**; otherwise, it will seriously affect the system's throughput performance and is very likely to cause system scheduling deadlocks.
``` csharp
        /// <summary>
        /// Two-stage response API client callback API sample
        /// </summary>
        /// <param name="left"></param>
        /// <param name="count"></param>
        /// <param name="callback">For the callback delegation in the first stage, the type of the penultimate parameter must be Action{AutoCSer.Net.CommandClientReturnValue{T}}</param>
        /// <param name="keepCallback">For the callback delegation with continuous response in the second stage, the last parameter type must be Action{AutoCSer.Net.CommandClientReturnValue{T}, AutoCSer.Net.KeepCallbackCommand}</param>
        /// <returns>The return value type must be AutoCSer.Net.KeepCallbackCommand</returns>
        AutoCSer.Net.KeepCallbackCommand Callback(int left, int count, Action<AutoCSer.Net.CommandClientReturnValue<TwoStageCallbackParameter>> callback, Action<AutoCSer.Net.CommandClientReturnValue<int>, AutoCSer.Net.KeepCallbackCommand> keepCallback);
```
From the above example, it can be seen that the return value of the client API **carries information about the network interaction status**. Many developers are not accustomed to this type of API return value. They are accustomed to the way apis directly return the required data types and obtain network interaction status error information by receiving Exception exceptions. AutoCSer provides [static code generation](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/05.CodeGenerator/05.CodeGenerator.Eng.md) tools that can be used to generate API encapsulation code that directly returns the required data types.
# Performance testing
Judging from the concurrent throughput test results of .NET gRPC and AutoCSer RPC, for the same requirements, in high-concurrency scenarios, the upper limit of the test throughput performance of AutoCSer RPC exceeds that of .NET gRPC by **one order of magnitude**.  
Of course, no matter how high the throughput performance of RPC framework components is, it is not a silver bullet and **cannot solve the performance bottleneck problem of business logic**. It can only provide high throughput performance in the network interaction link. If the business logic of the API itself consumes a lot, then the performance advantages provided by the framework components may not be very meaningful.  
[.NET gRPC test server project](https://github.com/AutoCSer/AutoCSer2/tree/main/TestCase/ThirdParty/GrpcServicePerformance)  
[.NET gRPC test client project](https://github.com/AutoCSer/AutoCSer2/tree/main/TestCase/ThirdParty/GrpcClientPerformance)  
[AutoCSer RPC test server project](https://github.com/AutoCSer/AutoCSer2/tree/main/TestCase/CommandServerPerformance)  
[AutoCSer RPC test client project](https://github.com/AutoCSer/AutoCSer2/tree/main/TestCase/CommandServerPerformance/Client)
# [Authentication and transmission data encoding](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/04.ServiceAuthentication/04.ServiceAuthentication.Eng.md)