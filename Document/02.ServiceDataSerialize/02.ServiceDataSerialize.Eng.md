# RPC data serialization
The data interaction between RPC clients and servers involves the mutual conversion between instances of application layer data types such as API parameters and return values and network byte order data. The operation of converting application layer data into byte-order data is called serialization, and the reverse operation is deserialization.  
In order to unify and simplify the serialization processing logic of API interaction data, AutoCSer RPC generates two structs to encapsulate API interaction data, representing input data and output data respectively.  
The input data members consist of API parameters other than those modified by out, while the output data members are composed of return values and parameters modified by ref/out. The ref/out parameters of apis with return values are not allowed to be named as ReturnValue.
``` csharp
        /// <param name="left">Input parameter</param>
        /// <param name="right">Input parameter + Output parameter</param>
        /// <param name="sum">Output parameter</param>
        /// <returns>Output parameter</returns>
        bool Add(int left, ref int right, out int sum);
```
For example, the input data and output data generated by the above API definition are defined as follows:
``` csharp
    public struct InputParameter
    {
        public int left;
        public int right;
    }
    public struct OutputParameter
    {
        public bool ReturnValue;
        public int right;
        public int sum;
    }
```
AutoCSer RPC data interaction built-in supports three serialization modes, ranked by performance as follows: simple data serialization, binary serialization, and JSON mixed binary serialization.  
API of input data and output data serialization of the model by the service interface configuration of [AutoCSer.Net.CommandServerControllerInterfaceAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Net/CommandServer/CommandServerControllerInterfaceAttribute.cs) IsSimpleSerializeInputParameter and IsSimpleSerializeOutputParameter stated, A default value of true indicates that simple data serialization operations are preferred; otherwise, binary serialization operations are adopted.
# Simple data serialization
Simple data serialization is actually a simplified version of binary serialization, which **only supports the struct** data type and requires all members to be **field members** of the specified common data types. The supported data member types are as follows:
``` text
bool, byte, sbyte, short, ushort, int, uint, long, ulong, float, double, decimal, char, DateTime,TimeSpan, Guid, enum, string, byte[], Int128, UInt128, Half
bool?, byte?, sbyte?, short?, ushort?, int?, uint?, long?, ulong?, float?, double?, decimal?, char?, DateTime?,TimeSpan?, Guid?
System.Numerics.Complex, System.Numerics.Plane, System.Numerics.Quaternion, System.Numerics.Matrix3x2, System.Numerics.Matrix4x4, System.Numerics.Vector2, System.Numerics.Vector3, System.Numerics.Vector4
```
The simple data serialization API is not open to developers. For instance, the struct InputParameter and struct OutputParameter generated in the example introduced above both meet the definition requirements.
# Binary serialization
The built-in binary serialization operation of AutoCSer does not serialize member names but only member data. Therefore, it is only suitable for scenarios where **data definitions remain stable**. For scenarios where the stability of data definitions cannot be determined, it should be declared as **JSON mixed binary serialization**.  
Note: To make the default serialization operation simple and efficient, **a maximum of 64 layers of object nesting structures are supported** by default to avoid stack overflow issues. For special data types like linked lists, interface System.Collections.Generic.ICollection<T> or custom serialization operations should be implemented.
## 1. JSON mixed binary serialization
The difference between this mode and JSON serialization lies in the **use of binary format serialization operations on data members**. Compared with JSON serialization, it has certain performance advantages and can also achieve compatibility with API version updates to a certain extent.  
To specify the type as JSON mixed binary serialization mode, you need to add the serialization configuration [AutoCSer.BinarySerializeAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/BinarySerialize/BinarySerializeAttribute.cs) to the type definition and [set IsJsonMix to true](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/02.ServiceDataSerialize/BinarySerialize/JsonMix.cs). After setting this parameter, the binary serialization operation will call the JSON serialization component to perform the actual serialization operation, so other binary serialization configurations will be ignored.
``` csharp
    /// <summary>
    /// Example of JSON mixed binary serialization
    /// </summary>
    [AutoCSer.BinarySerialize(IsJsonMix = true)]
    class JsonMix
```
## 2. Object reference checking
Binary serialization checks for duplicate object references by default to **support circular references to objects**.  
Object reference checking logic consumes certain resources. For data types that are certain not to generate circular references, object reference checking logic can be [manually configured to be disabled](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/02.ServiceDataSerialize/BinarySerialize/DisabledReference.cs). After disabling the reference checking logic, the deserialization operation of the same reference object will generate multiple independent objects.
``` csharp
    /// <summary>
    /// Disable the object reference check example
    /// </summary>
    [AutoCSer.BinarySerialize(IsReferenceMember = false)]
    class DisabledReference
```
## 3. Member selection
By default, binary serialization members select **all field members visible to the current type**, including public/protected/private fields defined by the current type and anonymous fields generated by **automatically implemented properties**, as well as all public/protected fields defined by the parent type. Also include the internal field of the current assembly.  
For example, if you only want to serialize public fields, you can [configure to select public field members](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/02.ServiceDataSerialize/BinarySerialize/PublicInstanceField.cs).
``` csharp
    /// <summary>
    /// Only select the examples of public field members
    /// </summary>
    [AutoCSer.BinarySerialize(Filter = AutoCSer.Metadata.MemberFiltersEnum.PublicInstanceField)]
    class PublicInstanceField
```
When serialization operations need to mask individual special members, you can add a serialization member configuration [AutoCSer.BinarySerializeMemberAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/BinarySerialize/BinarySerializeMemberAttribute.cs) to that member and [set IsIgnoreCurrent to true](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/02.ServiceDataSerialize/BinarySerialize/IgnoreMember.cs).
``` csharp
    /// <summary>
    /// Ignore the member example
    /// </summary>
    class IgnoreMember
    {
        /// <summary>
        /// Ignore the current member
        /// </summary>
        [AutoCSer.BinarySerializeMember(IsIgnoreCurrent = true)]
        public int Ignore;
    }
```
## 4. Base type serialization
When the serialization operations of all subtypes of a certain type need to ignore the specificity of the subtypes and be unified as serialization operations of this type, this type can be [configured as the base type serialization](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/02.ServiceDataSerialize/BinarySerialize/BaseType.cs).
``` csharp
    /// <summary>
    /// Example of base class serialization
    /// </summary>
    [AutoCSer.BinarySerialize(IsBaseType = true)]
    class BaseType
```
## 5. Custom serialization
The type of custom serialization logic must implement interface [AutoCSer.BinarySerialize.ICustomSerialize<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/BinarySerialize/ICustomSerialize.cs) and ensure the **symmetry** of serialization and deserialization operations. It is not recommended to directly read and write data streams. Instead, it should be converted to a regular data type and processed by [calling CustomSerialize and CustomDeserialize](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/02.ServiceDataSerialize/BinarySerialize/Custom.cs).
``` csharp
    /// <summary>
    /// Custom serialization example
    /// </summary>
    class Custom : AutoCSer.BinarySerialize.ICustomSerialize<Custom>
    {
        /// <summary>
        /// Field data
        /// </summary>
        int Value;
        /// <summary>
        /// Custom serialization
        /// </summary>
        /// <param name="serializer"></param>
        void AutoCSer.BinarySerialize.ICustomSerialize<Custom>.Serialize(AutoCSer.BinarySerializer serializer)
        {
            serializer.CustomSerialize(Value.ToString());
        }
        /// <summary>
        /// Custom deserialization
        /// </summary>
        /// <param name="deserializer"></param>
        void AutoCSer.BinarySerialize.ICustomSerialize<Custom>.Deserialize(AutoCSer.BinaryDeserializer deserializer)
        {
            var stringValue = default(string);
            if (deserializer.CustomDeserialize(ref stringValue)) Value = int.Parse(stringValue.AutoCSerClassGenericTypeExtensions().NotNull());
        }
    }
```
# JSON serialization
The built-in JSON serialization of AutoCSer does **not support circular references**, and multiple references to the same object will result in multiple serialization operations. **Developers need to be cautious to avoid circular reference issues**.  
When the binary serialization configuration is set to JSON mixed binary serialization, other related binary serialization configurations will become invalid. The JSON serialization configuration type is [AutoCSer.JsonSerializeAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Json/JsonSerializeAttribute.cs).
## 1. Member selection
By default, JSON serialization members select **all field and property members visible to the current type**, including public/protected/private fields and properties defined by the current type, as well as all public/protected fields and properties defined by the parent type. In addition, it includes the internal field and properties of the current assembly.  
For example, if you only want to serialize public fields, you can [configure to select public field members](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/02.ServiceDataSerialize/JsonSerialize/PublicInstanceField.cs).
``` csharp
    /// <summary>
    /// Only select the examples of public field members
    /// </summary>
    [AutoCSer.JsonSerialize(Filter = AutoCSer.Metadata.MemberFiltersEnum.PublicInstanceField)]
    class PublicInstanceField
```
When serialization operations need to mask individual special members, you can add a serialization member configuration [AutoCSer.JsonSerializeMemberAttribute](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Json/JsonSerializeMemberAttribute.cs) to that member and [set IsIgnoreCurrent to true](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/02.ServiceDataSerialize/JsonSerialize/IgnoreMember.cs).
``` csharp
    /// <summary>
    /// Ignore the member example
    /// </summary>
    class IgnoreMember
    {
        /// <summary>
        /// Ignore the current member
        /// </summary>
        [AutoCSer.JsonSerializeMember(IsIgnoreCurrent = true)]
        public int Ignore;
    }
```
## 2. Base type serialization
When the serialization operations of all subtypes of a certain type need to ignore the specificity of the subtypes and be unified as serialization operations of this type, this type can be [configured as the base type serialization](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/02.ServiceDataSerialize/JsonSerialize/BaseType.cs).
``` csharp
    /// <summary>
    /// Example of base class serialization
    /// </summary>
    [AutoCSer.JsonSerialize(IsBaseType = true)]
    class BaseType
```
## 3. Custom serialization
The type of custom serialization logic must implement interface [AutoCSer.Json.ICustomSerialize<T>](https://github.com/AutoCSer/AutoCSer2/blob/main/AutoCSer/Json/ICustomSerialize.cs) and ensure the **symmetry** of serialization and deserialization operations. It is not recommended to directly read and write data streams. Instead, it should be converted to a regular data type and processed by [calling CustomSerialize and CustomDeserialize](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/02.ServiceDataSerialize/JsonSerialize/Custom.cs).
``` csharp
    /// <summary>
    /// Custom serialization example
    /// </summary>
    class Custom : AutoCSer.Json.ICustomSerialize<Custom>
    {
        /// <summary>
        /// Field data
        /// </summary>
        int Value;
        /// <summary>
        /// Custom serialization
        /// </summary>
        /// <param name="serializer"></param>
        void AutoCSer.Json.ICustomSerialize<Custom>.Serialize(AutoCSer.JsonSerializer serializer)
        {
            serializer.CustomSerialize(Value.ToString());
        }
        /// <summary>
        /// Custom deserialization
        /// </summary>
        /// <param name="deserializer"></param>
        void AutoCSer.Json.ICustomSerialize<Custom>.Deserialize(AutoCSer.JsonDeserializer deserializer)
        {
            var stringValue = default(string);
            if (deserializer.CustomDeserialize(ref stringValue)) Value = int.Parse(stringValue.AutoCSerClassGenericTypeExtensions().NotNull());
        }
    }
```

For more serialization functions, please refer to the sample code of the [documentation project](https://github.com/AutoCSer/AutoCSer2/tree/main/Document/02.ServiceDataSerialize).
# [Thread scheduling strategy](https://github.com/AutoCSer/AutoCSer2/blob/main/Document/03.ServiceThreadStrategy/03.ServiceThreadStrategy.Eng.md)