//This file is automatically generated by a program. Please do not modify it by yourself.
//本文件由程序自动生成，请不要自行修改
using System;
using System.Numerics;
using AutoCSer;

#if NoAutoCSer
#else
#pragma warning disable
namespace AutoCSer.CommandService
{
        /// <summary>
        /// Log stream persistence in-memory database service interface 
///            日志流持久化内存数据库服务接口
        /// </summary>
        [AutoCSer.Net.CommandServer.ServerControllerInterface(typeof(IStreamPersistenceMemoryDatabaseServiceMethodEnum))]
        public partial interface IStreamPersistenceMemoryDatabaseService { }
        /// <summary>
        /// Log stream persistence in-memory database service interface 
///            日志流持久化内存数据库服务接口 (The method sequence number maps the enumeration type)
        /// </summary>
        public enum IStreamPersistenceMemoryDatabaseServiceMethodEnum
        {
            /// <summary>
            /// [0] Add the directory and file information of the repair method from the node 
///            从节点添加修复方法目录与文件信息
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue queue 
            /// long timestamp The timestamp of create the slave node client 
///            创建从节点客户端时间戳
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.RepairNodeMethodDirectory directory Directory information of the repair method 
///            修复方法目录信息
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.RepairNodeMethodFile file File information of the repair method 
///            修复方法文件信息
            /// </summary>
            AppendRepairNodeMethodDirectoryFile = 0,
            /// <summary>
            /// [1] Bind a new method to dynamically add interface functionality. The initial state of the new method number must be free 
///            绑定新方法，用于动态增加接口功能，新增方法编号初始状态必须为空闲状态
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index 
            /// byte[] rawAssembly Assembly file data 
///            程序集文件数据
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.RepairNodeMethodName methodName The name of the repair method must be a static method. The first parameter must be the interface type of the operation node. The method number and other necessary configuration information must be configured using AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethodAttribute.MethodIndex 
///            修复方法名称，必须是静态方法，第一个参数必须是操作节点接口类型，必须使用 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethodAttribute.MethodIndex 配置方法编号与其他必要配置信息
            /// AutoCSer.Net.CommandServerCallback{AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum} callback 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum 
            /// </summary>
            BindNodeMethod = 1,
            /// <summary>
            /// [2] Call the node method 
///            调用节点方法
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadQueue queue 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// int methodIndex Call method number 
///            调用方法编号
            /// AutoCSer.Net.CommandServerCallback{AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum} callback 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum 
            /// </summary>
            Call = 2,
            /// <summary>
            /// [3] Call the node method 
///            调用节点方法
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadQueue queue 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.RequestParameter parameter Request parameters 
///            请求参数
            /// AutoCSer.Net.CommandServerCallback{AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum} callback 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum 
            /// </summary>
            CallInput = 3,
            /// <summary>
            /// [4] Call the node method 
///            调用节点方法
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadQueue queue 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.RequestParameter parameter Request parameters 
///            请求参数
            /// AutoCSer.Net.CommandServerCallback{AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter} callback The callback of reutrn parameter 
///            返回参数回调
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter 
            /// </summary>
            CallInputOutput = 4,
            /// <summary>
            /// [5] Call the node method 
///            调用节点方法
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadQueue queue 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// int methodIndex Call method number 
///            调用方法编号
            /// AutoCSer.Net.CommandServerCallback{AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter} callback The callback of reutrn parameter 
///            返回参数回调
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter 
            /// </summary>
            CallOutput = 5,
            /// <summary>
            /// [6] Check whether the header of the persistent callback exception location file matches 
///            检查持久化回调异常位置文件头部是否匹配
            /// uint fileHeadVersion The header version information of the persistent callback exception location file 
///            持久化回调异常位置文件头部版本信息
            /// ulong rebuildPosition The starting position of persistent flow rebuild 
///            持久化流重建起始位置
            /// 返回值 long The written location of the persistent callback exception location file. Return -1 in case of failure 
///            持久化回调异常位置文件已写入位置，失败返回 -1
            /// </summary>
            CheckPersistenceCallbackExceptionPositionFileHead = 6,
            /// <summary>
            /// [7] Check whether the header of the persistent file matches 
///            检查持久化文件头部是否匹配
            /// uint fileHeadVersion The header version information of the persistent file 
///            持久化文件头部版本信息
            /// ulong rebuildPosition The starting position of persistent flow rebuild 
///            持久化流重建起始位置
            /// 返回值 long The persistent stream has been written to the location and returns -1 in case of failure 
///            持久化流已写入位置，失败返回 -1
            /// </summary>
            CheckPersistenceFileHead = 7,
            /// <summary>
            /// [8] Create a slave node 
///            创建从节点
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue queue 
            /// bool isBackup Is the backup client 
///            是否备份客户端
            /// 返回值 long Verify the timestamp from the node, and a negative number represents the CallStateEnum error status 
///            从节点验证时间戳，负数表示 CallStateEnum 错误状态
            /// </summary>
            CreateSlave = 8,
            /// <summary>
            /// [9] Get node identity 
///            获取节点标识
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue queue 
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// bool isCreate Create a free node identity when the keyword does not exist 
///            关键字不存在时创建空闲节点标识
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex When the keyword does not exist, return an free node identifier for creating the node 
///            关键字不存在时返回一个空闲节点标识用于创建节点
            /// </summary>
            GetNodeIndex = 9,
            /// <summary>
            /// [10] Get the location data of the persistent callback exception 
///            获取持久化回调异常位置数据
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue queue 
            /// long timestamp The timestamp of create the slave node client 
///            创建从节点客户端时间戳
            /// AutoCSer.Net.CommandServerKeepCallback{long} callback 
            /// 返回值 long 
            /// </summary>
            GetPersistenceCallbackExceptionPosition = 10,
            /// <summary>
            /// [11] Get the file data of the persistent callback exception location 
///            获取持久化回调异常位置文件数据
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue queue 
            /// long timestamp The timestamp of create the slave node client 
///            创建从节点客户端时间戳
            /// uint fileHeadVersion The header version information of the persistent callback exception location file 
///            持久化回调异常位置文件头部版本信息
            /// ulong rebuildPosition The starting position of persistent flow rebuild 
///            持久化流重建起始位置
            /// long position The starting position of the read file 
///            读取文件起始位置
            /// AutoCSer.Net.CommandServerKeepCallback{AutoCSer.CommandService.StreamPersistenceMemoryDatabase.PersistenceFileBuffer} callback 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.PersistenceFileBuffer 
            /// </summary>
            GetPersistenceCallbackExceptionPositionFile = 11,
            /// <summary>
            /// [12] Get the persistent file data 
///            获取持久化文件数据
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue queue 
            /// long timestamp The timestamp of create the slave node client 
///            创建从节点客户端时间戳
            /// uint fileHeadVersion The header version information of the persistent file 
///            持久化文件头部版本信息
            /// ulong rebuildPosition The starting position of persistent flow rebuild 
///            持久化流重建起始位置
            /// long position The starting position of the read file 
///            读取文件起始位置
            /// AutoCSer.Net.CommandServerKeepCallback{AutoCSer.CommandService.StreamPersistenceMemoryDatabase.PersistenceFileBuffer} callback 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.PersistenceFileBuffer 
            /// </summary>
            GetPersistenceFile = 12,
            /// <summary>
            /// [13] Get the current write location of the persistent stream 
///            获取持久化流已当前写入位置
            /// 返回值 long 
            /// </summary>
            GetPersistencePosition = 13,
            /// <summary>
            /// [14] Get the end position of the rebuild snapshot 
///            获取重建快照结束位置
            /// 返回值 long The end position of the rebuild snapshot 
///            重建快照结束位置
            /// </summary>
            GetRebuildSnapshotPosition = 14,
            /// <summary>
            /// [15] Get the repair node method information from slave node 
///            从节点获取修复节点方法信息
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue queue 
            /// long timestamp The timestamp of create the slave node client 
///            创建从节点客户端时间戳
            /// AutoCSer.Net.CommandServerKeepCallback{AutoCSer.CommandService.StreamPersistenceMemoryDatabase.RepairNodeMethodPosition} callback The callback delegate for get the method information of the repair node 
///            获取修复节点方法信息回调委托
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.RepairNodeMethodPosition 
            /// </summary>
            GetRepairNodeMethodPosition = 15,
            /// <summary>
            /// [16] Get the server UTC time 
///            获取服务端 UTC 时间
            /// 返回值 System.DateTime 
            /// </summary>
            GetUtcNow = 16,
            /// <summary>
            /// [17] Call the node method 
///            调用节点方法
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadQueue queue 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.RequestParameter parameter Request parameters 
///            请求参数
            /// AutoCSer.Net.CommandServerKeepCallback{AutoCSer.CommandService.StreamPersistenceMemoryDatabase.KeepCallbackResponseParameter} callback The return parameters of the keep callback 
///            返回参数回调
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.KeepCallbackResponseParameter 
            /// </summary>
            InputKeepCallback = 17,
            /// <summary>
            /// [18] Call the node method 
///            调用节点方法
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadQueue queue 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// int methodIndex Call method number 
///            调用方法编号
            /// AutoCSer.Net.CommandServerKeepCallback{AutoCSer.CommandService.StreamPersistenceMemoryDatabase.KeepCallbackResponseParameter} callback The return parameters of the keep callback 
///            返回参数回调
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.KeepCallbackResponseParameter 
            /// </summary>
            KeepCallback = 18,
            /// <summary>
            /// [19] Rebuild the persistent file (clear invalid data), and note that nodes that do not support snapshots will be discarded 
///            重建持久化文件（清除无效数据），注意不支持快照的节点将被抛弃
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue queue 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.RebuildResult 
            /// </summary>
            Rebuild = 19,
            /// <summary>
            /// [20] Remove the information from the node client 
///            移除从节点客户端信息
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue queue 
            /// long timestamp The timestamp of create the slave node client 
///            创建从节点客户端时间戳
            /// </summary>
            RemoveSlave = 20,
            /// <summary>
            /// [21] Fix the interface method error and force overwriting the original interface method call. Except for the first parameter being the operation node object, the method definition must be consistent 
///            修复接口方法错误，强制覆盖原接口方法调用，除了第一个参数为操作节点对象，方法定义必须一致
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index 
            /// byte[] rawAssembly Assembly file data 
///            程序集文件数据
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.RepairNodeMethodName methodName The name of the repair method must be a static method. The first parameter must be the interface type of the operation node, and the method number must be configured using AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethodAttribute.MethodIndex 
///            修复方法名称，必须是静态方法，第一个参数必须是操作节点接口类型，必须使用 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerMethodAttribute.MethodIndex 配置方法编号
            /// AutoCSer.Net.CommandServerCallback{AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum} callback 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum 
            /// </summary>
            RepairNodeMethod = 21,
            /// <summary>
            /// [22] Call the node method 
///            调用节点方法
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadQueue queue 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.RequestParameter parameter Request parameters 
///            请求参数
            /// </summary>
            SendOnly = 22,
            /// <summary>
            /// [23] Gets the node index information for all matching nodes 
///            获取所有匹配节点的节点索引信息
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo The server-side node information to be matched 
///            待匹配的服务端节点信息
            /// AutoCSer.Net.CommandServerKeepCallbackCount{AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex} callback 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex 
            /// </summary>
            GetNodeIndexs = 23,
            /// <summary>
            /// [24] Gets the global keyword and node index information of all matching nodes 
///            获取所有匹配节点的全局关键字与节点索引信息
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo The server-side node information to be matched 
///            待匹配的服务端节点信息
            /// AutoCSer.Net.CommandServerKeepCallbackCount{AutoCSer.BinarySerializeKeyValue{string,AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex}} callback 
            /// 返回值 AutoCSer.BinarySerializeKeyValue{string,AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex} 
            /// </summary>
            GetNodeKeyIndexs = 24,
            /// <summary>
            /// [25] Gets the global keyword for all matching nodes 
///            获取所有匹配节点的全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo The server-side node information to be matched 
///            待匹配的服务端节点信息
            /// AutoCSer.Net.CommandServerKeepCallbackCount{string} callback 
            /// 返回值 string 
            /// </summary>
            GetNodeKeys = 25,
            /// <summary>
            /// [26] Call the node method 
///            调用节点方法
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue queue 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.RequestParameter parameter Request parameters 
///            请求参数
            /// AutoCSer.Net.CommandServerCallback{AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter} callback The callback of reutrn parameter 
///            返回参数回调
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter 
            /// </summary>
            CallInputOutputWrite = 26,
            /// <summary>
            /// [27] Call the node method 
///            调用节点方法
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue queue 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.RequestParameter parameter Request parameters 
///            请求参数
            /// AutoCSer.Net.CommandServerCallback{AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum} callback 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum 
            /// </summary>
            CallInputWrite = 27,
            /// <summary>
            /// [28] Call the node method 
///            调用节点方法
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue queue 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// int methodIndex Call method number 
///            调用方法编号
            /// AutoCSer.Net.CommandServerCallback{AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter} callback The callback of reutrn parameter 
///            返回参数回调
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter 
            /// </summary>
            CallOutputWrite = 28,
            /// <summary>
            /// [29] Call the node method 
///            调用节点方法
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue queue 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// int methodIndex Call method number 
///            调用方法编号
            /// AutoCSer.Net.CommandServerCallback{AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum} callback 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CallStateEnum 
            /// </summary>
            CallWrite = 29,
            /// <summary>
            /// [30] Call the node method 
///            调用节点方法
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue queue 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.RequestParameter parameter Request parameters 
///            请求参数
            /// AutoCSer.Net.CommandServerKeepCallback{AutoCSer.CommandService.StreamPersistenceMemoryDatabase.KeepCallbackResponseParameter} callback The return parameters of the keep callback 
///            返回参数回调
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.KeepCallbackResponseParameter 
            /// </summary>
            InputKeepCallbackWrite = 30,
            /// <summary>
            /// [31] Call the node method 
///            调用节点方法
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue queue 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// int methodIndex Call method number 
///            调用方法编号
            /// AutoCSer.Net.CommandServerKeepCallback{AutoCSer.CommandService.StreamPersistenceMemoryDatabase.KeepCallbackResponseParameter} callback The return parameters of the keep callback 
///            返回参数回调
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.KeepCallbackResponseParameter 
            /// </summary>
            KeepCallbackWrite = 31,
            /// <summary>
            /// [32] Call the node method 
///            调用节点方法
            /// AutoCSer.Net.CommandServerSocket socket 
            /// AutoCSer.Net.CommandServerCallConcurrencyReadWriteQueue queue 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.RequestParameter parameter Request parameters 
///            请求参数
            /// </summary>
            SendOnlyWrite = 32,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CustomNode
{
        /// <summary>
        /// Timeout task message node interface (for distributed transaction data consistency check) 
///            超时任务消息节点接口（用于分布式事务数据一致性检查） client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CustomNode.ITimeoutMessageNode<>))]
        public partial interface ITimeoutMessageNodeClientNode<T>
        {
            /// <summary>
            /// Add the task node 
///            添加任务节点
            /// </summary>
            /// <param name="task"></param>
            /// <returns>Task identifier. Return 0 upon failure 
///            任务标识，失败返回 0</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<long> Append(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CustomNode.TimeoutMessage<T> task);
            /// <summary>
            /// Cancel the task 
///            取消任务
            /// </summary>
            /// <param name="identity">Task identity 
///            任务标识</param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Cancel(long identity);
            /// <summary>
            /// Get the total number of tasks 
///            获取任务总数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> GetCount();
            /// <summary>
            /// Get the number of failed tasks executed 
///            获取执行失败任务数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> GetFailedCount();
            /// <summary>
            /// Failed task retry 
///            失败任务重试
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter RetryFailed();
            /// <summary>
            /// Trigger task execution 
///            触发任务执行
            /// </summary>
            /// <param name="identity">Task identity 
///            任务标识</param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter RunTask(long identity);
            /// <summary>
            /// Add immediate execution tasks 
///            添加立即执行任务
            /// </summary>
            /// <param name="task"></param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter AppendRun(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CustomNode.TimeoutMessage<T> task);
            /// <summary>
            /// Get the execution task message data 
///            获取执行任务消息数据
            /// </summary>
            /// <returns></returns>
            AutoCSer.Net.KeepCallbackCommand GetRunTask(System.Action<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResult<T>,AutoCSer.Net.KeepCallbackCommand> callback);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Array node interface 
///            数组节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IArrayNode<>))]
        public partial interface IArrayNodeClientNode<T>
        {
            /// <summary>
            /// Clear the data at the specified location 
///            清除指定位置数据
            /// </summary>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">Clear data quantity 
///            清除数据数量</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Clear(int startIndex, int count);
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter ClearArray();
            /// <summary>
            /// Fill the array with data to specify the position 
///            用数据填充数组指定位置
            /// </summary>
            /// <param name="value"></param>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">The number of filled data 
///            填充数据数量</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Fill(T value, int startIndex, int count);
            /// <summary>
            /// Fill the entire array with data 
///            用数据填充整个数组
            /// </summary>
            /// <param name="value"></param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter FillArray(T value);
            /// <summary>
            /// Get the array length 
///            获取数组长度
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> GetLength();
            /// <summary>
            /// Get data based on index location 
///            根据索引位置获取数据
            /// </summary>
            /// <param name="index">Index position 
///            索引位置</param>
            /// <returns>If the return exceeds the index, there will be no return value 
///            超出索引返回则无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>> GetValue(int index);
            /// <summary>
            /// Set the data according to the index position and return the data before the setting 
///            根据索引位置设置数据并返回设置之前的数据
            /// </summary>
            /// <param name="index">Index position 
///            索引位置</param>
            /// <param name="value">data</param>
            /// <returns>Set the previous data. If it exceeds the index and returns, there will be no return value 
///            设置之前的数据，超出索引返回则无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>> GetValueSet(int index, T value);
            /// <summary>
            /// Find the position of the first matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找第一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">Search for the number of matching data 
///            查找匹配数据数量</param>
            /// <returns>Failure returns a negative number 
///            失败返回负数</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> IndexOf(T value, int startIndex, int count);
            /// <summary>
            /// Find the position of the first matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找第一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Failure returns a negative number 
///            失败返回负数</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> IndexOfArray(T value);
            /// <summary>
            /// Find the position of the last matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找最后一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <param name="startIndex">The last matching position (the starting position) 
///            最后一个匹配位置（起始位置）</param>
            /// <param name="count">Search for the number of matching data 
///            查找匹配数据数量</param>
            /// <returns>Failure returns a negative number 
///            失败返回负数</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> LastIndexOf(T value, int startIndex, int count);
            /// <summary>
            /// Find the position of the last matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找最后一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Failure returns a negative number 
///            失败返回负数</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> LastIndexOfArray(T value);
            /// <summary>
            /// Reverse the array data at the specified position 
///            反转指定位置数组数据
            /// </summary>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">Reverse the amount of data 
///            反转数据数量</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Reverse(int startIndex, int count);
            /// <summary>
            /// Reverse the entire array data 
///            反转整个数组数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter ReverseArray();
            /// <summary>
            /// Set the data according to the index position 
///            根据索引位置设置数据
            /// </summary>
            /// <param name="index">Index position 
///            索引位置</param>
            /// <param name="value">data</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> SetValue(int index, T value);
            /// <summary>
            /// Sort the array data at the specified position 
///            排序指定位置数组数据
            /// </summary>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">The quantity of data to be sorted 
///            排序数据数量</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Sort(int startIndex, int count);
            /// <summary>
            /// Array sorting 
///            数组排序
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter SortArray();
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Bitmap node interface 
///            位图节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IBitmapNode))]
        public partial interface IBitmapNodeClientNode
        {
            /// <summary>
            /// Clear bit status 
///            清除位状态
            /// </summary>
            /// <param name="index">Bit index position 
///            位索引位置</param>
            /// <returns>Returning false indicates that the index is out of range 
///            返回 false 表示索引超出范围</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> ClearBit(uint index);
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter ClearMap();
            /// <summary>
            /// Read bit status 
///            读取位状态
            /// </summary>
            /// <param name="index">Bit index position 
///            位索引位置</param>
            /// <returns>A non-0 indicates that the binary bit is in the set state. If the index exceeds, there will be no return value 
///            非 0 表示二进制位为已设置状态，索引超出则无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<int>> GetBit(uint index);
            /// <summary>
            /// Clear the bit state and return to the state before setting 
///            清除位状态并返回设置之前的状态
            /// </summary>
            /// <param name="index">Bit index position 
///            位索引位置</param>
            /// <returns>Clear the state before the operation. A non-0 state indicates that the binary bit was in the set state before. If the index exceeds, there will be no return value 
///            清除操作之前的状态，非 0 表示二进制位之前为已设置状态，索引超出则无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<int>> GetBitClearBit(uint index);
            /// <summary>
            /// Reverse the bit state and return the state before the operation 
///            位状态取反并返回操作之前的状态
            /// </summary>
            /// <param name="index">Bit index position 
///            位索引位置</param>
            /// <returns>Take the state before the reverse operation. If it is not 0, it indicates that the binary bit is in the set state before. If the index exceeds, there will be no return value 
///            取反操作之前的状态，非 0 表示二进制位之前为已设置状态，索引超出则无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<int>> GetBitInvertBit(uint index);
            /// <summary>
            /// Set the bit state and return the state before setting 
///            设置位状态并返回设置之前的状态
            /// </summary>
            /// <param name="index">Bit index position 
///            位索引位置</param>
            /// <returns>The state before setting: A non-0 indicates that the binary bit was in the set state before, and there is no return value if the index exceeds 
///            设置之前的状态，非 0 表示二进制位之前为已设置状态，索引超出则无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<int>> GetBitSetBit(uint index);
            /// <summary>
            /// Get the number of bitmap binary bits 
///            获取位图二进制位数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<uint> GetCapacity();
            /// <summary>
            /// Reverse the bit state 
///            位状态取反
            /// </summary>
            /// <param name="index">Bit index position 
///            位索引位置</param>
            /// <returns>Returning false indicates that the index is out of range 
///            返回 false 表示索引超出范围</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> InvertBit(uint index);
            /// <summary>
            /// Set bit status 
///            设置位状态
            /// </summary>
            /// <param name="index">Bit index position 
///            位索引位置</param>
            /// <returns>Returning false indicates that the index is out of range 
///            返回 false 表示索引超出范围</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> SetBit(uint index);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Dictionary node interface 
///            字典节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayDictionaryNode<>))]
        public partial interface IByteArrayDictionaryNodeClientNode<KT>
        {
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Clear();
            /// <summary>
            /// Determine whether the keyword exists 
///            判断关键字是否存在
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> ContainsKey(KT key);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> Count();
            /// <summary>
            /// Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns>Deleted data and no returned data indicate that the keyword does not exist 
///            被删除数据，无返回数据表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<byte[]>> GetRemove(KT key);
            /// <summary>
            /// Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns>Deleted data and no returned data indicate that the keyword does not exist 
///            被删除数据，无返回数据表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter> GetRemoveResponseParameter(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter returnValue, KT key);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="key"></param>
            /// <returns>Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Remove(KT key);
            /// <summary>
            /// Clear all data and rebuild the container (to solve the problem of low performance of the clear call when the data volume is large) 
///            清除所有数据并重建容器（用于解决数据量较大的情况下 Clear 调用性能低下的问题）
            /// </summary>
            /// <param name="capacity">Initialize the size of the new container 
///            新容器初始化大小</param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Renew(int capacity);
            /// <summary>
            /// Force the data to be set and overwrite if the keyword already exists 
///            强制设置数据，如果关键字已存在则覆盖
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns>Return false on failure</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Set(KT key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value);
            /// <summary>
            /// Try to add data 
///            尝试添加数据
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> TryAdd(KT key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter> TryGetResponseParameter(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter returnValue, KT key);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<byte[]>> TryGetValue(KT key);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="keys"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<byte[][]> GetValueArray(KT[] keys);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="keys"></param>
            /// <returns>The number of deleted keywords 
///            删除关键字数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> RemoveKeys(KT[] keys);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// 256 base fragment dictionary node interface 
///            256 基分片字典 节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayFragmentDictionaryNode<>))]
        public partial interface IByteArrayFragmentDictionaryNodeClientNode<KT>
        {
            /// <summary>
            /// Clear the data (retain the fragmented array) 
///            清除数据（保留分片数组）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Clear();
            /// <summary>
            /// Clear fragmented array (used to solve the problem of low performance of clear call when the amount of data is large) 
///            清除分片数组（用于解决数据量较大的情况下 Clear 调用性能低下的问题）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter ClearArray();
            /// <summary>
            /// Determine whether the keyword exists 
///            判断关键字是否存在
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> ContainsKey(KT key);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> Count();
            /// <summary>
            /// Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns>Deleted data and no returned data indicate that the keyword does not exist 
///            被删除数据，无返回数据表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<byte[]>> GetRemove(KT key);
            /// <summary>
            /// Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns>Deleted data and no returned data indicate that the keyword does not exist 
///            被删除数据，无返回数据表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter> GetRemoveResponseParameter(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter returnValue, KT key);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="key"></param>
            /// <returns>Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Remove(KT key);
            /// <summary>
            /// Force the data to be set and overwrite if the keyword already exists 
///            强制设置数据，如果关键字已存在则覆盖
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns>Return false on failure</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Set(KT key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value);
            /// <summary>
            /// If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> TryAdd(KT key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter> TryGetResponseParameter(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter returnValue, KT key);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<byte[]>> TryGetValue(KT key);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="keys"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<byte[][]> GetValueArray(KT[] keys);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="keys"></param>
            /// <returns>The number of deleted keywords 
///            删除关键字数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> RemoveKeys(KT[] keys);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Queue node Interface (First In, First Out) 
///            队列节点接口（先进先出） client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayQueueNode))]
        public partial interface IByteArrayQueueNodeClientNode
        {
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Clear();
            /// <summary>
            /// Get the number of queue data 
///            获取队列数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> Count();
            /// <summary>
            /// Add the data to the queue 
///            将数据添加到队列
            /// </summary>
            /// <param name="value"></param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Enqueue(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value);
            /// <summary>
            /// Pop a piece of data from the queue 
///            从队列中弹出一个数据
            /// </summary>
            /// <returns>If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<byte[]>> TryDequeue();
            /// <summary>
            /// Pop a piece of data from the queue 
///            从队列中弹出一个数据
            /// </summary>
            /// <returns>If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter> TryDequeueResponseParameter(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter returnValue);
            /// <summary>
            /// Get the next pop-up data in the queue (no pop-up data, only view) 
///            获取队列中下一个弹出数据（不弹出数据仅查看）
            /// </summary>
            /// <returns>If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<byte[]>> TryPeek();
            /// <summary>
            /// Get the next pop-up data in the queue (no pop-up data, only view) 
///            获取队列中下一个弹出数据（不弹出数据仅查看）
            /// </summary>
            /// <returns>If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter> TryPeekResponseParameter(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter returnValue);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Stack node interface (Last in, first out) 
///            栈节点接口（后进先出） client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IByteArrayStackNode))]
        public partial interface IByteArrayStackNodeClientNode
        {
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Clear();
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> Count();
            /// <summary>
            /// Add the data to the stack 
///            将数据添加到栈
            /// </summary>
            /// <param name="value"></param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Push(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value);
            /// <summary>
            /// Get the next popped data in the stack (no popped data, only view) 
///            获取栈中下一个弹出数据（不弹出数据仅查看）
            /// </summary>
            /// <returns>If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<byte[]>> TryPeek();
            /// <summary>
            /// Get the next popped data in the stack (no popped data, only view) 
///            获取栈中下一个弹出数据（不弹出数据仅查看）
            /// </summary>
            /// <returns>If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter> TryPeekResponseParameter(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter returnValue);
            /// <summary>
            /// Pop a piece of data from the stack 
///            从栈中弹出一个数据
            /// </summary>
            /// <returns>If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<byte[]>> TryPop();
            /// <summary>
            /// Pop a piece of data from the stack 
///            从栈中弹出一个数据
            /// </summary>
            /// <returns>If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter> TryPopResponseParameter(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter returnValue);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Dictionary node interface 
///            字典节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDictionaryNode<,>))]
        public partial interface IDictionaryNodeClientNode<KT,VT>
        {
            /// <summary>
            /// 
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Clear();
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> ContainsKey(KT key);
            /// <summary>
            /// 
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter ReusableClear();
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> Count();
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>> GetRemove(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Remove(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="capacity"></param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Renew(int capacity);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Set(KT key, VT value);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> TryAdd(KT key, VT value);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>> TryGetValue(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="keys"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<VT[]> GetValueArray(KT[] keys);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="keys"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> RemoveKeys(KT[] keys);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Distributed lock node interface 
///            分布式锁节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDistributedLockNode<>))]
        public partial interface IDistributedLockNodeClientNode<T>
        {
            /// <summary>
            /// Apply for a lock 
///            申请锁
            /// </summary>
            /// <param name="key">Keyword of lock 
///            锁关键字</param>
            /// <param name="timeoutSeconds">Timeout seconds 
///            超时秒数</param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<long> Enter(T key, ushort timeoutSeconds);
            /// <summary>
            /// Release the lock 
///            释放锁
            /// </summary>
            /// <param name="key">Keyword of lock 
///            锁关键字</param>
            /// <param name="identity">Lock request identity 
///            锁请求标识</param>
            AutoCSer.Net.SendOnlyCommand Release(T key, long identity);
            /// <summary>
            /// Try to apply for a lock 
///            尝试申请锁
            /// </summary>
            /// <param name="key">Keyword of lock 
///            锁关键字</param>
            /// <param name="timeoutSeconds">Timeout seconds 
///            超时秒数</param>
            /// <returns>Lock request identity. Return 0 if failed 
///            锁请求标识，失败返回 0</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<long> TryEnter(T key, ushort timeoutSeconds);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// 256 base fragment dictionary node interface 
///            256 基分片字典 节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IFragmentDictionaryNode<,>))]
        public partial interface IFragmentDictionaryNodeClientNode<KT,VT>
        {
            /// <summary>
            /// Clear the data (retain the fragmented array) 
///            清除数据（保留分片数组）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Clear();
            /// <summary>
            /// Clear fragmented array (used to solve the problem of low performance of clear call when the amount of data is large) 
///            清除分片数组（用于解决数据量较大的情况下 Clear 调用性能低下的问题）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter ClearArray();
            /// <summary>
            /// Determine whether the keyword exists 
///            判断关键字是否存在
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> ContainsKey(KT key);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> Count();
            /// <summary>
            /// Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>> GetRemove(KT key);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="key"></param>
            /// <returns>Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Remove(KT key);
            /// <summary>
            /// Force the data to be set and overwrite if the keyword already exists 
///            强制设置数据，如果关键字已存在则覆盖
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns>Return false on failure</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Set(KT key, VT value);
            /// <summary>
            /// If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> TryAdd(KT key, VT value);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>> TryGetValue(KT key);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="keys"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<VT[]> GetValueArray(KT[] keys);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="keys"></param>
            /// <returns>The number of deleted keywords 
///            删除关键字数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> RemoveKeys(KT[] keys);
            /// <summary>
            /// Reusable dictionaries reset data locations (The presence of reference type data can cause memory leaks) 
///            可重用字典重置数据位置（存在引用类型数据会造成内存泄露）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter ReusableClear();
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// 256 base fragment hash table node interface 
///            256 基分片 哈希表 节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IFragmentHashSetNode<>))]
        public partial interface IFragmentHashSetNodeClientNode<T>
        {
            /// <summary>
            /// If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Add(T value);
            /// <summary>
            /// Clear the data (retain the fragmented array) 
///            清除数据（保留分片数组）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Clear();
            /// <summary>
            /// Clear fragmented array (used to solve the problem of low performance of clear call when the amount of data is large) 
///            清除分片数组（用于解决数据量较大的情况下 Clear 调用性能低下的问题）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter ClearArray();
            /// <summary>
            /// Determine whether the keyword exists 
///            判断关键字是否存在
            /// </summary>
            /// <param name="value"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Contains(T value);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> Count();
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Remove(T value);
            /// <summary>
            /// If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// </summary>
            /// <param name="values"></param>
            /// <returns>The quantity of the added data 
///            添加数据数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> AddValues(T[] values);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="values"></param>
            /// <returns>The quantity of deleted data 
///            删除数据数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> RemoveValues(T[] values);
            /// <summary>
            /// Reusable hash tables reset data locations (The presence of reference type data can cause memory leaks) 
///            可重用哈希表重置数据位置（存在引用类型数据会造成内存泄露）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter ReusableClear();
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Dictionary node interface 
///            字典节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashBytesDictionaryNode))]
        public partial interface IHashBytesDictionaryNodeClientNode
        {
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Clear();
            /// <summary>
            /// Determine whether the keyword exists 
///            判断关键字是否存在
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> ContainsKey(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> Count();
            /// <summary>
            /// Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns>Deleted data and no returned data indicate that the keyword does not exist 
///            被删除数据，无返回数据表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<byte[]>> GetRemove(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key);
            /// <summary>
            /// Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns>Deleted data and no returned data indicate that the keyword does not exist 
///            被删除数据，无返回数据表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter> GetRemoveResponseParameter(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter returnValue, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="key"></param>
            /// <returns>Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Remove(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key);
            /// <summary>
            /// Clear all data and rebuild the container (to solve the problem of low performance of the clear call when the data volume is large) 
///            清除所有数据并重建容器（用于解决数据量较大的情况下 Clear 调用性能低下的问题）
            /// </summary>
            /// <param name="capacity">Initialize the size of the new container 
///            新容器初始化大小</param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Renew(int capacity);
            /// <summary>
            /// Force the data to be set and overwrite if the keyword already exists 
///            强制设置数据，如果关键字已存在则覆盖
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns>Return false on failure</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Set(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value);
            /// <summary>
            /// Try to add data 
///            尝试添加数据
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> TryAdd(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter> TryGetResponseParameter(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter returnValue, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<byte[]>> TryGetValue(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// 256 base fragment hash byte array dictionary node interface 
///            256 基分片哈希字节数组字典 节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashBytesFragmentDictionaryNode))]
        public partial interface IHashBytesFragmentDictionaryNodeClientNode
        {
            /// <summary>
            /// Clear the data (retain the fragmented array) 
///            清除数据（保留分片数组）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Clear();
            /// <summary>
            /// Clear fragmented array (used to solve the problem of low performance of clear call when the amount of data is large) 
///            清除分片数组（用于解决数据量较大的情况下 Clear 调用性能低下的问题）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter ClearArray();
            /// <summary>
            /// Determine whether the keyword exists 
///            判断关键字是否存在
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> ContainsKey(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> Count();
            /// <summary>
            /// Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns>Deleted data and no returned data indicate that the keyword does not exist 
///            被删除数据，无返回数据表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<byte[]>> GetRemove(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key);
            /// <summary>
            /// Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns>Deleted data and no returned data indicate that the keyword does not exist 
///            被删除数据，无返回数据表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter> GetRemoveResponseParameter(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter returnValue, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="key"></param>
            /// <returns>Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Remove(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key);
            /// <summary>
            /// Force the data to be set and overwrite if the keyword already exists 
///            强制设置数据，如果关键字已存在则覆盖
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns>Return false on failure</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Set(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value);
            /// <summary>
            /// If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> TryAdd(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter> TryGetResponseParameter(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter returnValue, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<byte[]>> TryGetValue(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Hash table node interface 
///            哈希表节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashSetNode<>))]
        public partial interface IHashSetNodeClientNode<T>
        {
            /// <summary>
            /// Add data
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Add(T value);
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Clear();
            /// <summary>
            /// Determine whether the keyword exists 
///            判断关键字是否存在
            /// </summary>
            /// <param name="value"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Contains(T value);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> Count();
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Remove(T value);
            /// <summary>
            /// Clear all data and rebuild the container (to solve the problem of low performance of the clear call when the data volume is large) 
///            清除所有数据并重建容器（用于解决数据量较大的情况下 Clear 调用性能低下的问题）
            /// </summary>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Renew(int capacity);
            /// <summary>
            /// Reusable dictionaries reset data locations (The presence of reference type data can cause memory leaks) 
///            可重用字典重置数据位置（存在引用类型数据会造成内存泄露）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter ReusableClear();
            /// <summary>
            /// If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// </summary>
            /// <param name="values"></param>
            /// <returns>The quantity of the added data 
///            添加数据数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> AddValues(T[] values);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="values"></param>
            /// <returns>The quantity of deleted data 
///            删除数据数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> RemoveValues(T[] values);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// 64-bit auto-increment identity node interface 
///            64 位自增ID 节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IIdentityGeneratorNode))]
        public partial interface IIdentityGeneratorNodeClientNode
        {
            /// <summary>
            /// Get the next increment identity 
///            获取下一个自增ID
            /// </summary>
            /// <returns>The next increment identity returns a negative number on failure 
///            下一个自增ID，失败返回负数</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<long> Next();
            /// <summary>
            /// Gets the auto-increment identity segment 
///            获取自增 ID 分段
            /// </summary>
            /// <param name="count">Get the quantity of data 
///            获取数据数量</param>
            /// <returns>Auto-increment identity segment 
///            自增 ID 分段</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IdentityFragment> NextFragment(int count);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Array node interface 
///            数组节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ILeftArrayNode<>))]
        public partial interface ILeftArrayNodeClientNode<T>
        {
            /// <summary>
            /// Add data
            /// </summary>
            /// <param name="value">data</param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Add(T value);
            /// <summary>
            /// Clear the data at the specified location 
///            清除指定位置数据
            /// </summary>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">Clear data quantity 
///            清除数据数量</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Clear(int startIndex, int count);
            /// <summary>
            /// Clear all the data and set the valid length of the data to 0 
///            清除所有数据并将数据有效长度设置为 0
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter ClearLength();
            /// <summary>
            /// Fill the array with data to specify the position 
///            用数据填充数组指定位置
            /// </summary>
            /// <param name="value"></param>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">The number of filled data 
///            填充数据数量</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Fill(T value, int startIndex, int count);
            /// <summary>
            /// Fill the entire array with data 
///            用数据填充整个数组
            /// </summary>
            /// <param name="value"></param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter FillArray(T value);
            /// <summary>
            /// Get the size of the array container 
///            获取数组容器大小
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> GetCapacity();
            /// <summary>
            /// Get the number of containers free 
///            获取容器空闲数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> GetFreeCount();
            /// <summary>
            /// Get the valid length of the array 
///            获取数组有效长度
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> GetLength();
            /// <summary>
            /// Remove the last data and return it 
///            移除最后一个数据并返回该数据
            /// </summary>
            /// <returns>No data will be returned if there is no removable data 
///            没有可移除数据则无数据返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>> GetTryPopValue();
            /// <summary>
            /// Get data based on index location 
///            根据索引位置获取数据
            /// </summary>
            /// <param name="index">Index position 
///            索引位置</param>
            /// <returns>If the return exceeds the index, there will be no return value 
///            超出索引返回则无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>> GetValue(int index);
            /// <summary>
            /// Remove the data at the specified index position and return the removed data 
///            移除指定索引位置数据并返回被移除的数据
            /// </summary>
            /// <param name="index">Data location 
///            数据位置</param>
            /// <returns>No data will be returned if the index range is exceeded 
///            超出索引范围则无数据返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>> GetValueRemoveAt(int index);
            /// <summary>
            /// Remove the data at the specified index position, move the last data to the specified position, and return the removed data 
///            移除指定索引位置数据，将最后一个数据移动到该指定位置，并返回被移除的数据
            /// </summary>
            /// <param name="index"></param>
            /// <returns>No data will be returned if the index range is exceeded 
///            超出索引范围则无数据返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>> GetValueRemoveToEnd(int index);
            /// <summary>
            /// Set the data according to the index position and return the data before the setting 
///            根据索引位置设置数据并返回设置之前的数据
            /// </summary>
            /// <param name="index">Index position 
///            索引位置</param>
            /// <param name="value">data</param>
            /// <returns>Set the previous data. If it exceeds the index and returns, there will be no return value 
///            设置之前的数据，超出索引返回则无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>> GetValueSet(int index, T value);
            /// <summary>
            /// Find the position of the first matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找第一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">Search for the number of matching data 
///            查找匹配数据数量</param>
            /// <returns>Failure returns a negative number 
///            失败返回负数</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> IndexOf(T value, int startIndex, int count);
            /// <summary>
            /// Find the position of the first matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找第一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Failure returns a negative number 
///            失败返回负数</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> IndexOfArray(T value);
            /// <summary>
            /// Insert data 
///            插入数据
            /// </summary>
            /// <param name="index">Insert position 
///            插入位置</param>
            /// <param name="value">data</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Insert(int index, T value);
            /// <summary>
            /// Find the position of the last matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找最后一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <param name="startIndex">The last matching position (the starting position) 
///            最后一个匹配位置（起始位置）</param>
            /// <param name="count">Search for the number of matching data 
///            查找匹配数据数量</param>
            /// <returns>Failure returns a negative number 
///            失败返回负数</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> LastIndexOf(T value, int startIndex, int count);
            /// <summary>
            /// Find the position of the last matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找最后一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Failure returns a negative number 
///            失败返回负数</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> LastIndexOfArray(T value);
            /// <summary>
            /// Remove the first matching data (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            移除第一个匹配数据（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value">data</param>
            /// <returns>Returning false indicates that there is no data match 
///            返回 false 表示不存在数据匹配</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Remove(T value);
            /// <summary>
            /// Remove the data at the specified index position 
///            移除指定索引位置数据
            /// </summary>
            /// <param name="index">Data location 
///            数据位置</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> RemoveAt(int index);
            /// <summary>
            /// Remove the data at the specified index position and move the last data to that specified position 
///            移除指定索引位置数据并将最后一个数据移动到该指定位置
            /// </summary>
            /// <param name="index"></param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> RemoveToEnd(int index);
            /// <summary>
            /// Reverse the array data at the specified position 
///            反转指定位置数组数据
            /// </summary>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">Reverse the amount of data 
///            反转数据数量</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Reverse(int startIndex, int count);
            /// <summary>
            /// Reverse the entire array data 
///            反转整个数组数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter ReverseArray();
            /// <summary>
            /// Empty and release the array 
///            置空并释放数组
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter SetEmpty();
            /// <summary>
            /// Set the data according to the index position 
///            根据索引位置设置数据
            /// </summary>
            /// <param name="index">Index position 
///            索引位置</param>
            /// <param name="value">data</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> SetValue(int index, T value);
            /// <summary>
            /// Sort the array data at the specified position 
///            排序指定位置数组数据
            /// </summary>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">The quantity of data to be sorted 
///            排序数据数量</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Sort(int startIndex, int count);
            /// <summary>
            /// Array sorting 
///            数组排序
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter SortArray();
            /// <summary>
            /// Add data when there is a free place 
///            当有空闲位置时添加数据
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the array is full and the addition failed 
///            返回 false 表示数组已满，添加失败</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> TryAdd(T value);
            /// <summary>
            /// Try to remove the last data 
///            尝试移除最后一个数据
            /// </summary>
            /// <returns>Is there any removable data 
///            是否存在可移除数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> TryPop();
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Multi-hash bitmap client synchronization filter node Interface (similar to Bloom filter, suitable for small containers) 
///            多哈希位图客户端同步过滤节点接口（类似布隆过滤器，适合小容器） client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IManyHashBitMapClientFilterNode))]
        public partial interface IManyHashBitMapClientFilterNodeClientNode
        {
            /// <summary>
            /// Get the operation of setting a new bit 
///            获取设置新位操作
            /// </summary>
            /// <returns></returns>
            AutoCSer.Net.KeepCallbackCommand GetBit(System.Action<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResult<int>,AutoCSer.Net.KeepCallbackCommand> callback);
            /// <summary>
            /// Get the current bitmap data 
///            获取当前位图数据
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ManyHashBitMap> GetData();
            /// <summary>
            /// Set bit 
///            设置位
            /// </summary>
            /// <param name="bit">The set binary bit 
///            设置的二进制位</param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter SetBit(int bit);
            /// <summary>
            /// Get the bitmap size (number of bits) 
///            获取位图大小（位数量）
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> GetSize();
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Multi-hash bitmap filter node interface (similar to Bloom Filter) 
///            多哈希位图过滤节点接口（类似布隆过滤器） client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IManyHashBitMapFilterNode))]
        public partial interface IManyHashBitMapFilterNodeClientNode
        {
            /// <summary>
            /// Get the bitmap size (number of bits) 
///            获取位图大小（位数量）
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> GetSize();
            /// <summary>
            /// Set bit 
///            设置位
            /// </summary>
            /// <param name="size">Bitmap size (number of bits) 
///            位图大小（位数量）</param>
            /// <param name="bits">Binary bit set 
///            位置集合</param>
            /// <returns>Returning false indicates that the bitmap size does not match 
///            返回 false 表示位图大小不匹配</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> SetBits(int size, uint[] bits);
            /// <summary>
            /// Binary bit set matching 
///            位置集合匹配
            /// </summary>
            /// <param name="size">Bitmap size (number of bits) 
///            位图大小（位数量）</param>
            /// <param name="bits">Binary bit set 
///            位置集合</param>
            /// <returns>Returning Null indicates that the bitmap does not match 
///            返回 Null 表示位图不匹配</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.NullableBoolEnum> CheckBits(int size, uint[] bits);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Message processing node interface 
///            消息处理节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNode<>))]
        public partial interface IMessageNodeClientNode<T>
        {
            /// <summary>
            /// Producers add new message 
///            生产者添加新消息
            /// </summary>
            /// <param name="message"></param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter AppendMessage(T message);
            /// <summary>
            /// Clear all messages 
///            清除所有消息
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Clear();
            /// <summary>
            /// Clear all failure messages (including handling timeout messages) 
///            清除所有失败消息（包括处理超时消息）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter ClearFailed();
            /// <summary>
            /// The message has been processed 
///            消息完成处理
            /// </summary>
            /// <param name="identity"></param>
            AutoCSer.Net.SendOnlyCommand Completed(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.MessageIdeneity identity);
            /// <summary>
            /// Message failed processing 
///            消息失败处理
            /// </summary>
            /// <param name="identity"></param>
            AutoCSer.Net.SendOnlyCommand Failed(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.MessageIdeneity identity);
            /// <summary>
            /// Get the number of consumer callbacks 
///            获取消费者回调数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> GetCallbackCount();
            /// <summary>
            /// Get the number of uncompleted messages (excluding failed messages) 
///            获取未完成消息数量（不包括失败消息）
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> GetCount();
            /// <summary>
            /// Get the number of failed messages (Including handling timeout messages) 
///            获取失败消息数量（包括处理超时消息）
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> GetFailedCount();
            /// <summary>
            /// The consumer client gets the message 
///            消费客户端获取消息
            /// </summary>
            /// <param name="maxCount">The current maximum number of concurrent messages on the client side 
///            当前客户端最大并发消息数量</param>
            /// <returns></returns>
            AutoCSer.Net.KeepCallbackCommand GetMessage(int maxCount, System.Action<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResult<T>,AutoCSer.Net.KeepCallbackCommand> callback);
            /// <summary>
            /// Get the number of unfinished timeout messages 
///            获取未完成的超时消息数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> GetTimeoutCount();
            /// <summary>
            /// Get the number of uncompleted messages (including failed messages) 
///            获取未完成消息数量（包括失败消息）
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> GetTotalCount();
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Archive-only data node interface (It is used for the rapid archiving of large amounts of concurrent data without modifying memory data or defining snapshot operations) 
///            仅存档数据节点接口（用于大量并发数据快速存档，不修改内存数据，也不定义快照操作） client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IOnlyPersistenceNode<>))]
        public partial interface IOnlyPersistenceNodeClientNode<T>
        {
            /// <summary>
            /// Data archiving 
///            数据存档
            /// </summary>
            /// <param name="value">Data to be archive 
///            待存档数据</param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Save(T value);
            /// <summary>
            /// Data archiving (The server does not respond) 
///            数据存档（服务端不响应）
            /// </summary>
            /// <param name="value">Data to be archive 
///            待存档数据</param>
            AutoCSer.Net.SendOnlyCommand SaveSendOnly(T value);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Process daemon node interface (The server needs to run as an administrator; otherwise, an exception may occur) 
///            进程守护节点接口（服务端需要以管理员身份运行，否则可能异常） client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IProcessGuardNode))]
        public partial interface IProcessGuardNodeClientNode
        {
            /// <summary>
            /// Add the process to be daemon 
///            添加待守护进程
            /// </summary>
            /// <param name="processInfo">Process information 
///            进程信息</param>
            /// <returns>Add failed and return false 
///            添加失败返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Guard(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ProcessGuardInfo processInfo);
            /// <summary>
            /// Delete the daemon process 
///            删除被守护进程
            /// </summary>
            /// <param name="processId">Process identity 
///            进程标识</param>
            /// <param name="startTime">Process startup time 
///            进程启动时间</param>
            /// <param name="processName">Process name 
///            进程名称</param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Remove(int processId, System.DateTime startTime, string processName);
            /// <summary>
            /// Switch processes 
///            切换进程
            /// </summary>
            /// <param name="key">The key words of the switched process 
///            切换进程关键字</param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Switch(string key);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Queue node interface (First In, First Out) 
///            队列节点接口（先进先出） client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IQueueNode<>))]
        public partial interface IQueueNodeClientNode<T>
        {
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Clear();
            /// <summary>
            /// Determine whether there is matching data in the queue (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            判断队列中是否存在匹配数据（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value">Data to be matched 
///            待匹配数据</param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Contains(T value);
            /// <summary>
            /// Get the number of queue data 
///            获取队列数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> Count();
            /// <summary>
            /// Add the data to the queue 
///            将数据添加到队列
            /// </summary>
            /// <param name="value"></param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Enqueue(T value);
            /// <summary>
            /// Pop a piece of data from the queue 
///            从队列中弹出一个数据
            /// </summary>
            /// <returns>If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>> TryDequeue();
            /// <summary>
            /// Get the next pop-up data in the queue (no pop-up data, only view) 
///            获取队列中下一个弹出数据（不弹出数据仅查看）
            /// </summary>
            /// <returns>If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>> TryPeek();
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Binary search tree node interface 
///            二叉搜索树节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISearchTreeDictionaryNode<,>))]
        public partial interface ISearchTreeDictionaryNodeClientNode<KT,VT>
        {
            /// <summary>
            /// 
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Clear();
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> ContainsKey(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> Count();
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> CountLess(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> CountThan(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> GetHeight();
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>> GetRemove(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="skipCount"></param>
            /// <param name="getCount"></param>
            /// <returns></returns>
            System.Threading.Tasks.Task<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.KeepCallbackResponse<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>>> GetValues(int skipCount, byte getCount);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> IndexOf(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Remove(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Set(KT key, VT value);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> TryAdd(KT key, VT value);
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<KT>> TryGetFirstKey();
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<AutoCSer.KeyValue<KT,VT>>> TryGetFirstKeyValue();
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>> TryGetFirstValue();
            /// <summary>
            /// 
            /// </summary>
            /// <param name="index"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<AutoCSer.KeyValue<KT,VT>>> TryGetKeyValueByIndex(int index);
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<KT>> TryGetLastKey();
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<AutoCSer.KeyValue<KT,VT>>> TryGetLastKeyValue();
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>> TryGetLastValue();
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>> TryGetValue(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="index"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>> TryGetValueByIndex(int index);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="keys"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<VT[]> GetValueArray(KT[] keys);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="keys"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> RemoveKeys(KT[] keys);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Binary search tree collection node interface 
///            二叉搜索树集合节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISearchTreeSetNode<>))]
        public partial interface ISearchTreeSetNodeClientNode<T>
        {
            /// <summary>
            /// Add data
            /// </summary>
            /// <param name="value">keyword</param>
            /// <returns>Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Add(T value);
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Clear();
            /// <summary>
            /// Determine whether the keyword exists 
///            判断关键字是否存在
            /// </summary>
            /// <param name="value">keyword</param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Contains(T value);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> Count();
            /// <summary>
            /// Get the number of nodes smaller than the specified keyword 
///            获取比指定关键字小的节点数量
            /// </summary>
            /// <param name="value">keyword</param>
            /// <returns>Returning -1 indicates that the data to be matched is null 
///            返回 -1 表示待匹配数据为 null</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> CountLess(T value);
            /// <summary>
            /// Get the number of nodes larger than the specified keyword 
///            获取比指定关键字大的节点数量
            /// </summary>
            /// <param name="value">keyword</param>
            /// <returns>Returning -1 indicates that the data to be matched is null 
///            返回 -1 表示待匹配数据为 null</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> CountThan(T value);
            /// <summary>
            /// Get data based on the node position 
///            根据节点位置获取数据
            /// </summary>
            /// <param name="index">Node position 
///            节点位置</param>
            /// <returns>data</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>> GetByIndex(int index);
            /// <summary>
            /// Get the first data 
///            获取第一个数据
            /// </summary>
            /// <returns>No return value is returned when there is no data 
///            没有数据时返回无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>> GetFrist();
            /// <summary>
            /// Get the last data 
///            获取最后一个数据
            /// </summary>
            /// <returns>No return value is returned when there is no data 
///            没有数据时返回无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>> GetLast();
            /// <summary>
            /// Get the matching node location based on the keyword 
///            根据关键字获取匹配节点位置
            /// </summary>
            /// <param name="value">keyword</param>
            /// <returns>Returning -1 indicates a failed match 
///            返回 -1 表示失败匹配</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> IndexOf(T value);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="value">keyword</param>
            /// <returns>Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Remove(T value);
            /// <summary>
            /// If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// </summary>
            /// <param name="values"></param>
            /// <returns>The quantity of the added data 
///            添加数据数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> AddValues(T[] values);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="values"></param>
            /// <returns>The quantity of deleted data 
///            删除数据数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> RemoveValues(T[] values);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Server registration node interface 
///            服务注册节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IServerRegistryNode))]
        public partial interface IServerRegistryNodeClientNode
        {
            /// <summary>
            /// Add the server registration log 
///            添加服务注册日志
            /// </summary>
            /// <param name="log"></param>
            /// <returns>Server registration status 
///            服务注册状态</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerRegistryStateEnum> Append(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerRegistryLog log);
            /// <summary>
            /// Get the server session identity 
///            获取服务会话标识
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<long> GetSessionID();
            /// <summary>
            /// Gets the server registration log 
///            获取服务注册日志
            /// </summary>
            /// <param name="serverName">Monitor the server name. An empty string represents all servers 
///            监视服务名称，空字符串表示所有服务</param>
            /// <returns></returns>
            AutoCSer.Net.KeepCallbackCommand LogCallback(string serverName, System.Action<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerRegistryLog>,AutoCSer.Net.KeepCallbackCommand> callback);
            /// <summary>
            /// The server registration callback delegate is mainly used to register components to check the online state of the server 
///            服务注册回调委托，主要用于注册组件检查服务的在线状态
            /// </summary>
            /// <param name="sessionID">Server session identity 
///            服务会话标识</param>
            /// <returns></returns>
            AutoCSer.Net.KeepCallbackCommand ServerCallback(long sessionID, System.Action<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerRegistryOperationTypeEnum>,AutoCSer.Net.KeepCallbackCommand> callback);
            /// <summary>
            /// Get the main log of the server 
///            获取服务主日志
            /// </summary>
            /// <param name="serverName">Server name 
///            服务名称</param>
            /// <returns>Returning null indicates that the server main log was not found 
///            返回 null 表示没有找到服务主日志</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerRegistryLog> GetLog(string serverName);
            /// <summary>
            /// Check the online status of the server 
///            检查服务在线状态
            /// </summary>
            /// <param name="sessionID">Server session identity 
///            服务会话标识</param>
            /// <param name="serverName">Server name 
///            服务名称</param>
            AutoCSer.Net.SendOnlyCommand Check(long sessionID, string serverName);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Service basic operation interface 
///            服务基础操作接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IServiceNode))]
        public partial interface IServiceNodeClientNode
        {
            /// <summary>
            /// Create a array node IArrayNode{T} 
///            创建数组节点 IArrayNode{T}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="length">Array length</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateArrayNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int length);
            /// <summary>
            /// Create a bitmap node IBitmapNode 
///            创建位图节点 IBitmapNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="capacity">The number of binary bits 
///            二进制位数量</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateBitmapNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, uint capacity);
            /// <summary>
            /// Create a dictionary node IByteArrayDictionaryNode{KT} 
///            创建字典节点 IByteArrayDictionaryNode{KT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <param name="groupType">Reusable dictionary recombination operation type 
///            可重用字典重组操作类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateByteArrayDictionaryNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int capacity, AutoCSer.ReusableDictionaryGroupTypeEnum groupType);
            /// <summary>
            /// Create a dictionary node IByteArrayFragmentDictionaryNode{KT} 
///            创建字典节点 IByteArrayFragmentDictionaryNode{KT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateByteArrayFragmentDictionaryNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType);
            /// <summary>
            /// Create a queue node IByteArrayQueueNode (First in, first Out) 
///            创建队列节点（先进先出） IByteArrayQueueNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateByteArrayQueueNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, int capacity);
            /// <summary>
            /// Create a stack node IByteArrayStackNode (Last in, first out) 
///            创建栈节点（后进先出） IByteArrayStackNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateByteArrayStackNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, int capacity);
            /// <summary>
            /// Create a dictionary node IDictionaryNode{KT,VT} 
///            创建字典节点 IDictionaryNode{KT,VT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="valueType">Data type</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <param name="groupType">Reusable dictionary recombination operation type 
///            可重用字典重组操作类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateDictionaryNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, AutoCSer.Reflection.RemoteType valueType, int capacity, AutoCSer.ReusableDictionaryGroupTypeEnum groupType);
            /// <summary>
            /// Create distributed lock nodes IDistributedLockNode{KT} 
///            创建分布式锁节点 IDistributedLockNode{KT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateDistributedLockNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType);
            /// <summary>
            /// Create a dictionary node IFragmentDictionaryNode{KT,VT} 
///            创建字典节点 IFragmentDictionaryNode{KT,VT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="valueType">Data type</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateFragmentDictionaryNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, AutoCSer.Reflection.RemoteType valueType);
            /// <summary>
            /// Create a 256 base fragment hash table node IFragmentHashSetNode{KT} 
///            创建 256 基分片哈希表节点 IFragmentHashSetNode{KT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateFragmentHashSetNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType);
            /// <summary>
            /// Create a dictionary node IHashBytesDictionaryNode 
///            创建字典节点 IHashBytesDictionaryNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <param name="groupType">Reusable dictionary recombination operation type 
///            可重用字典重组操作类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateHashBytesDictionaryNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, int capacity, AutoCSer.ReusableDictionaryGroupTypeEnum groupType);
            /// <summary>
            /// Create a dictionary node IHashBytesFragmentDictionaryNode 
///            创建字典节点 IHashBytesFragmentDictionaryNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateHashBytesFragmentDictionaryNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo);
            /// <summary>
            /// Create a hash table node IHashSetNode{KT} 
///            创建哈希表节点 IHashSetNode{KT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <param name="groupType">Reusable dictionary recombination operation type 
///            可重用字典重组操作类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateHashSetNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int capacity, AutoCSer.ReusableDictionaryGroupTypeEnum groupType);
            /// <summary>
            /// Create a 64-bit auto-increment identity node IIdentityGeneratorNode 
///            创建 64 位自增ID 节点 IIdentityGeneratorNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="identity">Initial Allocation identity 
///            起始分配 ID</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateIdentityGeneratorNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, long identity);
            /// <summary>
            /// Create a array node ILeftArrayNode{T} 
///            创建数组节点 ILeftArrayNode{T}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateLeftArrayNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int capacity);
            /// <summary>
            /// Create a message processing node IMessageNode{T} 
///            创建消息处理节点 IMessageNode{T}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="messageType">Message data type 
///            消息数据类型</param>
            /// <param name="arraySize">The size of the message array being processed 
///            正在处理的消息数组大小</param>
            /// <param name="timeoutSeconds">The number of seconds of message processing timeout 
///            消息处理超时秒数</param>
            /// <param name="checkTimeoutSeconds">Check the interval in seconds for message timeouts 
///            消息超时检查间隔秒数</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateMessageNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType messageType, int arraySize, int timeoutSeconds, int checkTimeoutSeconds);
            /// <summary>
            /// Create a queue node IQueueNode{T} (First in, first Out) 
///            创建队列节点（先进先出） IQueueNode{T}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateQueueNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int capacity);
            /// <summary>
            /// Create a binary search tree node ISearchTreeDictionaryNode{KT,VT} 
///            创建二叉搜索树节点 ISearchTreeDictionaryNode{KT,VT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="valueType">Data type</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateSearchTreeDictionaryNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, AutoCSer.Reflection.RemoteType valueType);
            /// <summary>
            /// Create a binary search tree collection node ISearchTreeSetNode{KT} 
///            创建二叉搜索树集合节点 ISearchTreeSetNode{KT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateSearchTreeSetNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType);
            /// <summary>
            /// Create a message processing node IMessageNode{ServerByteArrayMessage} 
///            创建消息处理节点 IMessageNode{ServerByteArrayMessage}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="arraySize">The size of the message array being processed 
///            正在处理的消息数组大小</param>
            /// <param name="timeoutSeconds">The number of seconds of message processing timeout 
///            消息处理超时秒数</param>
            /// <param name="checkTimeoutSeconds">Check the interval in seconds for message timeouts 
///            消息超时检查间隔秒数</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateServerByteArrayMessageNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, int arraySize, int timeoutSeconds, int checkTimeoutSeconds);
            /// <summary>
            /// Create a sorting dictionary node ISortedDictionaryNode{KT,VT} 
///            创建排序字典节点 ISortedDictionaryNode{KT,VT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="valueType">Data type</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateSortedDictionaryNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, AutoCSer.Reflection.RemoteType valueType);
            /// <summary>
            /// Create a sorting list node ISortedListNode{KT,VT} 
///            创建排序列表节点 ISortedListNode{KT,VT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="valueType">Data type</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateSortedListNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, AutoCSer.Reflection.RemoteType valueType, int capacity);
            /// <summary>
            /// Create sorted collection node ISortedSetNode{KT} 
///            创建排序集合节点 ISortedSetNode{KT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateSortedSetNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType);
            /// <summary>
            /// Create a stack node IStackNode{T} (Last in, first out) 
///            创建栈节点（后进先出） IStackNode{T}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateStackNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int capacity);
            /// <summary>
            /// Delete the node 
///            删除节点
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <returns>Returning false indicates that the node was not found 
///            返回 false 表示没有找到节点</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> RemoveNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index);
            /// <summary>
            /// Create a server registration node IServerRegistryNode 
///            创建服务注册节点 IServerRegistryNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="loadTimeoutSeconds">Cold start session timeout seconds 
///            冷启动会话超时秒数</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateServerRegistryNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, int loadTimeoutSeconds);
            /// <summary>
            /// Create a service process daemon node IProcessGuardNode 
///            创建服务进程守护节点 IProcessGuardNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateProcessGuardNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo);
            /// <summary>
            /// Creat a multi-hash bitmap client synchronization filter node IManyHashBitMapClientFilterNode 
///            创建多哈希位图客户端同步过滤节点 IManyHashBitMapClientFilterNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="size">Bitmap size (number of bits) 
///            位图大小（位数量）</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateManyHashBitMapClientFilterNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, int size);
            /// <summary>
            /// Creat a multi-hash bitmap filter node IManyHashBitMapFilterNode 
///            创建多哈希位图过滤节点 IManyHashBitMapFilterNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="size">Bitmap size (number of bits) 
///            位图大小（位数量）</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateManyHashBitMapFilterNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, int size);
            /// <summary>
            /// Delete the node 
///            删除节点
            /// </summary>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <returns>Returning false indicates that the node was not found 
///            返回 false 表示没有找到节点</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> RemoveNodeByKey(string key);
            /// <summary>
            /// Create an archive node only IOnlyPersistenceNode{T} 
///            创建仅存档节点 IOnlyPersistenceNode{T}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="valueType">Archive data type 
///            存档数据类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex> CreateOnlyPersistenceNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType valueType);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Sort dictionary node interface 
///            排序字典节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISortedDictionaryNode<,>))]
        public partial interface ISortedDictionaryNodeClientNode<KT,VT>
        {
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Clear();
            /// <summary>
            /// Determine whether the keyword exists 
///            判断关键字是否存在
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> ContainsKey(KT key);
            /// <summary>
            /// To determine whether the data exists, the time complexity is O(n). It is not recommended to call (since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            判断数据是否存在，时间复杂度 O(n) 不建议调用（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> ContainsValue(VT value);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> Count();
            /// <summary>
            /// Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>> GetRemove(KT key);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="key"></param>
            /// <returns>Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Remove(KT key);
            /// <summary>
            /// Add data
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> TryAdd(KT key, VT value);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>> TryGetValue(KT key);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="keys"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<VT[]> GetValueArray(KT[] keys);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="keys"></param>
            /// <returns>The number of deleted keywords 
///            删除关键字数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> RemoveKeys(KT[] keys);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Sort list node interface 
///            排序列表节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISortedListNode<,>))]
        public partial interface ISortedListNodeClientNode<KT,VT>
        {
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Clear();
            /// <summary>
            /// Determine whether the keyword exists 
///            判断关键字是否存在
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> ContainsKey(KT key);
            /// <summary>
            /// To determine whether the data exists, the time complexity is O(n). It is not recommended to call (since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            判断数据是否存在，时间复杂度 O(n) 不建议调用（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> ContainsValue(VT value);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> Count();
            /// <summary>
            /// Get the container size 
///            获取容器大小
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> GetCapacity();
            /// <summary>
            /// Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>> GetRemove(KT key);
            /// <summary>
            /// Get the ranking position of the key word 
///            获取关键字排序位置
            /// </summary>
            /// <param name="key"></param>
            /// <returns>A negative number indicates that the keyword was not found 
///            负数表示没有找到关键字</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> IndexOfKey(KT key);
            /// <summary>
            /// Get the first matching data sort position (since cached data is a serialized copy of the object, the equality test is done by implementing IEquatable{VT}) 
///            获取第一个匹配数据排序位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <returns>A negative number indicates that no matching data was found 
///            负数表示没有找到匹配数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> IndexOfValue(VT value);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="key"></param>
            /// <returns>Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Remove(KT key);
            /// <summary>
            /// Delete the data at the specified sort index position 
///            删除指定排序索引位置数据
            /// </summary>
            /// <param name="index"></param>
            /// <returns>Returning false indicates that the index is out of range 
///            返回 false 表示索引超出范围</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> RemoveAt(int index);
            /// <summary>
            /// Add data
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> TryAdd(KT key, VT value);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>> TryGetValue(KT key);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Sort collection node interface 
///            排序集合节点接口 client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISortedSetNode<>))]
        public partial interface ISortedSetNodeClientNode<T>
        {
            /// <summary>
            /// Add data
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Add(T value);
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Clear();
            /// <summary>
            /// Determine whether the keyword exists 
///            判断关键字是否存在
            /// </summary>
            /// <param name="value"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Contains(T value);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> Count();
            /// <summary>
            /// Get the maximum value 
///            获取最大值
            /// </summary>
            /// <returns>No return value is returned when there is no data 
///            没有数据时返回无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>> GetMax();
            /// <summary>
            /// Get the minimum value 
///            获取最小值
            /// </summary>
            /// <returns>No return value is returned when there is no data 
///            没有数据时返回无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>> GetMin();
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Remove(T value);
            /// <summary>
            /// If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// </summary>
            /// <param name="values"></param>
            /// <returns>The quantity of the added data 
///            添加数据数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> AddValues(T[] values);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="values"></param>
            /// <returns>The quantity of deleted data 
///            删除数据数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> RemoveValues(T[] values);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Stack node interface (Last in, first out) 
///            栈节点接口（后进先出） client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IStackNode<>))]
        public partial interface IStackNodeClientNode<T>
        {
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Clear();
            /// <summary>
            /// Determine whether there is matching data (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            判断是否存在匹配数据（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value">Data to be matched 
///            待匹配数据</param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<bool> Contains(T value);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<int> Count();
            /// <summary>
            /// Add the data to the stack 
///            将数据添加到栈
            /// </summary>
            /// <param name="value"></param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseResultAwaiter Push(T value);
            /// <summary>
            /// Get the next popped data in the stack (no popped data, only view) 
///            获取栈中下一个弹出数据（不弹出数据仅查看）
            /// </summary>
            /// <returns>If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>> TryPeek();
            /// <summary>
            /// Pop a piece of data from the stack 
///            从栈中弹出一个数据
            /// </summary>
            /// <returns>If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameterAwaiter<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>> TryPop();
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CustomNode
{
        /// <summary>
        /// Timeout task message node interface (for distributed transaction data consistency check) 
///            超时任务消息节点接口（用于分布式事务数据一致性检查） local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CustomNode.ITimeoutMessageNode<>))]
        public partial interface ITimeoutMessageNodeLocalClientNode<T>
        {
            /// <summary>
            /// Add the task node 
///            添加任务节点
            /// </summary>
            /// <param name="task"></param>
            /// <returns>Task identifier. Return 0 upon failure 
///            任务标识，失败返回 0</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<long>> Append(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CustomNode.TimeoutMessage<T> task);
            /// <summary>
            /// Cancel the task 
///            取消任务
            /// </summary>
            /// <param name="identity">Task identity 
///            任务标识</param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> Cancel(long identity);
            /// <summary>
            /// Get the total number of tasks 
///            获取任务总数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> GetCount();
            /// <summary>
            /// Get the number of failed tasks executed 
///            获取执行失败任务数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> GetFailedCount();
            /// <summary>
            /// Failed task retry 
///            失败任务重试
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> RetryFailed();
            /// <summary>
            /// Trigger task execution 
///            触发任务执行
            /// </summary>
            /// <param name="identity">Task identity 
///            任务标识</param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> RunTask(long identity);
            /// <summary>
            /// Add immediate execution tasks 
///            添加立即执行任务
            /// </summary>
            /// <param name="task"></param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> AppendRun(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CustomNode.TimeoutMessage<T> task);
            /// <summary>
            /// Get the execution task message data 
///            获取执行任务消息数据
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<System.IDisposable> GetRunTask(System.Action<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<T>> __callback__);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Array node interface 
///            数组节点接口 local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IArrayNode<>))]
        public partial interface IArrayNodeLocalClientNode<T>
        {
            /// <summary>
            /// Clear the data at the specified location 
///            清除指定位置数据
            /// </summary>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">Clear data quantity 
///            清除数据数量</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Clear(int startIndex, int count);
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> ClearArray();
            /// <summary>
            /// Fill the array with data to specify the position 
///            用数据填充数组指定位置
            /// </summary>
            /// <param name="value"></param>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">The number of filled data 
///            填充数据数量</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Fill(T value, int startIndex, int count);
            /// <summary>
            /// Fill the entire array with data 
///            用数据填充整个数组
            /// </summary>
            /// <param name="value"></param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> FillArray(T value);
            /// <summary>
            /// Get the array length 
///            获取数组长度
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> GetLength();
            /// <summary>
            /// Get data based on index location 
///            根据索引位置获取数据
            /// </summary>
            /// <param name="index">Index position 
///            索引位置</param>
            /// <returns>If the return exceeds the index, there will be no return value 
///            超出索引返回则无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>>> GetValue(int index);
            /// <summary>
            /// Set the data according to the index position and return the data before the setting 
///            根据索引位置设置数据并返回设置之前的数据
            /// </summary>
            /// <param name="index">Index position 
///            索引位置</param>
            /// <param name="value">data</param>
            /// <returns>Set the previous data. If it exceeds the index and returns, there will be no return value 
///            设置之前的数据，超出索引返回则无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>>> GetValueSet(int index, T value);
            /// <summary>
            /// Find the position of the first matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找第一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">Search for the number of matching data 
///            查找匹配数据数量</param>
            /// <returns>Failure returns a negative number 
///            失败返回负数</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> IndexOf(T value, int startIndex, int count);
            /// <summary>
            /// Find the position of the first matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找第一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Failure returns a negative number 
///            失败返回负数</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> IndexOfArray(T value);
            /// <summary>
            /// Find the position of the last matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找最后一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <param name="startIndex">The last matching position (the starting position) 
///            最后一个匹配位置（起始位置）</param>
            /// <param name="count">Search for the number of matching data 
///            查找匹配数据数量</param>
            /// <returns>Failure returns a negative number 
///            失败返回负数</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> LastIndexOf(T value, int startIndex, int count);
            /// <summary>
            /// Find the position of the last matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找最后一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Failure returns a negative number 
///            失败返回负数</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> LastIndexOfArray(T value);
            /// <summary>
            /// Reverse the array data at the specified position 
///            反转指定位置数组数据
            /// </summary>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">Reverse the amount of data 
///            反转数据数量</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Reverse(int startIndex, int count);
            /// <summary>
            /// Reverse the entire array data 
///            反转整个数组数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> ReverseArray();
            /// <summary>
            /// Set the data according to the index position 
///            根据索引位置设置数据
            /// </summary>
            /// <param name="index">Index position 
///            索引位置</param>
            /// <param name="value">data</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> SetValue(int index, T value);
            /// <summary>
            /// Sort the array data at the specified position 
///            排序指定位置数组数据
            /// </summary>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">The quantity of data to be sorted 
///            排序数据数量</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Sort(int startIndex, int count);
            /// <summary>
            /// Array sorting 
///            数组排序
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> SortArray();
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Bitmap node interface 
///            位图节点接口 local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IBitmapNode))]
        public partial interface IBitmapNodeLocalClientNode
        {
            /// <summary>
            /// Clear bit status 
///            清除位状态
            /// </summary>
            /// <param name="index">Bit index position 
///            位索引位置</param>
            /// <returns>Returning false indicates that the index is out of range 
///            返回 false 表示索引超出范围</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> ClearBit(uint index);
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> ClearMap();
            /// <summary>
            /// Read bit status 
///            读取位状态
            /// </summary>
            /// <param name="index">Bit index position 
///            位索引位置</param>
            /// <returns>A non-0 indicates that the binary bit is in the set state. If the index exceeds, there will be no return value 
///            非 0 表示二进制位为已设置状态，索引超出则无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<int>>> GetBit(uint index);
            /// <summary>
            /// Clear the bit state and return to the state before setting 
///            清除位状态并返回设置之前的状态
            /// </summary>
            /// <param name="index">Bit index position 
///            位索引位置</param>
            /// <returns>Clear the state before the operation. A non-0 state indicates that the binary bit was in the set state before. If the index exceeds, there will be no return value 
///            清除操作之前的状态，非 0 表示二进制位之前为已设置状态，索引超出则无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<int>>> GetBitClearBit(uint index);
            /// <summary>
            /// Reverse the bit state and return the state before the operation 
///            位状态取反并返回操作之前的状态
            /// </summary>
            /// <param name="index">Bit index position 
///            位索引位置</param>
            /// <returns>Take the state before the reverse operation. If it is not 0, it indicates that the binary bit is in the set state before. If the index exceeds, there will be no return value 
///            取反操作之前的状态，非 0 表示二进制位之前为已设置状态，索引超出则无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<int>>> GetBitInvertBit(uint index);
            /// <summary>
            /// Set the bit state and return the state before setting 
///            设置位状态并返回设置之前的状态
            /// </summary>
            /// <param name="index">Bit index position 
///            位索引位置</param>
            /// <returns>The state before setting: A non-0 indicates that the binary bit was in the set state before, and there is no return value if the index exceeds 
///            设置之前的状态，非 0 表示二进制位之前为已设置状态，索引超出则无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<int>>> GetBitSetBit(uint index);
            /// <summary>
            /// Get the number of bitmap binary bits 
///            获取位图二进制位数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<uint>> GetCapacity();
            /// <summary>
            /// Reverse the bit state 
///            位状态取反
            /// </summary>
            /// <param name="index">Bit index position 
///            位索引位置</param>
            /// <returns>Returning false indicates that the index is out of range 
///            返回 false 表示索引超出范围</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> InvertBit(uint index);
            /// <summary>
            /// Set bit status 
///            设置位状态
            /// </summary>
            /// <param name="index">Bit index position 
///            位索引位置</param>
            /// <returns>Returning false indicates that the index is out of range 
///            返回 false 表示索引超出范围</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> SetBit(uint index);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Dictionary node interface 
///            字典节点接口 local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDictionaryNode<,>))]
        public partial interface IDictionaryNodeLocalClientNode<KT,VT>
        {
            /// <summary>
            /// 
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> Clear();
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> ContainsKey(KT key);
            /// <summary>
            /// 
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> ReusableClear();
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> Count();
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>>> GetRemove(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Remove(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="capacity"></param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> Renew(int capacity);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Set(KT key, VT value);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> TryAdd(KT key, VT value);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>>> TryGetValue(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="keys"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<VT[]>> GetValueArray(KT[] keys);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="keys"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> RemoveKeys(KT[] keys);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Distributed lock node interface 
///            分布式锁节点接口 local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IDistributedLockNode<>))]
        public partial interface IDistributedLockNodeLocalClientNode<T>
        {
            /// <summary>
            /// Apply for a lock 
///            申请锁
            /// </summary>
            /// <param name="key">Keyword of lock 
///            锁关键字</param>
            /// <param name="timeoutSeconds">Timeout seconds 
///            超时秒数</param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<long>> Enter(T key, ushort timeoutSeconds);
            /// <summary>
            /// Release the lock 
///            释放锁
            /// </summary>
            /// <param name="key">Keyword of lock 
///            锁关键字</param>
            /// <param name="identity">Lock request identity 
///            锁请求标识</param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.MethodParameter Release(T key, long identity);
            /// <summary>
            /// Try to apply for a lock 
///            尝试申请锁
            /// </summary>
            /// <param name="key">Keyword of lock 
///            锁关键字</param>
            /// <param name="timeoutSeconds">Timeout seconds 
///            超时秒数</param>
            /// <returns>Lock request identity. Return 0 if failed 
///            锁请求标识，失败返回 0</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<long>> TryEnter(T key, ushort timeoutSeconds);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// 256 base fragment dictionary node interface 
///            256 基分片字典 节点接口 local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IFragmentDictionaryNode<,>))]
        public partial interface IFragmentDictionaryNodeLocalClientNode<KT,VT>
        {
            /// <summary>
            /// Clear the data (retain the fragmented array) 
///            清除数据（保留分片数组）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> Clear();
            /// <summary>
            /// Clear fragmented array (used to solve the problem of low performance of clear call when the amount of data is large) 
///            清除分片数组（用于解决数据量较大的情况下 Clear 调用性能低下的问题）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> ClearArray();
            /// <summary>
            /// Determine whether the keyword exists 
///            判断关键字是否存在
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> ContainsKey(KT key);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> Count();
            /// <summary>
            /// Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>>> GetRemove(KT key);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="key"></param>
            /// <returns>Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Remove(KT key);
            /// <summary>
            /// Force the data to be set and overwrite if the keyword already exists 
///            强制设置数据，如果关键字已存在则覆盖
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns>Return false on failure</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Set(KT key, VT value);
            /// <summary>
            /// If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> TryAdd(KT key, VT value);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>>> TryGetValue(KT key);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="keys"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<VT[]>> GetValueArray(KT[] keys);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="keys"></param>
            /// <returns>The number of deleted keywords 
///            删除关键字数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> RemoveKeys(KT[] keys);
            /// <summary>
            /// Reusable dictionaries reset data locations (The presence of reference type data can cause memory leaks) 
///            可重用字典重置数据位置（存在引用类型数据会造成内存泄露）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> ReusableClear();
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// 256 base fragment hash table node interface 
///            256 基分片 哈希表 节点接口 local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IFragmentHashSetNode<>))]
        public partial interface IFragmentHashSetNodeLocalClientNode<T>
        {
            /// <summary>
            /// If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Add(T value);
            /// <summary>
            /// Clear the data (retain the fragmented array) 
///            清除数据（保留分片数组）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> Clear();
            /// <summary>
            /// Clear fragmented array (used to solve the problem of low performance of clear call when the amount of data is large) 
///            清除分片数组（用于解决数据量较大的情况下 Clear 调用性能低下的问题）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> ClearArray();
            /// <summary>
            /// Determine whether the keyword exists 
///            判断关键字是否存在
            /// </summary>
            /// <param name="value"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Contains(T value);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> Count();
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Remove(T value);
            /// <summary>
            /// If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// </summary>
            /// <param name="values"></param>
            /// <returns>The quantity of the added data 
///            添加数据数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> AddValues(T[] values);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="values"></param>
            /// <returns>The quantity of deleted data 
///            删除数据数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> RemoveValues(T[] values);
            /// <summary>
            /// Reusable hash tables reset data locations (The presence of reference type data can cause memory leaks) 
///            可重用哈希表重置数据位置（存在引用类型数据会造成内存泄露）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> ReusableClear();
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Hash table node interface 
///            哈希表节点接口 local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IHashSetNode<>))]
        public partial interface IHashSetNodeLocalClientNode<T>
        {
            /// <summary>
            /// Add data
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Add(T value);
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> Clear();
            /// <summary>
            /// Determine whether the keyword exists 
///            判断关键字是否存在
            /// </summary>
            /// <param name="value"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Contains(T value);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> Count();
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Remove(T value);
            /// <summary>
            /// Clear all data and rebuild the container (to solve the problem of low performance of the clear call when the data volume is large) 
///            清除所有数据并重建容器（用于解决数据量较大的情况下 Clear 调用性能低下的问题）
            /// </summary>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> Renew(int capacity);
            /// <summary>
            /// Reusable dictionaries reset data locations (The presence of reference type data can cause memory leaks) 
///            可重用字典重置数据位置（存在引用类型数据会造成内存泄露）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> ReusableClear();
            /// <summary>
            /// If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// </summary>
            /// <param name="values"></param>
            /// <returns>The quantity of the added data 
///            添加数据数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> AddValues(T[] values);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="values"></param>
            /// <returns>The quantity of deleted data 
///            删除数据数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> RemoveValues(T[] values);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// 64-bit auto-increment identity node interface 
///            64 位自增ID 节点接口 local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IIdentityGeneratorNode))]
        public partial interface IIdentityGeneratorNodeLocalClientNode
        {
            /// <summary>
            /// Get the next increment identity 
///            获取下一个自增ID
            /// </summary>
            /// <returns>The next increment identity returns a negative number on failure 
///            下一个自增ID，失败返回负数</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<long>> Next();
            /// <summary>
            /// Gets the auto-increment identity segment 
///            获取自增 ID 分段
            /// </summary>
            /// <param name="count">Get the quantity of data 
///            获取数据数量</param>
            /// <returns>Auto-increment identity segment 
///            自增 ID 分段</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IdentityFragment>> NextFragment(int count);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Array node interface 
///            数组节点接口 local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ILeftArrayNode<>))]
        public partial interface ILeftArrayNodeLocalClientNode<T>
        {
            /// <summary>
            /// Add data
            /// </summary>
            /// <param name="value">data</param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> Add(T value);
            /// <summary>
            /// Clear the data at the specified location 
///            清除指定位置数据
            /// </summary>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">Clear data quantity 
///            清除数据数量</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Clear(int startIndex, int count);
            /// <summary>
            /// Clear all the data and set the valid length of the data to 0 
///            清除所有数据并将数据有效长度设置为 0
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> ClearLength();
            /// <summary>
            /// Fill the array with data to specify the position 
///            用数据填充数组指定位置
            /// </summary>
            /// <param name="value"></param>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">The number of filled data 
///            填充数据数量</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Fill(T value, int startIndex, int count);
            /// <summary>
            /// Fill the entire array with data 
///            用数据填充整个数组
            /// </summary>
            /// <param name="value"></param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> FillArray(T value);
            /// <summary>
            /// Get the size of the array container 
///            获取数组容器大小
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> GetCapacity();
            /// <summary>
            /// Get the number of containers free 
///            获取容器空闲数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> GetFreeCount();
            /// <summary>
            /// Get the valid length of the array 
///            获取数组有效长度
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> GetLength();
            /// <summary>
            /// Remove the last data and return it 
///            移除最后一个数据并返回该数据
            /// </summary>
            /// <returns>No data will be returned if there is no removable data 
///            没有可移除数据则无数据返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>>> GetTryPopValue();
            /// <summary>
            /// Get data based on index location 
///            根据索引位置获取数据
            /// </summary>
            /// <param name="index">Index position 
///            索引位置</param>
            /// <returns>If the return exceeds the index, there will be no return value 
///            超出索引返回则无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>>> GetValue(int index);
            /// <summary>
            /// Remove the data at the specified index position and return the removed data 
///            移除指定索引位置数据并返回被移除的数据
            /// </summary>
            /// <param name="index">Data location 
///            数据位置</param>
            /// <returns>No data will be returned if the index range is exceeded 
///            超出索引范围则无数据返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>>> GetValueRemoveAt(int index);
            /// <summary>
            /// Remove the data at the specified index position, move the last data to the specified position, and return the removed data 
///            移除指定索引位置数据，将最后一个数据移动到该指定位置，并返回被移除的数据
            /// </summary>
            /// <param name="index"></param>
            /// <returns>No data will be returned if the index range is exceeded 
///            超出索引范围则无数据返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>>> GetValueRemoveToEnd(int index);
            /// <summary>
            /// Set the data according to the index position and return the data before the setting 
///            根据索引位置设置数据并返回设置之前的数据
            /// </summary>
            /// <param name="index">Index position 
///            索引位置</param>
            /// <param name="value">data</param>
            /// <returns>Set the previous data. If it exceeds the index and returns, there will be no return value 
///            设置之前的数据，超出索引返回则无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>>> GetValueSet(int index, T value);
            /// <summary>
            /// Find the position of the first matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找第一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">Search for the number of matching data 
///            查找匹配数据数量</param>
            /// <returns>Failure returns a negative number 
///            失败返回负数</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> IndexOf(T value, int startIndex, int count);
            /// <summary>
            /// Find the position of the first matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找第一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Failure returns a negative number 
///            失败返回负数</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> IndexOfArray(T value);
            /// <summary>
            /// Insert data 
///            插入数据
            /// </summary>
            /// <param name="index">Insert position 
///            插入位置</param>
            /// <param name="value">data</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Insert(int index, T value);
            /// <summary>
            /// Find the position of the last matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找最后一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <param name="startIndex">The last matching position (the starting position) 
///            最后一个匹配位置（起始位置）</param>
            /// <param name="count">Search for the number of matching data 
///            查找匹配数据数量</param>
            /// <returns>Failure returns a negative number 
///            失败返回负数</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> LastIndexOf(T value, int startIndex, int count);
            /// <summary>
            /// Find the position of the last matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找最后一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Failure returns a negative number 
///            失败返回负数</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> LastIndexOfArray(T value);
            /// <summary>
            /// Remove the first matching data (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            移除第一个匹配数据（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value">data</param>
            /// <returns>Returning false indicates that there is no data match 
///            返回 false 表示不存在数据匹配</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Remove(T value);
            /// <summary>
            /// Remove the data at the specified index position 
///            移除指定索引位置数据
            /// </summary>
            /// <param name="index">Data location 
///            数据位置</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> RemoveAt(int index);
            /// <summary>
            /// Remove the data at the specified index position and move the last data to that specified position 
///            移除指定索引位置数据并将最后一个数据移动到该指定位置
            /// </summary>
            /// <param name="index"></param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> RemoveToEnd(int index);
            /// <summary>
            /// Reverse the array data at the specified position 
///            反转指定位置数组数据
            /// </summary>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">Reverse the amount of data 
///            反转数据数量</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Reverse(int startIndex, int count);
            /// <summary>
            /// Reverse the entire array data 
///            反转整个数组数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> ReverseArray();
            /// <summary>
            /// Empty and release the array 
///            置空并释放数组
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> SetEmpty();
            /// <summary>
            /// Set the data according to the index position 
///            根据索引位置设置数据
            /// </summary>
            /// <param name="index">Index position 
///            索引位置</param>
            /// <param name="value">data</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> SetValue(int index, T value);
            /// <summary>
            /// Sort the array data at the specified position 
///            排序指定位置数组数据
            /// </summary>
            /// <param name="startIndex">Starting position 
///            起始位置</param>
            /// <param name="count">The quantity of data to be sorted 
///            排序数据数量</param>
            /// <returns>Return false if it exceeds the index range 
///            超出索引范围则返回 false</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Sort(int startIndex, int count);
            /// <summary>
            /// Array sorting 
///            数组排序
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> SortArray();
            /// <summary>
            /// Add data when there is a free place 
///            当有空闲位置时添加数据
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the array is full and the addition failed 
///            返回 false 表示数组已满，添加失败</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> TryAdd(T value);
            /// <summary>
            /// Try to remove the last data 
///            尝试移除最后一个数据
            /// </summary>
            /// <returns>Is there any removable data 
///            是否存在可移除数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> TryPop();
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Multi-hash bitmap client synchronization filter node Interface (similar to Bloom filter, suitable for small containers) 
///            多哈希位图客户端同步过滤节点接口（类似布隆过滤器，适合小容器） local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IManyHashBitMapClientFilterNode))]
        public partial interface IManyHashBitMapClientFilterNodeLocalClientNode
        {
            /// <summary>
            /// Get the operation of setting a new bit 
///            获取设置新位操作
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<System.IDisposable> GetBit(System.Action<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> __callback__);
            /// <summary>
            /// Get the current bitmap data 
///            获取当前位图数据
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ManyHashBitMap>> GetData();
            /// <summary>
            /// Set bit 
///            设置位
            /// </summary>
            /// <param name="bit">The set binary bit 
///            设置的二进制位</param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> SetBit(int bit);
            /// <summary>
            /// Get the bitmap size (number of bits) 
///            获取位图大小（位数量）
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> GetSize();
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Multi-hash bitmap filter node interface (similar to Bloom Filter) 
///            多哈希位图过滤节点接口（类似布隆过滤器） local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IManyHashBitMapFilterNode))]
        public partial interface IManyHashBitMapFilterNodeLocalClientNode
        {
            /// <summary>
            /// Get the bitmap size (number of bits) 
///            获取位图大小（位数量）
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> GetSize();
            /// <summary>
            /// Set bit 
///            设置位
            /// </summary>
            /// <param name="size">Bitmap size (number of bits) 
///            位图大小（位数量）</param>
            /// <param name="bits">Binary bit set 
///            位置集合</param>
            /// <returns>Returning false indicates that the bitmap size does not match 
///            返回 false 表示位图大小不匹配</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> SetBits(int size, uint[] bits);
            /// <summary>
            /// Binary bit set matching 
///            位置集合匹配
            /// </summary>
            /// <param name="size">Bitmap size (number of bits) 
///            位图大小（位数量）</param>
            /// <param name="bits">Binary bit set 
///            位置集合</param>
            /// <returns>Returning Null indicates that the bitmap does not match 
///            返回 Null 表示位图不匹配</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.NullableBoolEnum>> CheckBits(int size, uint[] bits);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Message processing node interface 
///            消息处理节点接口 local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IMessageNode<>))]
        public partial interface IMessageNodeLocalClientNode<T>
        {
            /// <summary>
            /// Producers add new message 
///            生产者添加新消息
            /// </summary>
            /// <param name="message"></param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> AppendMessage(T message);
            /// <summary>
            /// Clear all messages 
///            清除所有消息
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> Clear();
            /// <summary>
            /// Clear all failure messages (including handling timeout messages) 
///            清除所有失败消息（包括处理超时消息）
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> ClearFailed();
            /// <summary>
            /// The message has been processed 
///            消息完成处理
            /// </summary>
            /// <param name="identity"></param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.MethodParameter Completed(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.MessageIdeneity identity);
            /// <summary>
            /// Message failed processing 
///            消息失败处理
            /// </summary>
            /// <param name="identity"></param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.MethodParameter Failed(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.MessageIdeneity identity);
            /// <summary>
            /// Get the number of consumer callbacks 
///            获取消费者回调数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> GetCallbackCount();
            /// <summary>
            /// Get the number of uncompleted messages (excluding failed messages) 
///            获取未完成消息数量（不包括失败消息）
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> GetCount();
            /// <summary>
            /// Get the number of failed messages (Including handling timeout messages) 
///            获取失败消息数量（包括处理超时消息）
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> GetFailedCount();
            /// <summary>
            /// The consumer client gets the message 
///            消费客户端获取消息
            /// </summary>
            /// <param name="maxCount">The current maximum number of concurrent messages on the client side 
///            当前客户端最大并发消息数量</param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<System.IDisposable> GetMessage(int maxCount, System.Action<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<T>> __callback__);
            /// <summary>
            /// Get the number of unfinished timeout messages 
///            获取未完成的超时消息数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> GetTimeoutCount();
            /// <summary>
            /// Get the number of uncompleted messages (including failed messages) 
///            获取未完成消息数量（包括失败消息）
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> GetTotalCount();
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Archive-only data node interface (It is used for the rapid archiving of large amounts of concurrent data without modifying memory data or defining snapshot operations) 
///            仅存档数据节点接口（用于大量并发数据快速存档，不修改内存数据，也不定义快照操作） local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IOnlyPersistenceNode<>))]
        public partial interface IOnlyPersistenceNodeLocalClientNode<T>
        {
            /// <summary>
            /// Data archiving 
///            数据存档
            /// </summary>
            /// <param name="value">Data to be archive 
///            待存档数据</param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> Save(T value);
            /// <summary>
            /// Data archiving (The server does not respond) 
///            数据存档（服务端不响应）
            /// </summary>
            /// <param name="value">Data to be archive 
///            待存档数据</param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.MethodParameter SaveSendOnly(T value);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Queue node interface (First In, First Out) 
///            队列节点接口（先进先出） local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IQueueNode<>))]
        public partial interface IQueueNodeLocalClientNode<T>
        {
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> Clear();
            /// <summary>
            /// Determine whether there is matching data in the queue (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            判断队列中是否存在匹配数据（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value">Data to be matched 
///            待匹配数据</param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Contains(T value);
            /// <summary>
            /// Get the number of queue data 
///            获取队列数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> Count();
            /// <summary>
            /// Add the data to the queue 
///            将数据添加到队列
            /// </summary>
            /// <param name="value"></param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> Enqueue(T value);
            /// <summary>
            /// Pop a piece of data from the queue 
///            从队列中弹出一个数据
            /// </summary>
            /// <returns>If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>>> TryDequeue();
            /// <summary>
            /// Get the next pop-up data in the queue (no pop-up data, only view) 
///            获取队列中下一个弹出数据（不弹出数据仅查看）
            /// </summary>
            /// <returns>If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>>> TryPeek();
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Binary search tree node interface 
///            二叉搜索树节点接口 local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISearchTreeDictionaryNode<,>))]
        public partial interface ISearchTreeDictionaryNodeLocalClientNode<KT,VT>
        {
            /// <summary>
            /// 
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> Clear();
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> ContainsKey(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> Count();
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> CountLess(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> CountThan(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> GetHeight();
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>>> GetRemove(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="skipCount"></param>
            /// <param name="getCount"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalKeepCallback<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>>> GetValues(int skipCount, byte getCount);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> IndexOf(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Remove(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Set(KT key, VT value);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> TryAdd(KT key, VT value);
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<KT>>> TryGetFirstKey();
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<AutoCSer.KeyValue<KT,VT>>>> TryGetFirstKeyValue();
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>>> TryGetFirstValue();
            /// <summary>
            /// 
            /// </summary>
            /// <param name="index"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<AutoCSer.KeyValue<KT,VT>>>> TryGetKeyValueByIndex(int index);
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<KT>>> TryGetLastKey();
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<AutoCSer.KeyValue<KT,VT>>>> TryGetLastKeyValue();
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>>> TryGetLastValue();
            /// <summary>
            /// 
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>>> TryGetValue(KT key);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="index"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>>> TryGetValueByIndex(int index);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="keys"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<VT[]>> GetValueArray(KT[] keys);
            /// <summary>
            /// 
            /// </summary>
            /// <param name="keys"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> RemoveKeys(KT[] keys);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Binary search tree collection node interface 
///            二叉搜索树集合节点接口 local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISearchTreeSetNode<>))]
        public partial interface ISearchTreeSetNodeLocalClientNode<T>
        {
            /// <summary>
            /// Add data
            /// </summary>
            /// <param name="value">keyword</param>
            /// <returns>Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Add(T value);
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> Clear();
            /// <summary>
            /// Determine whether the keyword exists 
///            判断关键字是否存在
            /// </summary>
            /// <param name="value">keyword</param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Contains(T value);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> Count();
            /// <summary>
            /// Get the number of nodes smaller than the specified keyword 
///            获取比指定关键字小的节点数量
            /// </summary>
            /// <param name="value">keyword</param>
            /// <returns>Returning -1 indicates that the data to be matched is null 
///            返回 -1 表示待匹配数据为 null</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> CountLess(T value);
            /// <summary>
            /// Get the number of nodes larger than the specified keyword 
///            获取比指定关键字大的节点数量
            /// </summary>
            /// <param name="value">keyword</param>
            /// <returns>Returning -1 indicates that the data to be matched is null 
///            返回 -1 表示待匹配数据为 null</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> CountThan(T value);
            /// <summary>
            /// Get data based on the node position 
///            根据节点位置获取数据
            /// </summary>
            /// <param name="index">Node position 
///            节点位置</param>
            /// <returns>data</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>>> GetByIndex(int index);
            /// <summary>
            /// Get the first data 
///            获取第一个数据
            /// </summary>
            /// <returns>No return value is returned when there is no data 
///            没有数据时返回无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>>> GetFrist();
            /// <summary>
            /// Get the last data 
///            获取最后一个数据
            /// </summary>
            /// <returns>No return value is returned when there is no data 
///            没有数据时返回无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>>> GetLast();
            /// <summary>
            /// Get the matching node location based on the keyword 
///            根据关键字获取匹配节点位置
            /// </summary>
            /// <param name="value">keyword</param>
            /// <returns>Returning -1 indicates a failed match 
///            返回 -1 表示失败匹配</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> IndexOf(T value);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="value">keyword</param>
            /// <returns>Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Remove(T value);
            /// <summary>
            /// If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// </summary>
            /// <param name="values"></param>
            /// <returns>The quantity of the added data 
///            添加数据数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> AddValues(T[] values);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="values"></param>
            /// <returns>The quantity of deleted data 
///            删除数据数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> RemoveValues(T[] values);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Service basic operation interface 
///            服务基础操作接口 local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IServiceNode))]
        public partial interface IServiceNodeLocalClientNode
        {
            /// <summary>
            /// Create a array node IArrayNode{T} 
///            创建数组节点 IArrayNode{T}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="length">Array length</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateArrayNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int length);
            /// <summary>
            /// Create a bitmap node IBitmapNode 
///            创建位图节点 IBitmapNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="capacity">The number of binary bits 
///            二进制位数量</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateBitmapNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, uint capacity);
            /// <summary>
            /// Create a dictionary node IByteArrayDictionaryNode{KT} 
///            创建字典节点 IByteArrayDictionaryNode{KT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <param name="groupType">Reusable dictionary recombination operation type 
///            可重用字典重组操作类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateByteArrayDictionaryNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int capacity, AutoCSer.ReusableDictionaryGroupTypeEnum groupType);
            /// <summary>
            /// Create a dictionary node IByteArrayFragmentDictionaryNode{KT} 
///            创建字典节点 IByteArrayFragmentDictionaryNode{KT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateByteArrayFragmentDictionaryNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType);
            /// <summary>
            /// Create a queue node IByteArrayQueueNode (First in, first Out) 
///            创建队列节点（先进先出） IByteArrayQueueNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateByteArrayQueueNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, int capacity);
            /// <summary>
            /// Create a stack node IByteArrayStackNode (Last in, first out) 
///            创建栈节点（后进先出） IByteArrayStackNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateByteArrayStackNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, int capacity);
            /// <summary>
            /// Create a dictionary node IDictionaryNode{KT,VT} 
///            创建字典节点 IDictionaryNode{KT,VT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="valueType">Data type</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <param name="groupType">Reusable dictionary recombination operation type 
///            可重用字典重组操作类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateDictionaryNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, AutoCSer.Reflection.RemoteType valueType, int capacity, AutoCSer.ReusableDictionaryGroupTypeEnum groupType);
            /// <summary>
            /// Create distributed lock nodes IDistributedLockNode{KT} 
///            创建分布式锁节点 IDistributedLockNode{KT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateDistributedLockNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType);
            /// <summary>
            /// Create a dictionary node IFragmentDictionaryNode{KT,VT} 
///            创建字典节点 IFragmentDictionaryNode{KT,VT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="valueType">Data type</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateFragmentDictionaryNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, AutoCSer.Reflection.RemoteType valueType);
            /// <summary>
            /// Create a 256 base fragment hash table node IFragmentHashSetNode{KT} 
///            创建 256 基分片哈希表节点 IFragmentHashSetNode{KT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateFragmentHashSetNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType);
            /// <summary>
            /// Create a dictionary node IHashBytesDictionaryNode 
///            创建字典节点 IHashBytesDictionaryNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <param name="groupType">Reusable dictionary recombination operation type 
///            可重用字典重组操作类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateHashBytesDictionaryNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, int capacity, AutoCSer.ReusableDictionaryGroupTypeEnum groupType);
            /// <summary>
            /// Create a dictionary node IHashBytesFragmentDictionaryNode 
///            创建字典节点 IHashBytesFragmentDictionaryNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateHashBytesFragmentDictionaryNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo);
            /// <summary>
            /// Create a hash table node IHashSetNode{KT} 
///            创建哈希表节点 IHashSetNode{KT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <param name="groupType">Reusable dictionary recombination operation type 
///            可重用字典重组操作类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateHashSetNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int capacity, AutoCSer.ReusableDictionaryGroupTypeEnum groupType);
            /// <summary>
            /// Create a 64-bit auto-increment identity node IIdentityGeneratorNode 
///            创建 64 位自增ID 节点 IIdentityGeneratorNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="identity">Initial Allocation identity 
///            起始分配 ID</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateIdentityGeneratorNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, long identity);
            /// <summary>
            /// Create a array node ILeftArrayNode{T} 
///            创建数组节点 ILeftArrayNode{T}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateLeftArrayNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int capacity);
            /// <summary>
            /// Create a message processing node IMessageNode{T} 
///            创建消息处理节点 IMessageNode{T}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="messageType">Message data type 
///            消息数据类型</param>
            /// <param name="arraySize">The size of the message array being processed 
///            正在处理的消息数组大小</param>
            /// <param name="timeoutSeconds">The number of seconds of message processing timeout 
///            消息处理超时秒数</param>
            /// <param name="checkTimeoutSeconds">Check the interval in seconds for message timeouts 
///            消息超时检查间隔秒数</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateMessageNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType messageType, int arraySize, int timeoutSeconds, int checkTimeoutSeconds);
            /// <summary>
            /// Create a queue node IQueueNode{T} (First in, first Out) 
///            创建队列节点（先进先出） IQueueNode{T}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateQueueNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int capacity);
            /// <summary>
            /// Create a binary search tree node ISearchTreeDictionaryNode{KT,VT} 
///            创建二叉搜索树节点 ISearchTreeDictionaryNode{KT,VT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="valueType">Data type</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateSearchTreeDictionaryNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, AutoCSer.Reflection.RemoteType valueType);
            /// <summary>
            /// Create a binary search tree collection node ISearchTreeSetNode{KT} 
///            创建二叉搜索树集合节点 ISearchTreeSetNode{KT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateSearchTreeSetNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType);
            /// <summary>
            /// Create a message processing node IMessageNode{ServerByteArrayMessage} 
///            创建消息处理节点 IMessageNode{ServerByteArrayMessage}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="arraySize">The size of the message array being processed 
///            正在处理的消息数组大小</param>
            /// <param name="timeoutSeconds">The number of seconds of message processing timeout 
///            消息处理超时秒数</param>
            /// <param name="checkTimeoutSeconds">Check the interval in seconds for message timeouts 
///            消息超时检查间隔秒数</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateServerByteArrayMessageNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, int arraySize, int timeoutSeconds, int checkTimeoutSeconds);
            /// <summary>
            /// Create a sorting dictionary node ISortedDictionaryNode{KT,VT} 
///            创建排序字典节点 ISortedDictionaryNode{KT,VT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="valueType">Data type</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateSortedDictionaryNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, AutoCSer.Reflection.RemoteType valueType);
            /// <summary>
            /// Create a sorting list node ISortedListNode{KT,VT} 
///            创建排序列表节点 ISortedListNode{KT,VT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="valueType">Data type</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateSortedListNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, AutoCSer.Reflection.RemoteType valueType, int capacity);
            /// <summary>
            /// Create sorted collection node ISortedSetNode{KT} 
///            创建排序集合节点 ISortedSetNode{KT}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateSortedSetNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType);
            /// <summary>
            /// Create a stack node IStackNode{T} (Last in, first out) 
///            创建栈节点（后进先出） IStackNode{T}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="keyType">Keyword type 
///            关键字类型</param>
            /// <param name="capacity">Container initialization size 
///            容器初始化大小</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateStackNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType keyType, int capacity);
            /// <summary>
            /// Delete the node 
///            删除节点
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <returns>Returning false indicates that the node was not found 
///            返回 false 表示没有找到节点</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> RemoveNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index);
            /// <summary>
            /// Create a server registration node IServerRegistryNode 
///            创建服务注册节点 IServerRegistryNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="loadTimeoutSeconds">Cold start session timeout seconds 
///            冷启动会话超时秒数</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateServerRegistryNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, int loadTimeoutSeconds);
            /// <summary>
            /// Create a service process daemon node IProcessGuardNode 
///            创建服务进程守护节点 IProcessGuardNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateProcessGuardNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo);
            /// <summary>
            /// Creat a multi-hash bitmap client synchronization filter node IManyHashBitMapClientFilterNode 
///            创建多哈希位图客户端同步过滤节点 IManyHashBitMapClientFilterNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="size">Bitmap size (number of bits) 
///            位图大小（位数量）</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateManyHashBitMapClientFilterNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, int size);
            /// <summary>
            /// Creat a multi-hash bitmap filter node IManyHashBitMapFilterNode 
///            创建多哈希位图过滤节点 IManyHashBitMapFilterNode
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="size">Bitmap size (number of bits) 
///            位图大小（位数量）</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateManyHashBitMapFilterNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, int size);
            /// <summary>
            /// Delete the node 
///            删除节点
            /// </summary>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <returns>Returning false indicates that the node was not found 
///            返回 false 表示没有找到节点</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> RemoveNodeByKey(string key);
            /// <summary>
            /// Create an archive node only IOnlyPersistenceNode{T} 
///            创建仅存档节点 IOnlyPersistenceNode{T}
            /// </summary>
            /// <param name="index">Node index information 
///            节点索引信息</param>
            /// <param name="key">Node global keyword 
///            节点全局关键字</param>
            /// <param name="nodeInfo">Server-side node information 
///            服务端节点信息</param>
            /// <param name="valueType">Archive data type 
///            存档数据类型</param>
            /// <returns>Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex>> CreateOnlyPersistenceNode(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index, string key, AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo, AutoCSer.Reflection.RemoteType valueType);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Sort dictionary node interface 
///            排序字典节点接口 local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISortedDictionaryNode<,>))]
        public partial interface ISortedDictionaryNodeLocalClientNode<KT,VT>
        {
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> Clear();
            /// <summary>
            /// Determine whether the keyword exists 
///            判断关键字是否存在
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> ContainsKey(KT key);
            /// <summary>
            /// To determine whether the data exists, the time complexity is O(n). It is not recommended to call (since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            判断数据是否存在，时间复杂度 O(n) 不建议调用（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> ContainsValue(VT value);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> Count();
            /// <summary>
            /// Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>>> GetRemove(KT key);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="key"></param>
            /// <returns>Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Remove(KT key);
            /// <summary>
            /// Add data
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> TryAdd(KT key, VT value);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>>> TryGetValue(KT key);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="keys"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<VT[]>> GetValueArray(KT[] keys);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="keys"></param>
            /// <returns>The number of deleted keywords 
///            删除关键字数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> RemoveKeys(KT[] keys);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Sort list node interface 
///            排序列表节点接口 local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISortedListNode<,>))]
        public partial interface ISortedListNodeLocalClientNode<KT,VT>
        {
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> Clear();
            /// <summary>
            /// Determine whether the keyword exists 
///            判断关键字是否存在
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> ContainsKey(KT key);
            /// <summary>
            /// To determine whether the data exists, the time complexity is O(n). It is not recommended to call (since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            判断数据是否存在，时间复杂度 O(n) 不建议调用（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> ContainsValue(VT value);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> Count();
            /// <summary>
            /// Get the container size 
///            获取容器大小
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> GetCapacity();
            /// <summary>
            /// Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>>> GetRemove(KT key);
            /// <summary>
            /// Get the ranking position of the key word 
///            获取关键字排序位置
            /// </summary>
            /// <param name="key"></param>
            /// <returns>A negative number indicates that the keyword was not found 
///            负数表示没有找到关键字</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> IndexOfKey(KT key);
            /// <summary>
            /// Get the first matching data sort position (since cached data is a serialized copy of the object, the equality test is done by implementing IEquatable{VT}) 
///            获取第一个匹配数据排序位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value"></param>
            /// <returns>A negative number indicates that no matching data was found 
///            负数表示没有找到匹配数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> IndexOfValue(VT value);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="key"></param>
            /// <returns>Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Remove(KT key);
            /// <summary>
            /// Delete the data at the specified sort index position 
///            删除指定排序索引位置数据
            /// </summary>
            /// <param name="index"></param>
            /// <returns>Returning false indicates that the index is out of range 
///            返回 false 表示索引超出范围</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> RemoveAt(int index);
            /// <summary>
            /// Add data
            /// </summary>
            /// <param name="key"></param>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> TryAdd(KT key, VT value);
            /// <summary>
            /// Get data based on keywords 
///            根据关键字获取数据
            /// </summary>
            /// <param name="key"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<VT>>> TryGetValue(KT key);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Sort collection node interface 
///            排序集合节点接口 local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ISortedSetNode<>))]
        public partial interface ISortedSetNodeLocalClientNode<T>
        {
            /// <summary>
            /// Add data
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Add(T value);
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> Clear();
            /// <summary>
            /// Determine whether the keyword exists 
///            判断关键字是否存在
            /// </summary>
            /// <param name="value"></param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Contains(T value);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> Count();
            /// <summary>
            /// Get the maximum value 
///            获取最大值
            /// </summary>
            /// <returns>No return value is returned when there is no data 
///            没有数据时返回无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>>> GetMax();
            /// <summary>
            /// Get the minimum value 
///            获取最小值
            /// </summary>
            /// <returns>No return value is returned when there is no data 
///            没有数据时返回无返回值</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>>> GetMin();
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="value"></param>
            /// <returns>Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Remove(T value);
            /// <summary>
            /// If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// </summary>
            /// <param name="values"></param>
            /// <returns>The quantity of the added data 
///            添加数据数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> AddValues(T[] values);
            /// <summary>
            /// Remove keyword 
///            删除关键字
            /// </summary>
            /// <param name="values"></param>
            /// <returns>The quantity of deleted data 
///            删除数据数量</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> RemoveValues(T[] values);
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Stack node interface (Last in, first out) 
///            栈节点接口（后进先出） local client node interface
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ClientNode(typeof(AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IStackNode<>))]
        public partial interface IStackNodeLocalClientNode<T>
        {
            /// <summary>
            /// Clear all data 
///            清除所有数据
            /// </summary>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> Clear();
            /// <summary>
            /// Determine whether there is matching data (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            判断是否存在匹配数据（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// </summary>
            /// <param name="value">Data to be matched 
///            待匹配数据</param>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<bool>> Contains(T value);
            /// <summary>
            /// Get the quantity of data 
///            获取数据数量
            /// </summary>
            /// <returns></returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<int>> Count();
            /// <summary>
            /// Add the data to the stack 
///            将数据添加到栈
            /// </summary>
            /// <param name="value"></param>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult> Push(T value);
            /// <summary>
            /// Get the next popped data in the stack (no popped data, only view) 
///            获取栈中下一个弹出数据（不弹出数据仅查看）
            /// </summary>
            /// <returns>If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>>> TryPeek();
            /// <summary>
            /// Pop a piece of data from the stack 
///            从栈中弹出一个数据
            /// </summary>
            /// <returns>If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据</returns>
            AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalServiceQueueNode<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.LocalResult<AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult<T>>> TryPop();
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CustomNode
{
        /// <summary>
        /// Timeout task message node interface (for distributed transaction data consistency check) 
///            超时任务消息节点接口（用于分布式事务数据一致性检查）
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(ITimeoutMessageNodeMethodEnum))]
        public partial interface ITimeoutMessageNode<T> { }
        /// <summary>
        /// Timeout task message node interface (for distributed transaction data consistency check) 
///            超时任务消息节点接口（用于分布式事务数据一致性检查） (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum ITimeoutMessageNodeMethodEnum
        {
            /// <summary>
            /// [0] Add the task node 
///            添加任务节点
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CustomNode.TimeoutMessage{T} task 
            /// 返回值 long Task identifier. Return 0 upon failure 
///            任务标识，失败返回 0
            /// </summary>
            Append = 0,
            /// <summary>
            /// [1] Add the task node (Check the input parameters before the persistence operation) 
///            添加任务节点（持久化操作之前检查输入参数）
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CustomNode.TimeoutMessage{T} task 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{long} 
            /// </summary>
            AppendBeforePersistence = 1,
            /// <summary>
            /// [2] Cancel the task 
///            取消任务
            /// long identity Task identity 
///            任务标识
            /// </summary>
            Cancel = 2,
            /// <summary>
            /// [3] Complete the completed task 
///            完成已任务
            /// long identity 
            /// bool isSuccess 
            /// </summary>
            Completed = 3,
            /// <summary>
            /// [4] Get the total number of tasks 
///            获取任务总数量
            /// 返回值 int 
            /// </summary>
            GetCount = 4,
            /// <summary>
            /// [5] Get the number of failed tasks executed 
///            获取执行失败任务数量
            /// 返回值 int 
            /// </summary>
            GetFailedCount = 5,
            /// <summary>
            /// [6] Failed task retry 
///            失败任务重试
            /// </summary>
            RetryFailed = 6,
            /// <summary>
            /// [7] Trigger task execution 
///            触发任务执行
            /// long identity Task identity 
///            任务标识
            /// </summary>
            RunTask = 7,
            /// <summary>
            /// [8] Trigger task execution (Initialize and load the persistent data) 
///            触发任务执行（初始化加载持久化数据）
            /// long identity Task identity 
///            任务标识
            /// </summary>
            RunTaskLoadPersistence = 8,
            /// <summary>
            /// [9] Load snapshot data (recover memory data from snapshot data) 
///            加载快照数据（从快照数据恢复内存数据）
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CustomNode.TimeoutMessageData{T} value data
            /// </summary>
            SnapshotAdd = 9,
            /// <summary>
            /// [10] Add immediate execution tasks 
///            添加立即执行任务
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CustomNode.TimeoutMessage{T} task 
            /// </summary>
            AppendRun = 10,
            /// <summary>
            /// [11] Add immediate execution tasks (Check the input parameters before the persistence operation) 
///            添加立即执行任务（持久化操作之前检查输入参数）
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CustomNode.TimeoutMessage{T} task 
            /// 返回值 bool Returning true indicates that a persistence operation is required 
///            返回 true 表示需要持久化操作
            /// </summary>
            AppendRunBeforePersistence = 11,
            /// <summary>
            /// [12] Add immediate execution tasks (Initialize and load the persistent data) 
///            添加立即执行任务（初始化加载持久化数据）
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.CustomNode.TimeoutMessage{T} task 
            /// </summary>
            AppendRunLoadPersistence = 12,
            /// <summary>
            /// [13] Get the execution task message data 
///            获取执行任务消息数据
            /// </summary>
            GetRunTask = 13,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Array node interface 
///            数组节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IArrayNodeMethodEnum))]
        public partial interface IArrayNode<T> { }
        /// <summary>
        /// Array node interface 
///            数组节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IArrayNodeMethodEnum
        {
            /// <summary>
            /// [0] Clear the data at the specified location 
///            清除指定位置数据
            /// int startIndex Starting position 
///            起始位置
            /// int count Clear data quantity 
///            清除数据数量
            /// 返回值 bool Return false if it exceeds the index range 
///            超出索引范围则返回 false
            /// </summary>
            Clear = 0,
            /// <summary>
            /// [1] Clear all data 
///            清除所有数据
            /// </summary>
            ClearArray = 1,
            /// <summary>
            /// [2] Fill the array with data to specify the position 
///            用数据填充数组指定位置
            /// T value 
            /// int startIndex Starting position 
///            起始位置
            /// int count The number of filled data 
///            填充数据数量
            /// 返回值 bool Return false if it exceeds the index range 
///            超出索引范围则返回 false
            /// </summary>
            Fill = 2,
            /// <summary>
            /// [3] Fill the entire array with data 
///            用数据填充整个数组
            /// T value 
            /// </summary>
            FillArray = 3,
            /// <summary>
            /// [4] Get the array length 
///            获取数组长度
            /// 返回值 int 
            /// </summary>
            GetLength = 4,
            /// <summary>
            /// [5] Get data based on index location 
///            根据索引位置获取数据
            /// int index Index position 
///            索引位置
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{T} If the return exceeds the index, there will be no return value 
///            超出索引返回则无返回值
            /// </summary>
            GetValue = 5,
            /// <summary>
            /// [6] Set the data according to the index position and return the data before the setting 
///            根据索引位置设置数据并返回设置之前的数据
            /// int index Index position 
///            索引位置
            /// T value data
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{T} Set the previous data. If it exceeds the index and returns, there will be no return value 
///            设置之前的数据，超出索引返回则无返回值
            /// </summary>
            GetValueSet = 6,
            /// <summary>
            /// [7] Find the position of the first matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找第一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// T value 
            /// int startIndex Starting position 
///            起始位置
            /// int count Search for the number of matching data 
///            查找匹配数据数量
            /// 返回值 int Failure returns a negative number 
///            失败返回负数
            /// </summary>
            IndexOf = 7,
            /// <summary>
            /// [8] Find the position of the first matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找第一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// T value 
            /// 返回值 int Failure returns a negative number 
///            失败返回负数
            /// </summary>
            IndexOfArray = 8,
            /// <summary>
            /// [9] Find the position of the last matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找最后一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// T value 
            /// int startIndex The last matching position (the starting position) 
///            最后一个匹配位置（起始位置）
            /// int count Search for the number of matching data 
///            查找匹配数据数量
            /// 返回值 int Failure returns a negative number 
///            失败返回负数
            /// </summary>
            LastIndexOf = 9,
            /// <summary>
            /// [10] Find the position of the last matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找最后一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// T value 
            /// 返回值 int Failure returns a negative number 
///            失败返回负数
            /// </summary>
            LastIndexOfArray = 10,
            /// <summary>
            /// [11] Reverse the array data at the specified position 
///            反转指定位置数组数据
            /// int startIndex Starting position 
///            起始位置
            /// int count Reverse the amount of data 
///            反转数据数量
            /// 返回值 bool Return false if it exceeds the index range 
///            超出索引范围则返回 false
            /// </summary>
            Reverse = 11,
            /// <summary>
            /// [12] Reverse the entire array data 
///            反转整个数组数据
            /// </summary>
            ReverseArray = 12,
            /// <summary>
            /// [13] Set the data according to the index position 
///            根据索引位置设置数据
            /// int index Index position 
///            索引位置
            /// T value data
            /// 返回值 bool Return false if it exceeds the index range 
///            超出索引范围则返回 false
            /// </summary>
            SetValue = 13,
            /// <summary>
            /// [14] Load snapshot data (recover memory data from snapshot data) 
///            加载快照数据（从快照数据恢复内存数据）
            /// AutoCSer.KeyValue{int,T} value data
            /// </summary>
            SnapshotSet = 14,
            /// <summary>
            /// [15] Sort the array data at the specified position 
///            排序指定位置数组数据
            /// int startIndex Starting position 
///            起始位置
            /// int count The quantity of data to be sorted 
///            排序数据数量
            /// 返回值 bool Return false if it exceeds the index range 
///            超出索引范围则返回 false
            /// </summary>
            Sort = 15,
            /// <summary>
            /// [16] Array sorting 
///            数组排序
            /// </summary>
            SortArray = 16,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Bitmap node interface 
///            位图节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IBitmapNodeMethodEnum))]
        public partial interface IBitmapNode { }
        /// <summary>
        /// Bitmap node interface 
///            位图节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IBitmapNodeMethodEnum
        {
            /// <summary>
            /// [0] Clear bit status 
///            清除位状态
            /// uint index Bit index position 
///            位索引位置
            /// 返回值 bool Returning false indicates that the index is out of range 
///            返回 false 表示索引超出范围
            /// </summary>
            ClearBit = 0,
            /// <summary>
            /// [1] Clear all data 
///            清除所有数据
            /// </summary>
            ClearMap = 1,
            /// <summary>
            /// [2] Read bit status 
///            读取位状态
            /// uint index Bit index position 
///            位索引位置
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{int} A non-0 indicates that the binary bit is in the set state. If the index exceeds, there will be no return value 
///            非 0 表示二进制位为已设置状态，索引超出则无返回值
            /// </summary>
            GetBit = 2,
            /// <summary>
            /// [3] Clear the bit state and return to the state before setting 
///            清除位状态并返回设置之前的状态
            /// uint index Bit index position 
///            位索引位置
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{int} Clear the state before the operation. A non-0 state indicates that the binary bit was in the set state before. If the index exceeds, there will be no return value 
///            清除操作之前的状态，非 0 表示二进制位之前为已设置状态，索引超出则无返回值
            /// </summary>
            GetBitClearBit = 3,
            /// <summary>
            /// [4] Reverse the bit state and return the state before the operation 
///            位状态取反并返回操作之前的状态
            /// uint index Bit index position 
///            位索引位置
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{int} Take the state before the reverse operation. If it is not 0, it indicates that the binary bit is in the set state before. If the index exceeds, there will be no return value 
///            取反操作之前的状态，非 0 表示二进制位之前为已设置状态，索引超出则无返回值
            /// </summary>
            GetBitInvertBit = 4,
            /// <summary>
            /// [5] Set the bit state and return the state before setting 
///            设置位状态并返回设置之前的状态
            /// uint index Bit index position 
///            位索引位置
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{int} The state before setting: A non-0 indicates that the binary bit was in the set state before, and there is no return value if the index exceeds 
///            设置之前的状态，非 0 表示二进制位之前为已设置状态，索引超出则无返回值
            /// </summary>
            GetBitSetBit = 5,
            /// <summary>
            /// [6] Get the number of bitmap binary bits 
///            获取位图二进制位数量
            /// 返回值 uint 
            /// </summary>
            GetCapacity = 6,
            /// <summary>
            /// [7] Reverse the bit state 
///            位状态取反
            /// uint index Bit index position 
///            位索引位置
            /// 返回值 bool Returning false indicates that the index is out of range 
///            返回 false 表示索引超出范围
            /// </summary>
            InvertBit = 7,
            /// <summary>
            /// [8] Set bit status 
///            设置位状态
            /// uint index Bit index position 
///            位索引位置
            /// 返回值 bool Returning false indicates that the index is out of range 
///            返回 false 表示索引超出范围
            /// </summary>
            SetBit = 8,
            /// <summary>
            /// [9] Add snapshot data 
///            添加快照数据
            /// byte[] map 
            /// </summary>
            SnapshotSet = 9,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Dictionary node interface 
///            字典节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IByteArrayDictionaryNodeMethodEnum))]
        public partial interface IByteArrayDictionaryNode<KT> { }
        /// <summary>
        /// Dictionary node interface 
///            字典节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IByteArrayDictionaryNodeMethodEnum
        {
            /// <summary>
            /// [0] Clear all data 
///            清除所有数据
            /// </summary>
            Clear = 0,
            /// <summary>
            /// [1] Determine whether the keyword exists 
///            判断关键字是否存在
            /// KT key 
            /// 返回值 bool 
            /// </summary>
            ContainsKey = 1,
            /// <summary>
            /// [2] Get the quantity of data 
///            获取数据数量
            /// 返回值 int 
            /// </summary>
            Count = 2,
            /// <summary>
            /// [3] Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// KT key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{byte[]} Deleted data and no returned data indicate that the keyword does not exist 
///            被删除数据，无返回数据表示关键字不存在
            /// </summary>
            GetRemove = 3,
            /// <summary>
            /// [4] Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// KT key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter Deleted data and no returned data indicate that the keyword does not exist 
///            被删除数据，无返回数据表示关键字不存在
            /// </summary>
            GetRemoveResponseParameter = 4,
            /// <summary>
            /// [5] Remove keyword 
///            删除关键字
            /// KT key 
            /// 返回值 bool Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在
            /// </summary>
            Remove = 5,
            /// <summary>
            /// [6] Clear all data and rebuild the container (to solve the problem of low performance of the clear call when the data volume is large) 
///            清除所有数据并重建容器（用于解决数据量较大的情况下 Clear 调用性能低下的问题）
            /// int capacity Initialize the size of the new container 
///            新容器初始化大小
            /// </summary>
            Renew = 6,
            /// <summary>
            /// [7] Force the data to be set and overwrite if the keyword already exists 
///            强制设置数据，如果关键字已存在则覆盖
            /// KT key 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value 
            /// 返回值 bool Return false on failure
            /// </summary>
            Set = 7,
            /// <summary>
            /// [8] Add snapshot data 
///            添加快照数据
            /// AutoCSer.BinarySerializeKeyValue{KT,byte[]} value 
            /// </summary>
            SnapshotAdd = 8,
            /// <summary>
            /// [9] Try to add data 
///            尝试添加数据
            /// KT key 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value 
            /// 返回值 bool Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在
            /// </summary>
            TryAdd = 9,
            /// <summary>
            /// [10] Get data based on keywords 
///            根据关键字获取数据
            /// KT key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter 
            /// </summary>
            TryGetResponseParameter = 10,
            /// <summary>
            /// [11] Get data based on keywords 
///            根据关键字获取数据
            /// KT key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{byte[]} 
            /// </summary>
            TryGetValue = 11,
            /// <summary>
            /// [12] Get data based on keywords 
///            根据关键字获取数据
            /// KT[] keys 
            /// 返回值 byte[][] 
            /// </summary>
            GetValueArray = 12,
            /// <summary>
            /// [13] Remove keyword 
///            删除关键字
            /// KT[] keys 
            /// 返回值 int The number of deleted keywords 
///            删除关键字数量
            /// </summary>
            RemoveKeys = 13,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// 256 base fragment dictionary node interface 
///            256 基分片字典 节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IByteArrayFragmentDictionaryNodeMethodEnum))]
        public partial interface IByteArrayFragmentDictionaryNode<KT> { }
        /// <summary>
        /// 256 base fragment dictionary node interface 
///            256 基分片字典 节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IByteArrayFragmentDictionaryNodeMethodEnum
        {
            /// <summary>
            /// [0] Clear the data (retain the fragmented array) 
///            清除数据（保留分片数组）
            /// </summary>
            Clear = 0,
            /// <summary>
            /// [1] Clear fragmented array (used to solve the problem of low performance of clear call when the amount of data is large) 
///            清除分片数组（用于解决数据量较大的情况下 Clear 调用性能低下的问题）
            /// </summary>
            ClearArray = 1,
            /// <summary>
            /// [2] Determine whether the keyword exists 
///            判断关键字是否存在
            /// KT key 
            /// 返回值 bool 
            /// </summary>
            ContainsKey = 2,
            /// <summary>
            /// [3] Get the quantity of data 
///            获取数据数量
            /// 返回值 int 
            /// </summary>
            Count = 3,
            /// <summary>
            /// [4] Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// KT key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{byte[]} Deleted data and no returned data indicate that the keyword does not exist 
///            被删除数据，无返回数据表示关键字不存在
            /// </summary>
            GetRemove = 4,
            /// <summary>
            /// [5] Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// KT key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter Deleted data and no returned data indicate that the keyword does not exist 
///            被删除数据，无返回数据表示关键字不存在
            /// </summary>
            GetRemoveResponseParameter = 5,
            /// <summary>
            /// [6] Remove keyword 
///            删除关键字
            /// KT key 
            /// 返回值 bool Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在
            /// </summary>
            Remove = 6,
            /// <summary>
            /// [7] Force the data to be set and overwrite if the keyword already exists 
///            强制设置数据，如果关键字已存在则覆盖
            /// KT key 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value 
            /// 返回值 bool Return false on failure
            /// </summary>
            Set = 7,
            /// <summary>
            /// [8] Add snapshot data 
///            添加快照数据
            /// AutoCSer.BinarySerializeKeyValue{KT,byte[]} value 
            /// </summary>
            SnapshotAdd = 8,
            /// <summary>
            /// [9] If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// KT key 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value 
            /// 返回值 bool Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在
            /// </summary>
            TryAdd = 9,
            /// <summary>
            /// [10] Get data based on keywords 
///            根据关键字获取数据
            /// KT key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter 
            /// </summary>
            TryGetResponseParameter = 10,
            /// <summary>
            /// [11] Get data based on keywords 
///            根据关键字获取数据
            /// KT key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{byte[]} 
            /// </summary>
            TryGetValue = 11,
            /// <summary>
            /// [12] Get data based on keywords 
///            根据关键字获取数据
            /// KT[] keys 
            /// 返回值 byte[][] 
            /// </summary>
            GetValueArray = 12,
            /// <summary>
            /// [13] Remove keyword 
///            删除关键字
            /// KT[] keys 
            /// 返回值 int The number of deleted keywords 
///            删除关键字数量
            /// </summary>
            RemoveKeys = 13,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Queue node Interface (First In, First Out) 
///            队列节点接口（先进先出）
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IByteArrayQueueNodeMethodEnum))]
        public partial interface IByteArrayQueueNode { }
        /// <summary>
        /// Queue node Interface (First In, First Out) 
///            队列节点接口（先进先出） (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IByteArrayQueueNodeMethodEnum
        {
            /// <summary>
            /// [0] Clear all data 
///            清除所有数据
            /// </summary>
            Clear = 0,
            /// <summary>
            /// [1] Get the number of queue data 
///            获取队列数据数量
            /// 返回值 int 
            /// </summary>
            Count = 1,
            /// <summary>
            /// [2] Add the data to the queue 
///            将数据添加到队列
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value 
            /// </summary>
            Enqueue = 2,
            /// <summary>
            /// [3] Add snapshot data 
///            添加快照数据
            /// byte[] value 
            /// </summary>
            SnapshotAdd = 3,
            /// <summary>
            /// [4] Pop a piece of data from the queue 
///            从队列中弹出一个数据
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{byte[]} If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据
            /// </summary>
            TryDequeue = 4,
            /// <summary>
            /// [5] Pop a piece of data from the queue 
///            从队列中弹出一个数据
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据
            /// </summary>
            TryDequeueResponseParameter = 5,
            /// <summary>
            /// [6] Get the next pop-up data in the queue (no pop-up data, only view) 
///            获取队列中下一个弹出数据（不弹出数据仅查看）
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{byte[]} If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据
            /// </summary>
            TryPeek = 6,
            /// <summary>
            /// [7] Get the next pop-up data in the queue (no pop-up data, only view) 
///            获取队列中下一个弹出数据（不弹出数据仅查看）
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据
            /// </summary>
            TryPeekResponseParameter = 7,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Stack node interface (Last in, first out) 
///            栈节点接口（后进先出）
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IByteArrayStackNodeMethodEnum))]
        public partial interface IByteArrayStackNode { }
        /// <summary>
        /// Stack node interface (Last in, first out) 
///            栈节点接口（后进先出） (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IByteArrayStackNodeMethodEnum
        {
            /// <summary>
            /// [0] Clear all data 
///            清除所有数据
            /// </summary>
            Clear = 0,
            /// <summary>
            /// [1] Get the quantity of data 
///            获取数据数量
            /// 返回值 int 
            /// </summary>
            Count = 1,
            /// <summary>
            /// [2] Add the data to the stack 
///            将数据添加到栈
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value 
            /// </summary>
            Push = 2,
            /// <summary>
            /// [3] Add snapshot data 
///            添加快照数据
            /// byte[] value 
            /// </summary>
            SnapshotAdd = 3,
            /// <summary>
            /// [4] Get the next popped data in the stack (no popped data, only view) 
///            获取栈中下一个弹出数据（不弹出数据仅查看）
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{byte[]} If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据
            /// </summary>
            TryPeek = 4,
            /// <summary>
            /// [5] Get the next popped data in the stack (no popped data, only view) 
///            获取栈中下一个弹出数据（不弹出数据仅查看）
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据
            /// </summary>
            TryPeekResponseParameter = 5,
            /// <summary>
            /// [6] Pop a piece of data from the stack 
///            从栈中弹出一个数据
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{byte[]} If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据
            /// </summary>
            TryPop = 6,
            /// <summary>
            /// [7] Pop a piece of data from the stack 
///            从栈中弹出一个数据
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据
            /// </summary>
            TryPopResponseParameter = 7,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Dictionary node interface 
///            字典节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IDictionaryNodeMethodEnum))]
        public partial interface IDictionaryNode<KT,VT> { }
        /// <summary>
        /// Dictionary node interface 
///            字典节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IDictionaryNodeMethodEnum
        {
            /// <summary>
            /// [0] 
            /// </summary>
            Clear = 0,
            /// <summary>
            /// [1] 
            /// KT key 
            /// 返回值 bool 
            /// </summary>
            ContainsKey = 1,
            /// <summary>
            /// [2] 
            /// </summary>
            ReusableClear = 2,
            /// <summary>
            /// [3] 
            /// 返回值 int 
            /// </summary>
            Count = 3,
            /// <summary>
            /// [4] 
            /// KT key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{VT} 
            /// </summary>
            GetRemove = 4,
            /// <summary>
            /// [5] 
            /// KT key 
            /// 返回值 bool 
            /// </summary>
            Remove = 5,
            /// <summary>
            /// [6] 
            /// int capacity 
            /// </summary>
            Renew = 6,
            /// <summary>
            /// [7] 
            /// KT key 
            /// VT value 
            /// 返回值 bool 
            /// </summary>
            Set = 7,
            /// <summary>
            /// [8] 
            /// AutoCSer.KeyValue{KT,VT} value 
            /// </summary>
            SnapshotAdd = 8,
            /// <summary>
            /// [9] 
            /// KT key 
            /// VT value 
            /// 返回值 bool 
            /// </summary>
            TryAdd = 9,
            /// <summary>
            /// [10] 
            /// KT key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{VT} 
            /// </summary>
            TryGetValue = 10,
            /// <summary>
            /// [11] 
            /// KT[] keys 
            /// 返回值 VT[] 
            /// </summary>
            GetValueArray = 11,
            /// <summary>
            /// [12] 
            /// KT[] keys 
            /// 返回值 int 
            /// </summary>
            RemoveKeys = 12,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Distributed lock node interface 
///            分布式锁节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IDistributedLockNodeMethodEnum))]
        public partial interface IDistributedLockNode<T> { }
        /// <summary>
        /// Distributed lock node interface 
///            分布式锁节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IDistributedLockNodeMethodEnum
        {
            /// <summary>
            /// [0] Apply for a lock 
///            申请锁
            /// T key Keyword of lock 
///            锁关键字
            /// ushort timeoutSeconds Timeout seconds 
///            超时秒数
            /// </summary>
            Enter = 0,
            /// <summary>
            /// [1] Release the lock 
///            释放锁
            /// T key Keyword of lock 
///            锁关键字
            /// long identity Lock request identity 
///            锁请求标识
            /// </summary>
            Release = 1,
            /// <summary>
            /// [2] Load snapshot data (recover memory data from snapshot data) 
///            加载快照数据（从快照数据恢复内存数据）
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.DistributedLockIdentity{T} value data
            /// </summary>
            SnapshotSet = 2,
            /// <summary>
            /// [3] Try to apply for a lock 
///            尝试申请锁
            /// T key Keyword of lock 
///            锁关键字
            /// ushort timeoutSeconds Timeout seconds 
///            超时秒数
            /// 返回值 long Lock request identity. Return 0 if failed 
///            锁请求标识，失败返回 0
            /// </summary>
            TryEnter = 3,
            /// <summary>
            /// [4] Load snapshot data (recover memory data from snapshot data) 
///            加载快照数据（从快照数据恢复内存数据）
            /// long value data
            /// </summary>
            SnapshotSetIdentity = 4,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// 256 base fragment dictionary node interface 
///            256 基分片字典 节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IFragmentDictionaryNodeMethodEnum))]
        public partial interface IFragmentDictionaryNode<KT,VT> { }
        /// <summary>
        /// 256 base fragment dictionary node interface 
///            256 基分片字典 节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IFragmentDictionaryNodeMethodEnum
        {
            /// <summary>
            /// [0] Clear the data (retain the fragmented array) 
///            清除数据（保留分片数组）
            /// </summary>
            Clear = 0,
            /// <summary>
            /// [1] Clear fragmented array (used to solve the problem of low performance of clear call when the amount of data is large) 
///            清除分片数组（用于解决数据量较大的情况下 Clear 调用性能低下的问题）
            /// </summary>
            ClearArray = 1,
            /// <summary>
            /// [2] Determine whether the keyword exists 
///            判断关键字是否存在
            /// KT key 
            /// 返回值 bool 
            /// </summary>
            ContainsKey = 2,
            /// <summary>
            /// [3] Get the quantity of data 
///            获取数据数量
            /// 返回值 int 
            /// </summary>
            Count = 3,
            /// <summary>
            /// [4] Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// KT key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{VT} 
            /// </summary>
            GetRemove = 4,
            /// <summary>
            /// [5] Remove keyword 
///            删除关键字
            /// KT key 
            /// 返回值 bool Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在
            /// </summary>
            Remove = 5,
            /// <summary>
            /// [6] Force the data to be set and overwrite if the keyword already exists 
///            强制设置数据，如果关键字已存在则覆盖
            /// KT key 
            /// VT value 
            /// 返回值 bool Return false on failure
            /// </summary>
            Set = 6,
            /// <summary>
            /// [7] Add snapshot data 
///            添加快照数据
            /// AutoCSer.KeyValue{KT,VT} value 
            /// </summary>
            SnapshotAdd = 7,
            /// <summary>
            /// [8] If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// KT key 
            /// VT value 
            /// 返回值 bool Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在
            /// </summary>
            TryAdd = 8,
            /// <summary>
            /// [9] Get data based on keywords 
///            根据关键字获取数据
            /// KT key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{VT} 
            /// </summary>
            TryGetValue = 9,
            /// <summary>
            /// [10] Get data based on keywords 
///            根据关键字获取数据
            /// KT[] keys 
            /// 返回值 VT[] 
            /// </summary>
            GetValueArray = 10,
            /// <summary>
            /// [11] Remove keyword 
///            删除关键字
            /// KT[] keys 
            /// 返回值 int The number of deleted keywords 
///            删除关键字数量
            /// </summary>
            RemoveKeys = 11,
            /// <summary>
            /// [12] Reusable dictionaries reset data locations (The presence of reference type data can cause memory leaks) 
///            可重用字典重置数据位置（存在引用类型数据会造成内存泄露）
            /// </summary>
            ReusableClear = 12,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// 256 base fragment hash table node interface 
///            256 基分片 哈希表 节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IFragmentHashSetNodeMethodEnum))]
        public partial interface IFragmentHashSetNode<T> { }
        /// <summary>
        /// 256 base fragment hash table node interface 
///            256 基分片 哈希表 节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IFragmentHashSetNodeMethodEnum
        {
            /// <summary>
            /// [0] If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// T value 
            /// 返回值 bool Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在
            /// </summary>
            Add = 0,
            /// <summary>
            /// [1] Clear the data (retain the fragmented array) 
///            清除数据（保留分片数组）
            /// </summary>
            Clear = 1,
            /// <summary>
            /// [2] Clear fragmented array (used to solve the problem of low performance of clear call when the amount of data is large) 
///            清除分片数组（用于解决数据量较大的情况下 Clear 调用性能低下的问题）
            /// </summary>
            ClearArray = 2,
            /// <summary>
            /// [3] Determine whether the keyword exists 
///            判断关键字是否存在
            /// T value 
            /// 返回值 bool 
            /// </summary>
            Contains = 3,
            /// <summary>
            /// [4] Get the quantity of data 
///            获取数据数量
            /// 返回值 int 
            /// </summary>
            Count = 4,
            /// <summary>
            /// [5] Remove keyword 
///            删除关键字
            /// T value 
            /// 返回值 bool Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在
            /// </summary>
            Remove = 5,
            /// <summary>
            /// [6] If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// T[] values 
            /// 返回值 int The quantity of the added data 
///            添加数据数量
            /// </summary>
            AddValues = 6,
            /// <summary>
            /// [7] Remove keyword 
///            删除关键字
            /// T[] values 
            /// 返回值 int The quantity of deleted data 
///            删除数据数量
            /// </summary>
            RemoveValues = 7,
            /// <summary>
            /// [8] Reusable hash tables reset data locations (The presence of reference type data can cause memory leaks) 
///            可重用哈希表重置数据位置（存在引用类型数据会造成内存泄露）
            /// </summary>
            ReusableClear = 8,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Dictionary node interface 
///            字典节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IHashBytesDictionaryNodeMethodEnum))]
        public partial interface IHashBytesDictionaryNode { }
        /// <summary>
        /// Dictionary node interface 
///            字典节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IHashBytesDictionaryNodeMethodEnum
        {
            /// <summary>
            /// [0] Clear all data 
///            清除所有数据
            /// </summary>
            Clear = 0,
            /// <summary>
            /// [1] Determine whether the keyword exists 
///            判断关键字是否存在
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key 
            /// 返回值 bool 
            /// </summary>
            ContainsKey = 1,
            /// <summary>
            /// [2] Get the quantity of data 
///            获取数据数量
            /// 返回值 int 
            /// </summary>
            Count = 2,
            /// <summary>
            /// [3] Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{byte[]} Deleted data and no returned data indicate that the keyword does not exist 
///            被删除数据，无返回数据表示关键字不存在
            /// </summary>
            GetRemove = 3,
            /// <summary>
            /// [4] Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter Deleted data and no returned data indicate that the keyword does not exist 
///            被删除数据，无返回数据表示关键字不存在
            /// </summary>
            GetRemoveResponseParameter = 4,
            /// <summary>
            /// [5] Remove keyword 
///            删除关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key 
            /// 返回值 bool Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在
            /// </summary>
            Remove = 5,
            /// <summary>
            /// [6] Clear all data and rebuild the container (to solve the problem of low performance of the clear call when the data volume is large) 
///            清除所有数据并重建容器（用于解决数据量较大的情况下 Clear 调用性能低下的问题）
            /// int capacity Initialize the size of the new container 
///            新容器初始化大小
            /// </summary>
            Renew = 6,
            /// <summary>
            /// [7] Force the data to be set and overwrite if the keyword already exists 
///            强制设置数据，如果关键字已存在则覆盖
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value 
            /// 返回值 bool Return false on failure
            /// </summary>
            Set = 7,
            /// <summary>
            /// [8] Add snapshot data 
///            添加快照数据
            /// AutoCSer.BinarySerializeKeyValue{byte[],byte[]} value 
            /// </summary>
            SnapshotAdd = 8,
            /// <summary>
            /// [9] Try to add data 
///            尝试添加数据
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value 
            /// 返回值 bool Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在
            /// </summary>
            TryAdd = 9,
            /// <summary>
            /// [10] Get data based on keywords 
///            根据关键字获取数据
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter 
            /// </summary>
            TryGetResponseParameter = 10,
            /// <summary>
            /// [11] Get data based on keywords 
///            根据关键字获取数据
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{byte[]} 
            /// </summary>
            TryGetValue = 11,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// 256 base fragment hash byte array dictionary node interface 
///            256 基分片哈希字节数组字典 节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IHashBytesFragmentDictionaryNodeMethodEnum))]
        public partial interface IHashBytesFragmentDictionaryNode { }
        /// <summary>
        /// 256 base fragment hash byte array dictionary node interface 
///            256 基分片哈希字节数组字典 节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IHashBytesFragmentDictionaryNodeMethodEnum
        {
            /// <summary>
            /// [0] Clear the data (retain the fragmented array) 
///            清除数据（保留分片数组）
            /// </summary>
            Clear = 0,
            /// <summary>
            /// [1] Clear fragmented array (used to solve the problem of low performance of clear call when the amount of data is large) 
///            清除分片数组（用于解决数据量较大的情况下 Clear 调用性能低下的问题）
            /// </summary>
            ClearArray = 1,
            /// <summary>
            /// [2] Determine whether the keyword exists 
///            判断关键字是否存在
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key 
            /// 返回值 bool 
            /// </summary>
            ContainsKey = 2,
            /// <summary>
            /// [3] Get the quantity of data 
///            获取数据数量
            /// 返回值 int 
            /// </summary>
            Count = 3,
            /// <summary>
            /// [4] Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{byte[]} Deleted data and no returned data indicate that the keyword does not exist 
///            被删除数据，无返回数据表示关键字不存在
            /// </summary>
            GetRemove = 4,
            /// <summary>
            /// [5] Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter Deleted data and no returned data indicate that the keyword does not exist 
///            被删除数据，无返回数据表示关键字不存在
            /// </summary>
            GetRemoveResponseParameter = 5,
            /// <summary>
            /// [6] Remove keyword 
///            删除关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key 
            /// 返回值 bool Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在
            /// </summary>
            Remove = 6,
            /// <summary>
            /// [7] Force the data to be set and overwrite if the keyword already exists 
///            强制设置数据，如果关键字已存在则覆盖
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value 
            /// 返回值 bool Return false on failure
            /// </summary>
            Set = 7,
            /// <summary>
            /// [8] Add snapshot data 
///            添加快照数据
            /// AutoCSer.BinarySerializeKeyValue{byte[],byte[]} value 
            /// </summary>
            SnapshotAdd = 8,
            /// <summary>
            /// [9] If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key 
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray value 
            /// 返回值 bool Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在
            /// </summary>
            TryAdd = 9,
            /// <summary>
            /// [10] Get data based on keywords 
///            根据关键字获取数据
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ResponseParameter 
            /// </summary>
            TryGetResponseParameter = 10,
            /// <summary>
            /// [11] Get data based on keywords 
///            根据关键字获取数据
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerByteArray key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{byte[]} 
            /// </summary>
            TryGetValue = 11,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Hash table node interface 
///            哈希表节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IHashSetNodeMethodEnum))]
        public partial interface IHashSetNode<T> { }
        /// <summary>
        /// Hash table node interface 
///            哈希表节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IHashSetNodeMethodEnum
        {
            /// <summary>
            /// [0] Add data
            /// T value 
            /// 返回值 bool Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在
            /// </summary>
            Add = 0,
            /// <summary>
            /// [1] Clear all data 
///            清除所有数据
            /// </summary>
            Clear = 1,
            /// <summary>
            /// [2] Determine whether the keyword exists 
///            判断关键字是否存在
            /// T value 
            /// 返回值 bool 
            /// </summary>
            Contains = 2,
            /// <summary>
            /// [3] Get the quantity of data 
///            获取数据数量
            /// 返回值 int 
            /// </summary>
            Count = 3,
            /// <summary>
            /// [4] Remove keyword 
///            删除关键字
            /// T value 
            /// 返回值 bool Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在
            /// </summary>
            Remove = 4,
            /// <summary>
            /// [5] Clear all data and rebuild the container (to solve the problem of low performance of the clear call when the data volume is large) 
///            清除所有数据并重建容器（用于解决数据量较大的情况下 Clear 调用性能低下的问题）
            /// int capacity Container initialization size 
///            容器初始化大小
            /// </summary>
            Renew = 5,
            /// <summary>
            /// [6] Reusable dictionaries reset data locations (The presence of reference type data can cause memory leaks) 
///            可重用字典重置数据位置（存在引用类型数据会造成内存泄露）
            /// </summary>
            ReusableClear = 6,
            /// <summary>
            /// [7] If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// T[] values 
            /// 返回值 int The quantity of the added data 
///            添加数据数量
            /// </summary>
            AddValues = 7,
            /// <summary>
            /// [8] Remove keyword 
///            删除关键字
            /// T[] values 
            /// 返回值 int The quantity of deleted data 
///            删除数据数量
            /// </summary>
            RemoveValues = 8,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// 64-bit auto-increment identity node interface 
///            64 位自增ID 节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IIdentityGeneratorNodeMethodEnum))]
        public partial interface IIdentityGeneratorNode { }
        /// <summary>
        /// 64-bit auto-increment identity node interface 
///            64 位自增ID 节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IIdentityGeneratorNodeMethodEnum
        {
            /// <summary>
            /// [0] Get the next increment identity 
///            获取下一个自增ID
            /// 返回值 long The next increment identity returns a negative number on failure 
///            下一个自增ID，失败返回负数
            /// </summary>
            Next = 0,
            /// <summary>
            /// [1] Gets the auto-increment identity segment 
///            获取自增 ID 分段
            /// int count Get the quantity of data 
///            获取数据数量
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.IdentityFragment Auto-increment identity segment 
///            自增 ID 分段
            /// </summary>
            NextFragment = 1,
            /// <summary>
            /// [2] Add snapshot data 
///            添加快照数据
            /// long identity 
            /// </summary>
            SnapshotSet = 2,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Array node interface 
///            数组节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(ILeftArrayNodeMethodEnum))]
        public partial interface ILeftArrayNode<T> { }
        /// <summary>
        /// Array node interface 
///            数组节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum ILeftArrayNodeMethodEnum
        {
            /// <summary>
            /// [0] Add data
            /// T value data
            /// </summary>
            Add = 0,
            /// <summary>
            /// [1] Clear the data at the specified location 
///            清除指定位置数据
            /// int startIndex Starting position 
///            起始位置
            /// int count Clear data quantity 
///            清除数据数量
            /// 返回值 bool Return false if it exceeds the index range 
///            超出索引范围则返回 false
            /// </summary>
            Clear = 1,
            /// <summary>
            /// [2] Clear all the data and set the valid length of the data to 0 
///            清除所有数据并将数据有效长度设置为 0
            /// </summary>
            ClearLength = 2,
            /// <summary>
            /// [3] Fill the array with data to specify the position 
///            用数据填充数组指定位置
            /// T value 
            /// int startIndex Starting position 
///            起始位置
            /// int count The number of filled data 
///            填充数据数量
            /// 返回值 bool Return false if it exceeds the index range 
///            超出索引范围则返回 false
            /// </summary>
            Fill = 3,
            /// <summary>
            /// [4] Fill the entire array with data 
///            用数据填充整个数组
            /// T value 
            /// </summary>
            FillArray = 4,
            /// <summary>
            /// [5] Get the size of the array container 
///            获取数组容器大小
            /// 返回值 int 
            /// </summary>
            GetCapacity = 5,
            /// <summary>
            /// [6] Get the number of containers free 
///            获取容器空闲数量
            /// 返回值 int 
            /// </summary>
            GetFreeCount = 6,
            /// <summary>
            /// [7] Get the valid length of the array 
///            获取数组有效长度
            /// 返回值 int 
            /// </summary>
            GetLength = 7,
            /// <summary>
            /// [8] Remove the last data and return it 
///            移除最后一个数据并返回该数据
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{T} No data will be returned if there is no removable data 
///            没有可移除数据则无数据返回
            /// </summary>
            GetTryPopValue = 8,
            /// <summary>
            /// [9] Get data based on index location 
///            根据索引位置获取数据
            /// int index Index position 
///            索引位置
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{T} If the return exceeds the index, there will be no return value 
///            超出索引返回则无返回值
            /// </summary>
            GetValue = 9,
            /// <summary>
            /// [10] Remove the data at the specified index position and return the removed data 
///            移除指定索引位置数据并返回被移除的数据
            /// int index Data location 
///            数据位置
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{T} No data will be returned if the index range is exceeded 
///            超出索引范围则无数据返回
            /// </summary>
            GetValueRemoveAt = 10,
            /// <summary>
            /// [11] Remove the data at the specified index position, move the last data to the specified position, and return the removed data 
///            移除指定索引位置数据，将最后一个数据移动到该指定位置，并返回被移除的数据
            /// int index 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{T} No data will be returned if the index range is exceeded 
///            超出索引范围则无数据返回
            /// </summary>
            GetValueRemoveToEnd = 11,
            /// <summary>
            /// [12] Set the data according to the index position and return the data before the setting 
///            根据索引位置设置数据并返回设置之前的数据
            /// int index Index position 
///            索引位置
            /// T value data
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{T} Set the previous data. If it exceeds the index and returns, there will be no return value 
///            设置之前的数据，超出索引返回则无返回值
            /// </summary>
            GetValueSet = 12,
            /// <summary>
            /// [13] Find the position of the first matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找第一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// T value 
            /// int startIndex Starting position 
///            起始位置
            /// int count Search for the number of matching data 
///            查找匹配数据数量
            /// 返回值 int Failure returns a negative number 
///            失败返回负数
            /// </summary>
            IndexOf = 13,
            /// <summary>
            /// [14] Find the position of the first matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找第一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// T value 
            /// 返回值 int Failure returns a negative number 
///            失败返回负数
            /// </summary>
            IndexOfArray = 14,
            /// <summary>
            /// [15] Insert data 
///            插入数据
            /// int index Insert position 
///            插入位置
            /// T value data
            /// 返回值 bool Return false if it exceeds the index range 
///            超出索引范围则返回 false
            /// </summary>
            Insert = 15,
            /// <summary>
            /// [16] Find the position of the last matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找最后一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// T value 
            /// int startIndex The last matching position (the starting position) 
///            最后一个匹配位置（起始位置）
            /// int count Search for the number of matching data 
///            查找匹配数据数量
            /// 返回值 int Failure returns a negative number 
///            失败返回负数
            /// </summary>
            LastIndexOf = 16,
            /// <summary>
            /// [17] Find the position of the last matching data from the array. (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            从数组中查找最后一个匹配数据的位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// T value 
            /// 返回值 int Failure returns a negative number 
///            失败返回负数
            /// </summary>
            LastIndexOfArray = 17,
            /// <summary>
            /// [18] Remove the first matching data (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            移除第一个匹配数据（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// T value data
            /// 返回值 bool Returning false indicates that there is no data match 
///            返回 false 表示不存在数据匹配
            /// </summary>
            Remove = 18,
            /// <summary>
            /// [19] Remove the data at the specified index position 
///            移除指定索引位置数据
            /// int index Data location 
///            数据位置
            /// 返回值 bool Return false if it exceeds the index range 
///            超出索引范围则返回 false
            /// </summary>
            RemoveAt = 19,
            /// <summary>
            /// [20] Remove the data at the specified index position and move the last data to that specified position 
///            移除指定索引位置数据并将最后一个数据移动到该指定位置
            /// int index 
            /// 返回值 bool Return false if it exceeds the index range 
///            超出索引范围则返回 false
            /// </summary>
            RemoveToEnd = 20,
            /// <summary>
            /// [21] Reverse the array data at the specified position 
///            反转指定位置数组数据
            /// int startIndex Starting position 
///            起始位置
            /// int count Reverse the amount of data 
///            反转数据数量
            /// 返回值 bool Return false if it exceeds the index range 
///            超出索引范围则返回 false
            /// </summary>
            Reverse = 21,
            /// <summary>
            /// [22] Reverse the entire array data 
///            反转整个数组数据
            /// </summary>
            ReverseArray = 22,
            /// <summary>
            /// [23] Empty and release the array 
///            置空并释放数组
            /// </summary>
            SetEmpty = 23,
            /// <summary>
            /// [24] Set the data according to the index position 
///            根据索引位置设置数据
            /// int index Index position 
///            索引位置
            /// T value data
            /// 返回值 bool Return false if it exceeds the index range 
///            超出索引范围则返回 false
            /// </summary>
            SetValue = 24,
            /// <summary>
            /// [25] Sort the array data at the specified position 
///            排序指定位置数组数据
            /// int startIndex Starting position 
///            起始位置
            /// int count The quantity of data to be sorted 
///            排序数据数量
            /// 返回值 bool Return false if it exceeds the index range 
///            超出索引范围则返回 false
            /// </summary>
            Sort = 25,
            /// <summary>
            /// [26] Array sorting 
///            数组排序
            /// </summary>
            SortArray = 26,
            /// <summary>
            /// [27] Add data when there is a free place 
///            当有空闲位置时添加数据
            /// T value 
            /// 返回值 bool Returning false indicates that the array is full and the addition failed 
///            返回 false 表示数组已满，添加失败
            /// </summary>
            TryAdd = 27,
            /// <summary>
            /// [28] Try to remove the last data 
///            尝试移除最后一个数据
            /// 返回值 bool Is there any removable data 
///            是否存在可移除数据
            /// </summary>
            TryPop = 28,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Multi-hash bitmap client synchronization filter node Interface (similar to Bloom filter, suitable for small containers) 
///            多哈希位图客户端同步过滤节点接口（类似布隆过滤器，适合小容器）
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IManyHashBitMapClientFilterNodeMethodEnum))]
        public partial interface IManyHashBitMapClientFilterNode { }
        /// <summary>
        /// Multi-hash bitmap client synchronization filter node Interface (similar to Bloom filter, suitable for small containers) 
///            多哈希位图客户端同步过滤节点接口（类似布隆过滤器，适合小容器） (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IManyHashBitMapClientFilterNodeMethodEnum
        {
            /// <summary>
            /// [0] Get the operation of setting a new bit 
///            获取设置新位操作
            /// </summary>
            GetBit = 0,
            /// <summary>
            /// [1] Get the current bitmap data 
///            获取当前位图数据
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ManyHashBitMap 
            /// </summary>
            GetData = 1,
            /// <summary>
            /// [2] Set bit 
///            设置位
            /// int bit The set binary bit 
///            设置的二进制位
            /// </summary>
            SetBit = 2,
            /// <summary>
            /// [3] Set bit (Check the input parameters before the persistence operation) 
///            设置位（持久化操作之前检查输入参数）
            /// int bit The set binary bit 
///            设置的二进制位
            /// 返回值 bool Returning true indicates that a persistence operation is required 
///            返回 true 表示需要持久化操作
            /// </summary>
            SetBitBeforePersistence = 3,
            /// <summary>
            /// [4] Add snapshot data 
///            添加快照数据
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ManyHashBitMap map Multi-hash bitmap data 
///            多哈希位图数据
            /// </summary>
            SnapshotSet = 4,
            /// <summary>
            /// [5] Get the bitmap size (number of bits) 
///            获取位图大小（位数量）
            /// 返回值 int 
            /// </summary>
            GetSize = 5,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Multi-hash bitmap filter node interface (similar to Bloom Filter) 
///            多哈希位图过滤节点接口（类似布隆过滤器）
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IManyHashBitMapFilterNodeMethodEnum))]
        public partial interface IManyHashBitMapFilterNode { }
        /// <summary>
        /// Multi-hash bitmap filter node interface (similar to Bloom Filter) 
///            多哈希位图过滤节点接口（类似布隆过滤器） (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IManyHashBitMapFilterNodeMethodEnum
        {
            /// <summary>
            /// [0] Get the bitmap size (number of bits) 
///            获取位图大小（位数量）
            /// 返回值 int 
            /// </summary>
            GetSize = 0,
            /// <summary>
            /// [1] Set bit 
///            设置位
            /// int size Bitmap size (number of bits) 
///            位图大小（位数量）
            /// uint[] bits Binary bit set 
///            位置集合
            /// 返回值 bool Returning false indicates that the bitmap size does not match 
///            返回 false 表示位图大小不匹配
            /// </summary>
            SetBits = 1,
            /// <summary>
            /// [2] Set bit (Check the input parameters before the persistence operation) 
///            设置位（持久化操作之前检查输入参数）
            /// int size Bitmap size (number of bits) 
///            位图大小（位数量）
            /// uint[] bits Binary bit set 
///            位置集合
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{bool} Returning false indicates that the bitmap size does not match 
///            返回 false 表示位图大小不匹配
            /// </summary>
            SetBitsBeforePersistence = 2,
            /// <summary>
            /// [3] Add snapshot data 
///            添加快照数据
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ManyHashBitMap map Multi-hash bitmap data 
///            多哈希位图数据
            /// </summary>
            SnapshotSet = 3,
            /// <summary>
            /// [4] Binary bit set matching 
///            位置集合匹配
            /// int size Bitmap size (number of bits) 
///            位图大小（位数量）
            /// uint[] bits Binary bit set 
///            位置集合
            /// 返回值 AutoCSer.NullableBoolEnum Returning Null indicates that the bitmap does not match 
///            返回 Null 表示位图不匹配
            /// </summary>
            CheckBits = 4,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Message processing node interface 
///            消息处理节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IMessageNodeMethodEnum))]
        public partial interface IMessageNode<T> { }
        /// <summary>
        /// Message processing node interface 
///            消息处理节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IMessageNodeMethodEnum
        {
            /// <summary>
            /// [0] Producers add new message 
///            生产者添加新消息
            /// T message 
            /// </summary>
            AppendMessage = 0,
            /// <summary>
            /// [1] Clear all messages 
///            清除所有消息
            /// </summary>
            Clear = 1,
            /// <summary>
            /// [2] Clear all failure messages (including handling timeout messages) 
///            清除所有失败消息（包括处理超时消息）
            /// </summary>
            ClearFailed = 2,
            /// <summary>
            /// [3] The message has been processed 
///            消息完成处理
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.MessageIdeneity identity 
            /// </summary>
            Completed = 3,
            /// <summary>
            /// [4] Message failed processing 
///            消息失败处理
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.MessageIdeneity identity 
            /// </summary>
            Failed = 4,
            /// <summary>
            /// [5] Get the number of consumer callbacks 
///            获取消费者回调数量
            /// 返回值 int 
            /// </summary>
            GetCallbackCount = 5,
            /// <summary>
            /// [6] Get the number of uncompleted messages (excluding failed messages) 
///            获取未完成消息数量（不包括失败消息）
            /// 返回值 int 
            /// </summary>
            GetCount = 6,
            /// <summary>
            /// [7] Get the number of failed messages (Including handling timeout messages) 
///            获取失败消息数量（包括处理超时消息）
            /// 返回值 int 
            /// </summary>
            GetFailedCount = 7,
            /// <summary>
            /// [8] The consumer client gets the message 
///            消费客户端获取消息
            /// int maxCount The current maximum number of concurrent messages on the client side 
///            当前客户端最大并发消息数量
            /// </summary>
            GetMessage = 8,
            /// <summary>
            /// [9] Get the number of unfinished timeout messages 
///            获取未完成的超时消息数量
            /// 返回值 int 
            /// </summary>
            GetTimeoutCount = 9,
            /// <summary>
            /// [10] Get the number of uncompleted messages (including failed messages) 
///            获取未完成消息数量（包括失败消息）
            /// 返回值 int 
            /// </summary>
            GetTotalCount = 10,
            /// <summary>
            /// [11] Load snapshot data (recover memory data from snapshot data) 
///            加载快照数据（从快照数据恢复内存数据）
            /// T value data
            /// </summary>
            SnapshotAdd = 11,
            /// <summary>
            /// [12] Producers add new message (Initialize and load the persistent data) 
///            生产者添加新消息（初始化加载持久化数据）
            /// T message 
            /// </summary>
            AppendMessageLoadPersistence = 12,
            /// <summary>
            /// [13] Clear all failure messages (including handling timeout messages) (Initialize and load the persistent data) 
///            清除所有失败消息（包括处理超时消息）（初始化加载持久化数据）
            /// </summary>
            ClearFailedLoadPersistence = 13,
            /// <summary>
            /// [14] Clear all messages (Initialize and load the persistent data) 
///            清除所有消息（初始化加载持久化数据）
            /// </summary>
            ClearLoadPersistence = 14,
            /// <summary>
            /// [15] The message has been processed (Initialize and load the persistent data) 
///            消息完成处理（初始化加载持久化数据）
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.MessageIdeneity identity 
            /// </summary>
            CompletedLoadPersistence = 15,
            /// <summary>
            /// [16] Message failed processing (Initialize and load the persistent data) 
///            消息失败处理（初始化加载持久化数据）
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.MessageIdeneity identity 
            /// </summary>
            FailedLoadPersistence = 16,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Archive-only data node interface (It is used for the rapid archiving of large amounts of concurrent data without modifying memory data or defining snapshot operations) 
///            仅存档数据节点接口（用于大量并发数据快速存档，不修改内存数据，也不定义快照操作）
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IOnlyPersistenceNodeMethodEnum))]
        public partial interface IOnlyPersistenceNode<T> { }
        /// <summary>
        /// Archive-only data node interface (It is used for the rapid archiving of large amounts of concurrent data without modifying memory data or defining snapshot operations) 
///            仅存档数据节点接口（用于大量并发数据快速存档，不修改内存数据，也不定义快照操作） (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IOnlyPersistenceNodeMethodEnum
        {
            /// <summary>
            /// [0] Data archiving 
///            数据存档
            /// T value Data to be archive 
///            待存档数据
            /// </summary>
            Save = 0,
            /// <summary>
            /// [1] Load the archived data for scanning the archived mode (initializing the loading of persistent data) 
///            加载存档数据，用于扫描存档模式（初始化加载持久化数据）
            /// T value Data to be archive 
///            待存档数据
            /// </summary>
            SaveLoadPersistence = 1,
            /// <summary>
            /// [2] Data archiving (The server does not respond) 
///            数据存档（服务端不响应）
            /// T value Data to be archive 
///            待存档数据
            /// </summary>
            SaveSendOnly = 2,
            /// <summary>
            /// [3] Load the archived data for scanning the archived mode (initializing the loading of persistent data) 
///            加载保存数据，用于扫描存档模式（初始化加载持久化数据）
            /// T value Data to be archive 
///            待存档数据
            /// </summary>
            SaveSendOnlyLoadPersistence = 3,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Process daemon node interface (The server needs to run as an administrator; otherwise, an exception may occur) 
///            进程守护节点接口（服务端需要以管理员身份运行，否则可能异常）
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IProcessGuardNodeMethodEnum))]
        public partial interface IProcessGuardNode { }
        /// <summary>
        /// Process daemon node interface (The server needs to run as an administrator; otherwise, an exception may occur) 
///            进程守护节点接口（服务端需要以管理员身份运行，否则可能异常） (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IProcessGuardNodeMethodEnum
        {
            /// <summary>
            /// [0] Add the process to be daemon 
///            添加待守护进程
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ProcessGuardInfo processInfo Process information 
///            进程信息
            /// 返回值 bool Add failed and return false 
///            添加失败返回 false
            /// </summary>
            Guard = 0,
            /// <summary>
            /// [1] Delete the daemon process 
///            删除被守护进程
            /// int processId Process identity 
///            进程标识
            /// System.DateTime startTime Process startup time 
///            进程启动时间
            /// string processName Process name 
///            进程名称
            /// </summary>
            Remove = 1,
            /// <summary>
            /// [2] Load snapshot data (recover memory data from snapshot data) 
///            加载快照数据（从快照数据恢复内存数据）
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ProcessGuardInfo value data
            /// </summary>
            SnapshotSet = 2,
            /// <summary>
            /// [3] Switch processes 
///            切换进程
            /// string key The key words of the switched process 
///            切换进程关键字
            /// </summary>
            Switch = 3,
            /// <summary>
            /// [4] Initialize and add the daemon process to be added (Initialize and load the persistent data) 
///            初始化添加待守护进程（初始化加载持久化数据）
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ProcessGuardInfo processInfo Process information 
///            进程信息
            /// 返回值 bool Add failed and return false 
///            添加失败返回 false
            /// </summary>
            GuardLoadPersistence = 4,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Queue node interface (First In, First Out) 
///            队列节点接口（先进先出）
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IQueueNodeMethodEnum))]
        public partial interface IQueueNode<T> { }
        /// <summary>
        /// Queue node interface (First In, First Out) 
///            队列节点接口（先进先出） (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IQueueNodeMethodEnum
        {
            /// <summary>
            /// [0] Clear all data 
///            清除所有数据
            /// </summary>
            Clear = 0,
            /// <summary>
            /// [1] Determine whether there is matching data in the queue (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            判断队列中是否存在匹配数据（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// T value Data to be matched 
///            待匹配数据
            /// 返回值 bool 
            /// </summary>
            Contains = 1,
            /// <summary>
            /// [2] Get the number of queue data 
///            获取队列数据数量
            /// 返回值 int 
            /// </summary>
            Count = 2,
            /// <summary>
            /// [3] Add the data to the queue 
///            将数据添加到队列
            /// T value 
            /// </summary>
            Enqueue = 3,
            /// <summary>
            /// [4] Pop a piece of data from the queue 
///            从队列中弹出一个数据
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{T} If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据
            /// </summary>
            TryDequeue = 4,
            /// <summary>
            /// [5] Get the next pop-up data in the queue (no pop-up data, only view) 
///            获取队列中下一个弹出数据（不弹出数据仅查看）
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{T} If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据
            /// </summary>
            TryPeek = 5,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Binary search tree node interface 
///            二叉搜索树节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(ISearchTreeDictionaryNodeMethodEnum))]
        public partial interface ISearchTreeDictionaryNode<KT,VT> { }
        /// <summary>
        /// Binary search tree node interface 
///            二叉搜索树节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum ISearchTreeDictionaryNodeMethodEnum
        {
            /// <summary>
            /// [0] 
            /// </summary>
            Clear = 0,
            /// <summary>
            /// [1] 
            /// KT key 
            /// 返回值 bool 
            /// </summary>
            ContainsKey = 1,
            /// <summary>
            /// [2] 
            /// 返回值 int 
            /// </summary>
            Count = 2,
            /// <summary>
            /// [3] 
            /// KT key 
            /// 返回值 int 
            /// </summary>
            CountLess = 3,
            /// <summary>
            /// [4] 
            /// KT key 
            /// 返回值 int 
            /// </summary>
            CountThan = 4,
            /// <summary>
            /// [5] 
            /// 返回值 int 
            /// </summary>
            GetHeight = 5,
            /// <summary>
            /// [6] 
            /// KT key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{VT} 
            /// </summary>
            GetRemove = 6,
            /// <summary>
            /// [7] 
            /// int skipCount 
            /// byte getCount 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{VT} 
            /// </summary>
            GetValues = 7,
            /// <summary>
            /// [8] 
            /// KT key 
            /// 返回值 int 
            /// </summary>
            IndexOf = 8,
            /// <summary>
            /// [9] 
            /// KT key 
            /// 返回值 bool 
            /// </summary>
            Remove = 9,
            /// <summary>
            /// [10] 
            /// KT key 
            /// VT value 
            /// 返回值 bool 
            /// </summary>
            Set = 10,
            /// <summary>
            /// [11] 
            /// AutoCSer.KeyValue{KT,VT} value 
            /// </summary>
            SnapshotAdd = 11,
            /// <summary>
            /// [12] 
            /// KT key 
            /// VT value 
            /// 返回值 bool 
            /// </summary>
            TryAdd = 12,
            /// <summary>
            /// [13] 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{KT} 
            /// </summary>
            TryGetFirstKey = 13,
            /// <summary>
            /// [14] 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{AutoCSer.KeyValue{KT,VT}} 
            /// </summary>
            TryGetFirstKeyValue = 14,
            /// <summary>
            /// [15] 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{VT} 
            /// </summary>
            TryGetFirstValue = 15,
            /// <summary>
            /// [16] 
            /// int index 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{AutoCSer.KeyValue{KT,VT}} 
            /// </summary>
            TryGetKeyValueByIndex = 16,
            /// <summary>
            /// [17] 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{KT} 
            /// </summary>
            TryGetLastKey = 17,
            /// <summary>
            /// [18] 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{AutoCSer.KeyValue{KT,VT}} 
            /// </summary>
            TryGetLastKeyValue = 18,
            /// <summary>
            /// [19] 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{VT} 
            /// </summary>
            TryGetLastValue = 19,
            /// <summary>
            /// [20] 
            /// KT key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{VT} 
            /// </summary>
            TryGetValue = 20,
            /// <summary>
            /// [21] 
            /// int index 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{VT} 
            /// </summary>
            TryGetValueByIndex = 21,
            /// <summary>
            /// [22] 
            /// KT[] keys 
            /// 返回值 VT[] 
            /// </summary>
            GetValueArray = 22,
            /// <summary>
            /// [23] 
            /// KT[] keys 
            /// 返回值 int 
            /// </summary>
            RemoveKeys = 23,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Binary search tree collection node interface 
///            二叉搜索树集合节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(ISearchTreeSetNodeMethodEnum))]
        public partial interface ISearchTreeSetNode<T> { }
        /// <summary>
        /// Binary search tree collection node interface 
///            二叉搜索树集合节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum ISearchTreeSetNodeMethodEnum
        {
            /// <summary>
            /// [0] Add data
            /// T value keyword
            /// 返回值 bool Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在
            /// </summary>
            Add = 0,
            /// <summary>
            /// [1] Clear all data 
///            清除所有数据
            /// </summary>
            Clear = 1,
            /// <summary>
            /// [2] Determine whether the keyword exists 
///            判断关键字是否存在
            /// T value keyword
            /// 返回值 bool 
            /// </summary>
            Contains = 2,
            /// <summary>
            /// [3] Get the quantity of data 
///            获取数据数量
            /// 返回值 int 
            /// </summary>
            Count = 3,
            /// <summary>
            /// [4] Get the number of nodes smaller than the specified keyword 
///            获取比指定关键字小的节点数量
            /// T value keyword
            /// 返回值 int Returning -1 indicates that the data to be matched is null 
///            返回 -1 表示待匹配数据为 null
            /// </summary>
            CountLess = 4,
            /// <summary>
            /// [5] Get the number of nodes larger than the specified keyword 
///            获取比指定关键字大的节点数量
            /// T value keyword
            /// 返回值 int Returning -1 indicates that the data to be matched is null 
///            返回 -1 表示待匹配数据为 null
            /// </summary>
            CountThan = 5,
            /// <summary>
            /// [6] Get data based on the node position 
///            根据节点位置获取数据
            /// int index Node position 
///            节点位置
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{T} data
            /// </summary>
            GetByIndex = 6,
            /// <summary>
            /// [7] Get the first data 
///            获取第一个数据
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{T} No return value is returned when there is no data 
///            没有数据时返回无返回值
            /// </summary>
            GetFrist = 7,
            /// <summary>
            /// [8] Get the last data 
///            获取最后一个数据
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{T} No return value is returned when there is no data 
///            没有数据时返回无返回值
            /// </summary>
            GetLast = 8,
            /// <summary>
            /// [9] Get the matching node location based on the keyword 
///            根据关键字获取匹配节点位置
            /// T value keyword
            /// 返回值 int Returning -1 indicates a failed match 
///            返回 -1 表示失败匹配
            /// </summary>
            IndexOf = 9,
            /// <summary>
            /// [10] Remove keyword 
///            删除关键字
            /// T value keyword
            /// 返回值 bool Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在
            /// </summary>
            Remove = 10,
            /// <summary>
            /// [11] If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// T[] values 
            /// 返回值 int The quantity of the added data 
///            添加数据数量
            /// </summary>
            AddValues = 11,
            /// <summary>
            /// [12] Remove keyword 
///            删除关键字
            /// T[] values 
            /// 返回值 int The quantity of deleted data 
///            删除数据数量
            /// </summary>
            RemoveValues = 12,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Server registration node interface 
///            服务注册节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IServerRegistryNodeMethodEnum))]
        public partial interface IServerRegistryNode { }
        /// <summary>
        /// Server registration node interface 
///            服务注册节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IServerRegistryNodeMethodEnum
        {
            /// <summary>
            /// [0] Add the server registration log 
///            添加服务注册日志
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerRegistryLog log 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerRegistryStateEnum Server registration status 
///            服务注册状态
            /// </summary>
            Append = 0,
            /// <summary>
            /// [1] Get the server session identity 
///            获取服务会话标识
            /// 返回值 long 
            /// </summary>
            GetSessionID = 1,
            /// <summary>
            /// [2] Gets the server registration log 
///            获取服务注册日志
            /// string serverName Monitor the server name. An empty string represents all servers 
///            监视服务名称，空字符串表示所有服务
            /// </summary>
            LogCallback = 2,
            /// <summary>
            /// [3] The server registration callback delegate is mainly used to register components to check the online state of the server 
///            服务注册回调委托，主要用于注册组件检查服务的在线状态
            /// long sessionID Server session identity 
///            服务会话标识
            /// </summary>
            ServerCallback = 3,
            /// <summary>
            /// [4] Load snapshot data (recover memory data from snapshot data) 
///            加载快照数据（从快照数据恢复内存数据）
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerRegistryLog value data
            /// </summary>
            SnapshotSet = 4,
            /// <summary>
            /// [5] Get the main log of the server 
///            获取服务主日志
            /// string serverName Server name 
///            服务名称
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerRegistryLog Returning null indicates that the server main log was not found 
///            返回 null 表示没有找到服务主日志
            /// </summary>
            GetLog = 5,
            /// <summary>
            /// [6] Check the online status of the server 
///            检查服务在线状态
            /// long sessionID Server session identity 
///            服务会话标识
            /// string serverName Server name 
///            服务名称
            /// </summary>
            Check = 6,
            /// <summary>
            /// [7] Persistent operations for server disconnection 
///            服务失联的持久化操作
            /// long sessionID Server session identity 
///            服务会话标识
            /// string serverName Server name 
///            服务名称
            /// </summary>
            LostContact = 7,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Service basic operation interface 
///            服务基础操作接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IServiceNodeMethodEnum))]
        public partial interface IServiceNode { }
        /// <summary>
        /// Service basic operation interface 
///            服务基础操作接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IServiceNodeMethodEnum
        {
            /// <summary>
            /// [0] Create a array node IArrayNode{T} 
///            创建数组节点 IArrayNode{T}
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// AutoCSer.Reflection.RemoteType keyType Keyword type 
///            关键字类型
            /// int length Array length
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateArrayNode = 0,
            /// <summary>
            /// [1] Create a bitmap node IBitmapNode 
///            创建位图节点 IBitmapNode
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// uint capacity The number of binary bits 
///            二进制位数量
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateBitmapNode = 1,
            /// <summary>
            /// [2] Create a dictionary node IByteArrayDictionaryNode{KT} 
///            创建字典节点 IByteArrayDictionaryNode{KT}
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// AutoCSer.Reflection.RemoteType keyType Keyword type 
///            关键字类型
            /// int capacity Container initialization size 
///            容器初始化大小
            /// AutoCSer.ReusableDictionaryGroupTypeEnum groupType Reusable dictionary recombination operation type 
///            可重用字典重组操作类型
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateByteArrayDictionaryNode = 2,
            /// <summary>
            /// [3] Create a dictionary node IByteArrayFragmentDictionaryNode{KT} 
///            创建字典节点 IByteArrayFragmentDictionaryNode{KT}
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// AutoCSer.Reflection.RemoteType keyType Keyword type 
///            关键字类型
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateByteArrayFragmentDictionaryNode = 3,
            /// <summary>
            /// [4] Create a queue node IByteArrayQueueNode (First in, first Out) 
///            创建队列节点（先进先出） IByteArrayQueueNode
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// int capacity Container initialization size 
///            容器初始化大小
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateByteArrayQueueNode = 4,
            /// <summary>
            /// [5] Create a stack node IByteArrayStackNode (Last in, first out) 
///            创建栈节点（后进先出） IByteArrayStackNode
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// int capacity Container initialization size 
///            容器初始化大小
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateByteArrayStackNode = 5,
            /// <summary>
            /// [6] Create a dictionary node IDictionaryNode{KT,VT} 
///            创建字典节点 IDictionaryNode{KT,VT}
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// AutoCSer.Reflection.RemoteType keyType Keyword type 
///            关键字类型
            /// AutoCSer.Reflection.RemoteType valueType Data type
            /// int capacity Container initialization size 
///            容器初始化大小
            /// AutoCSer.ReusableDictionaryGroupTypeEnum groupType Reusable dictionary recombination operation type 
///            可重用字典重组操作类型
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateDictionaryNode = 6,
            /// <summary>
            /// [7] Create distributed lock nodes IDistributedLockNode{KT} 
///            创建分布式锁节点 IDistributedLockNode{KT}
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// AutoCSer.Reflection.RemoteType keyType Keyword type 
///            关键字类型
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateDistributedLockNode = 7,
            /// <summary>
            /// [8] Create a dictionary node IFragmentDictionaryNode{KT,VT} 
///            创建字典节点 IFragmentDictionaryNode{KT,VT}
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// AutoCSer.Reflection.RemoteType keyType Keyword type 
///            关键字类型
            /// AutoCSer.Reflection.RemoteType valueType Data type
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateFragmentDictionaryNode = 8,
            /// <summary>
            /// [9] Create a 256 base fragment hash table node IFragmentHashSetNode{KT} 
///            创建 256 基分片哈希表节点 IFragmentHashSetNode{KT}
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// AutoCSer.Reflection.RemoteType keyType Keyword type 
///            关键字类型
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateFragmentHashSetNode = 9,
            /// <summary>
            /// [10] Create a dictionary node IHashBytesDictionaryNode 
///            创建字典节点 IHashBytesDictionaryNode
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// int capacity Container initialization size 
///            容器初始化大小
            /// AutoCSer.ReusableDictionaryGroupTypeEnum groupType Reusable dictionary recombination operation type 
///            可重用字典重组操作类型
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateHashBytesDictionaryNode = 10,
            /// <summary>
            /// [11] Create a dictionary node IHashBytesFragmentDictionaryNode 
///            创建字典节点 IHashBytesFragmentDictionaryNode
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateHashBytesFragmentDictionaryNode = 11,
            /// <summary>
            /// [12] Create a hash table node IHashSetNode{KT} 
///            创建哈希表节点 IHashSetNode{KT}
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// AutoCSer.Reflection.RemoteType keyType Keyword type 
///            关键字类型
            /// int capacity Container initialization size 
///            容器初始化大小
            /// AutoCSer.ReusableDictionaryGroupTypeEnum groupType Reusable dictionary recombination operation type 
///            可重用字典重组操作类型
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateHashSetNode = 12,
            /// <summary>
            /// [13] Create a 64-bit auto-increment identity node IIdentityGeneratorNode 
///            创建 64 位自增ID 节点 IIdentityGeneratorNode
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// long identity Initial Allocation identity 
///            起始分配 ID
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateIdentityGeneratorNode = 13,
            /// <summary>
            /// [14] Create a array node ILeftArrayNode{T} 
///            创建数组节点 ILeftArrayNode{T}
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// AutoCSer.Reflection.RemoteType keyType Keyword type 
///            关键字类型
            /// int capacity Container initialization size 
///            容器初始化大小
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateLeftArrayNode = 14,
            /// <summary>
            /// [15] Create a message processing node IMessageNode{T} 
///            创建消息处理节点 IMessageNode{T}
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// AutoCSer.Reflection.RemoteType messageType Message data type 
///            消息数据类型
            /// int arraySize The size of the message array being processed 
///            正在处理的消息数组大小
            /// int timeoutSeconds The number of seconds of message processing timeout 
///            消息处理超时秒数
            /// int checkTimeoutSeconds Check the interval in seconds for message timeouts 
///            消息超时检查间隔秒数
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateMessageNode = 15,
            /// <summary>
            /// [16] Create a queue node IQueueNode{T} (First in, first Out) 
///            创建队列节点（先进先出） IQueueNode{T}
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// AutoCSer.Reflection.RemoteType keyType Keyword type 
///            关键字类型
            /// int capacity Container initialization size 
///            容器初始化大小
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateQueueNode = 16,
            /// <summary>
            /// [17] Create a binary search tree node ISearchTreeDictionaryNode{KT,VT} 
///            创建二叉搜索树节点 ISearchTreeDictionaryNode{KT,VT}
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// AutoCSer.Reflection.RemoteType keyType Keyword type 
///            关键字类型
            /// AutoCSer.Reflection.RemoteType valueType Data type
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateSearchTreeDictionaryNode = 17,
            /// <summary>
            /// [18] Create a binary search tree collection node ISearchTreeSetNode{KT} 
///            创建二叉搜索树集合节点 ISearchTreeSetNode{KT}
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// AutoCSer.Reflection.RemoteType keyType Keyword type 
///            关键字类型
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateSearchTreeSetNode = 18,
            /// <summary>
            /// [19] Create a message processing node IMessageNode{ServerByteArrayMessage} 
///            创建消息处理节点 IMessageNode{ServerByteArrayMessage}
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// int arraySize The size of the message array being processed 
///            正在处理的消息数组大小
            /// int timeoutSeconds The number of seconds of message processing timeout 
///            消息处理超时秒数
            /// int checkTimeoutSeconds Check the interval in seconds for message timeouts 
///            消息超时检查间隔秒数
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateServerByteArrayMessageNode = 19,
            /// <summary>
            /// [20] Create a sorting dictionary node ISortedDictionaryNode{KT,VT} 
///            创建排序字典节点 ISortedDictionaryNode{KT,VT}
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// AutoCSer.Reflection.RemoteType keyType Keyword type 
///            关键字类型
            /// AutoCSer.Reflection.RemoteType valueType Data type
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateSortedDictionaryNode = 20,
            /// <summary>
            /// [21] Create a sorting list node ISortedListNode{KT,VT} 
///            创建排序列表节点 ISortedListNode{KT,VT}
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// AutoCSer.Reflection.RemoteType keyType Keyword type 
///            关键字类型
            /// AutoCSer.Reflection.RemoteType valueType Data type
            /// int capacity Container initialization size 
///            容器初始化大小
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateSortedListNode = 21,
            /// <summary>
            /// [22] Create sorted collection node ISortedSetNode{KT} 
///            创建排序集合节点 ISortedSetNode{KT}
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// AutoCSer.Reflection.RemoteType keyType Keyword type 
///            关键字类型
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateSortedSetNode = 22,
            /// <summary>
            /// [23] Create a stack node IStackNode{T} (Last in, first out) 
///            创建栈节点（后进先出） IStackNode{T}
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// AutoCSer.Reflection.RemoteType keyType Keyword type 
///            关键字类型
            /// int capacity Container initialization size 
///            容器初始化大小
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateStackNode = 23,
            /// <summary>
            /// [24] Delete the node 
///            删除节点
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// 返回值 bool Returning false indicates that the node was not found 
///            返回 false 表示没有找到节点
            /// </summary>
            RemoveNode = 24,
            /// <summary>
            /// [25] Create a server registration node IServerRegistryNode 
///            创建服务注册节点 IServerRegistryNode
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// int loadTimeoutSeconds Cold start session timeout seconds 
///            冷启动会话超时秒数
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateServerRegistryNode = 25,
            /// <summary>
            /// [26] Create a service process daemon node IProcessGuardNode 
///            创建服务进程守护节点 IProcessGuardNode
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateProcessGuardNode = 26,
            /// <summary>
            /// [27] Creat a multi-hash bitmap client synchronization filter node IManyHashBitMapClientFilterNode 
///            创建多哈希位图客户端同步过滤节点 IManyHashBitMapClientFilterNode
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// int size Bitmap size (number of bits) 
///            位图大小（位数量）
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateManyHashBitMapClientFilterNode = 27,
            /// <summary>
            /// [28] Creat a multi-hash bitmap filter node IManyHashBitMapFilterNode 
///            创建多哈希位图过滤节点 IManyHashBitMapFilterNode
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// int size Bitmap size (number of bits) 
///            位图大小（位数量）
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateManyHashBitMapFilterNode = 28,
            /// <summary>
            /// [29] Delete the node 
///            删除节点
            /// string key Node global keyword 
///            节点全局关键字
            /// 返回值 bool Returning false indicates that the node was not found 
///            返回 false 表示没有找到节点
            /// </summary>
            RemoveNodeByKey = 29,
            /// <summary>
            /// [30] Create an archive node only IOnlyPersistenceNode{T} 
///            创建仅存档节点 IOnlyPersistenceNode{T}
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex index Node index information 
///            节点索引信息
            /// string key Node global keyword 
///            节点全局关键字
            /// AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeInfo nodeInfo Server-side node information 
///            服务端节点信息
            /// AutoCSer.Reflection.RemoteType valueType Archive data type 
///            存档数据类型
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.NodeIndex Node identifier, there have been a node is returned directly 
///            节点标识，已经存在节点则直接返回
            /// </summary>
            CreateOnlyPersistenceNode = 30,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Sort dictionary node interface 
///            排序字典节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(ISortedDictionaryNodeMethodEnum))]
        public partial interface ISortedDictionaryNode<KT,VT> { }
        /// <summary>
        /// Sort dictionary node interface 
///            排序字典节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum ISortedDictionaryNodeMethodEnum
        {
            /// <summary>
            /// [0] Clear all data 
///            清除所有数据
            /// </summary>
            Clear = 0,
            /// <summary>
            /// [1] Determine whether the keyword exists 
///            判断关键字是否存在
            /// KT key 
            /// 返回值 bool 
            /// </summary>
            ContainsKey = 1,
            /// <summary>
            /// [2] To determine whether the data exists, the time complexity is O(n). It is not recommended to call (since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            判断数据是否存在，时间复杂度 O(n) 不建议调用（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// VT value 
            /// 返回值 bool 
            /// </summary>
            ContainsValue = 2,
            /// <summary>
            /// [3] Get the quantity of data 
///            获取数据数量
            /// 返回值 int 
            /// </summary>
            Count = 3,
            /// <summary>
            /// [4] Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// KT key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{VT} 
            /// </summary>
            GetRemove = 4,
            /// <summary>
            /// [5] Remove keyword 
///            删除关键字
            /// KT key 
            /// 返回值 bool Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在
            /// </summary>
            Remove = 5,
            /// <summary>
            /// [6] Add snapshot data 
///            添加快照数据
            /// AutoCSer.KeyValue{KT,VT} value 
            /// </summary>
            SnapshotAdd = 6,
            /// <summary>
            /// [7] Add data
            /// KT key 
            /// VT value 
            /// 返回值 bool Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在
            /// </summary>
            TryAdd = 7,
            /// <summary>
            /// [8] Get data based on keywords 
///            根据关键字获取数据
            /// KT key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{VT} 
            /// </summary>
            TryGetValue = 8,
            /// <summary>
            /// [9] Get data based on keywords 
///            根据关键字获取数据
            /// KT[] keys 
            /// 返回值 VT[] 
            /// </summary>
            GetValueArray = 9,
            /// <summary>
            /// [10] Remove keyword 
///            删除关键字
            /// KT[] keys 
            /// 返回值 int The number of deleted keywords 
///            删除关键字数量
            /// </summary>
            RemoveKeys = 10,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Sort list node interface 
///            排序列表节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(ISortedListNodeMethodEnum))]
        public partial interface ISortedListNode<KT,VT> { }
        /// <summary>
        /// Sort list node interface 
///            排序列表节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum ISortedListNodeMethodEnum
        {
            /// <summary>
            /// [0] Clear all data 
///            清除所有数据
            /// </summary>
            Clear = 0,
            /// <summary>
            /// [1] Determine whether the keyword exists 
///            判断关键字是否存在
            /// KT key 
            /// 返回值 bool 
            /// </summary>
            ContainsKey = 1,
            /// <summary>
            /// [2] To determine whether the data exists, the time complexity is O(n). It is not recommended to call (since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            判断数据是否存在，时间复杂度 O(n) 不建议调用（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// VT value 
            /// 返回值 bool 
            /// </summary>
            ContainsValue = 2,
            /// <summary>
            /// [3] Get the quantity of data 
///            获取数据数量
            /// 返回值 int 
            /// </summary>
            Count = 3,
            /// <summary>
            /// [4] Get the container size 
///            获取容器大小
            /// 返回值 int 
            /// </summary>
            GetCapacity = 4,
            /// <summary>
            /// [5] Delete the keywords and return the deleted data 
///            删除关键字并返回被删除数据
            /// KT key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{VT} 
            /// </summary>
            GetRemove = 5,
            /// <summary>
            /// [6] Get the ranking position of the key word 
///            获取关键字排序位置
            /// KT key 
            /// 返回值 int A negative number indicates that the keyword was not found 
///            负数表示没有找到关键字
            /// </summary>
            IndexOfKey = 6,
            /// <summary>
            /// [7] Get the first matching data sort position (since cached data is a serialized copy of the object, the equality test is done by implementing IEquatable{VT}) 
///            获取第一个匹配数据排序位置（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// VT value 
            /// 返回值 int A negative number indicates that no matching data was found 
///            负数表示没有找到匹配数据
            /// </summary>
            IndexOfValue = 7,
            /// <summary>
            /// [8] Remove keyword 
///            删除关键字
            /// KT key 
            /// 返回值 bool Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在
            /// </summary>
            Remove = 8,
            /// <summary>
            /// [9] Delete the data at the specified sort index position 
///            删除指定排序索引位置数据
            /// int index 
            /// 返回值 bool Returning false indicates that the index is out of range 
///            返回 false 表示索引超出范围
            /// </summary>
            RemoveAt = 9,
            /// <summary>
            /// [10] Add snapshot data 
///            添加快照数据
            /// AutoCSer.KeyValue{KT,VT} value 
            /// </summary>
            SnapshotAdd = 10,
            /// <summary>
            /// [11] Add data
            /// KT key 
            /// VT value 
            /// 返回值 bool Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在
            /// </summary>
            TryAdd = 11,
            /// <summary>
            /// [12] Get data based on keywords 
///            根据关键字获取数据
            /// KT key 
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{VT} 
            /// </summary>
            TryGetValue = 12,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Sort collection node interface 
///            排序集合节点接口
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(ISortedSetNodeMethodEnum))]
        public partial interface ISortedSetNode<T> { }
        /// <summary>
        /// Sort collection node interface 
///            排序集合节点接口 (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum ISortedSetNodeMethodEnum
        {
            /// <summary>
            /// [0] Add data
            /// T value 
            /// 返回值 bool Returning false indicates that the keyword already exists 
///            返回 false 表示关键字已经存在
            /// </summary>
            Add = 0,
            /// <summary>
            /// [1] Clear all data 
///            清除所有数据
            /// </summary>
            Clear = 1,
            /// <summary>
            /// [2] Determine whether the keyword exists 
///            判断关键字是否存在
            /// T value 
            /// 返回值 bool 
            /// </summary>
            Contains = 2,
            /// <summary>
            /// [3] Get the quantity of data 
///            获取数据数量
            /// 返回值 int 
            /// </summary>
            Count = 3,
            /// <summary>
            /// [4] Get the maximum value 
///            获取最大值
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{T} No return value is returned when there is no data 
///            没有数据时返回无返回值
            /// </summary>
            GetMax = 4,
            /// <summary>
            /// [5] Get the minimum value 
///            获取最小值
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{T} No return value is returned when there is no data 
///            没有数据时返回无返回值
            /// </summary>
            GetMin = 5,
            /// <summary>
            /// [6] Remove keyword 
///            删除关键字
            /// T value 
            /// 返回值 bool Returning false indicates that the keyword does not exist 
///            返回 false 表示关键字不存在
            /// </summary>
            Remove = 6,
            /// <summary>
            /// [7] If the keyword does not exist, add the data 
///            如果关键字不存在则添加数据
            /// T[] values 
            /// 返回值 int The quantity of the added data 
///            添加数据数量
            /// </summary>
            AddValues = 7,
            /// <summary>
            /// [8] Remove keyword 
///            删除关键字
            /// T[] values 
            /// 返回值 int The quantity of deleted data 
///            删除数据数量
            /// </summary>
            RemoveValues = 8,
        }
}namespace AutoCSer.CommandService.StreamPersistenceMemoryDatabase
{
        /// <summary>
        /// Stack node interface (Last in, first out) 
///            栈节点接口（后进先出）
        /// </summary>
        [AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ServerNodeType(typeof(IStackNodeMethodEnum))]
        public partial interface IStackNode<T> { }
        /// <summary>
        /// Stack node interface (Last in, first out) 
///            栈节点接口（后进先出） (Node method sequence number mapping enumeration type)
        /// </summary>
        public enum IStackNodeMethodEnum
        {
            /// <summary>
            /// [0] Clear all data 
///            清除所有数据
            /// </summary>
            Clear = 0,
            /// <summary>
            /// [1] Determine whether there is matching data (Since the cached data is a serialized copy of the object, the prerequisite for determining whether the objects are equal is to implement IEquatable{VT}) 
///            判断是否存在匹配数据（由于缓存数据是序列化的对象副本，所以判断是否对象相等的前提是实现 IEquatable{VT} ）
            /// T value Data to be matched 
///            待匹配数据
            /// 返回值 bool 
            /// </summary>
            Contains = 1,
            /// <summary>
            /// [2] Get the quantity of data 
///            获取数据数量
            /// 返回值 int 
            /// </summary>
            Count = 2,
            /// <summary>
            /// [3] Add the data to the stack 
///            将数据添加到栈
            /// T value 
            /// </summary>
            Push = 3,
            /// <summary>
            /// [4] Get the next popped data in the stack (no popped data, only view) 
///            获取栈中下一个弹出数据（不弹出数据仅查看）
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{T} If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据
            /// </summary>
            TryPeek = 4,
            /// <summary>
            /// [5] Pop a piece of data from the stack 
///            从栈中弹出一个数据
            /// 返回值 AutoCSer.CommandService.StreamPersistenceMemoryDatabase.ValueResult{T} If there is no pop-up data, no data will be returned 
///            没有可弹出数据则返回无数据
            /// </summary>
            TryPop = 5,
        }
}
#endif